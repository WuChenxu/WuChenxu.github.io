<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[functional safety and cyber security]]></title>
    <url>%2F2018%2F05%2F11%2Fsafety-and-security%2F</url>
    <content type="text"><![CDATA[title: functional safety and cyber security categories: - safety - security tags: - safety - security comments: true layout: post date: 2018-05-11 22:03:39 modified: 2018-05-11 22:03:39 --- safety: 安全，侧重于防止系统的内部故障导致生命财产损失。 security： 安保/防护，侧重于防止外部侵入导致生命财产损失。 对应到汽车领域：functional safety(功能安全)与cyber security(网络安全) # overview functional safety: absence of unreasonable risk due to hazards caused by malfunctioning behavior of E/E systems. Cyber security : protection of systems from the theft and damage to their hardware, software or information, as well as from disruption or misdirection of the services they provide. {% asset_img overview_safety_security.png %} 功能安全还有个进化版本 SOTIF(Safety of the intended functionality, ISO21448). # method 功能安全和网络安全的方法都需要在考虑整个产品生命周期（life cycle）的基础上，从两个大的方面来实施：技术与流程。 {% asset_img methods_safety_security.png %} 功能安全的一些方法在ISO26262里有详细的推荐，包括硬件失效分析以及诊断方法，软件开发方法，测试方法等。 {% asset_img security_solutions.png %} {% asset_img safety_efforts.png %} # 举例 [CRC(Cyclic redundancy check)](https://en.wikipedia.org/wiki/Cyclic_redundancy_check) - safety point of view: data error detection [MAC(Message authentication code)](https://en.wikipedia.org/wiki/Message_authentication_code#Security) - security point of view：data autenticity check. References 1. [关于safety和security的翻译问题](https://www.zhihu.com/question/28426435?sort=created) 2. [Combining functional safety and cyber security](https://www.controleng.com/single-article/combining-functional-safety-and-cyber-security/) 3. [Functional safety and cyber security](https://vector.com/technologie-tage/files/VTT17_Grundlagenseminar_Security_Safety.pdf) 4. [The relevance of cyber-security to functional safety of connected and automated vehicles](http://www.umtri.umich.edu/sites/default/files/Safety.2014.Andre_.Weimerskirch_0.pdf)]]></content>
      <categories>
        <category>safety</category>
        <category>security</category>
      </categories>
      <tags>
        <tag>safety</tag>
        <tag>security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件开发(3):软件集成重名解决方案]]></title>
    <url>%2F2018%2F04%2F15%2Fintegrate-files-with-same-name-same-function-in-C%2F</url>
    <content type="text"><![CDATA[title: 软件开发(3):软件集成重名解决方案 categories: - software - build tags: - software - build - c-lang comments: true layout: post date: 2018-04-15 17:55:16 modified: 2018-04-15 17:55:16 --- 本文介绍了一种在软件集成过程中，遇到重名文件 和/或 重名函数时的解决方案。 # why 在[software development(2):variant handling](wuchenxu.com/2017/02/27/software-design-2-variant-handling/)一文中介绍了很多种variant管理的方法，其中有关于[link different libs](wuchenxu.com/2017/02/27/software-design-2-variant-handling/#link different libs)的方法。 设想如下场景：开发过程中（针对C语言），各个模块分别由不同的团队开发，最后集成的时候，如果遇到重名的函数怎么处理？ 本文针对这种场景，搜集了几种解决方案。 # what 场景设置: 三个模块，`a` `b` `os`，其中`a`和`b`模块都包含一个名字为`func_internal.c`的文件，这个同名文件中包含了名字一样的函数，分别为`int func_internal(void)`与`int func_internal(int a)`。这两个函数都没有申明为static，但是没有外部调用。 [demo in github](https://github.com/WuChenxu/C/tree/master/link2step) ``` . ├── README.md ├── component_a │ ├── exported_sym.list │ ├── func_a.c │ ├── func_internal.c │ ├── func_internal.h │ ├── functions.h │ ├── makefile │ └── redefine.syms ├── component_b │ ├── exported_sym.list │ ├── func_b.c │ ├── func_internal.c │ ├── func_internal.h │ ├── functions.h │ └── makefile ├── makefile ├── obj └── os ├── exported_sym.list ├── main.c └── makefile ``` {% include_code lang:c component_a/func_a.c link2steps/component_a/func_a.c %} {% include_code lang:c component_a/func_internal.c link2steps/component_a/func_internal.c %} {% include_code lang:c component_b/func_b.c link2steps/component_b/func_b.c %} {% include_code lang:c component_b/func_internal.c link2steps/component_b/func_internal.c %} # how ## 分析 1. 由于有文件重名，所以不能每个`.c`单独编译成`.o`，然后再链接； 出现两个同名的`.o`，要不然链接器报错，要不然只用了其中一个`.o`，这样会导致运行时异常。 1. 由于有函数重名，且函数没有申明为局部，链接的时候必然会出现错误： ``` duplicate symbol _func_internal in: component_a/func_internal.o component_b/func_internal.o ``` ## 解决方案 ### 编译 本文采用的方法： 每个模块单独编译成一个`.o`文件。 其他方法： 1. 重名文件改名；重名函数改名；局部函数申明为static。 1. 定义函数时定义visibility属性（GUN only） ``` __attribute__((visibility("hidden"))) ``` ### 链接 本文采用的方法： `-exported_symbols_list filename`(Mac) 或者 `--retain-symbols-file=filename`(linux) ```ld link all the .o in each component to one .o file; and only export symbols in the list ld -r -exported_symbols_list exported_sym.list ${OBJECTS} -o ${TARGET}.o ``` {% asset_img ld.png %} 其实是强制将符号表里的全局符号(`T`)变成了局部符号(`t`)，这样除了列表文件里的函数，其他对外均不可见。 其他方法： 1. gcc在链接时设置 -fvisibility=hidden，则不加 visibility声明的都默认为hidden; gcc默认设置 -fvisibility=default，即全部可见； 1. 使用export map，gcc -Wl,--version-script=export.map, 在export.map中指定 ``` { global:export_func; local:*; }; ``` ### objcopy 1. 将全局符号修改为局部符号： `-L symbolname` 1. 替换符号名 `--redefine-sym old=new` `--redefine-syms=filename` # recap 1. 由于C语言没有namespace的概念，可以在开发之前约定好，所有的`全局函数`和`全局变量`都加上特殊的前缀，eg. `CompanyName_ProductName_ComponentName_FunctionName`。 1. 所有的局部函数定义都加上static。 1. 可以先编译各个模块，再链接（类似于每个模块编译成静态库），这样可以防止重名的文件名报错。 1. 可以在链接的时候控制各个模块编译后全局函数，将内部使用的但没有申明为static的函数，在符号表中强制修改为local的符号。 1. 链接后，可以通过`objcopy`改变符号的属性（全局->局部）或者 修改全局符号的名字。 Reference： 1. [Choosing Visibility Options for Mac](https://developer.apple.com/library/content/technotes/tn2185/_index.html#//apple_ref/doc/uid/DTS10004200-CH1-SUBSECTION5) 1. [Introduction to symbol visibility](https://www.ibm.com/developerworks/aix/library/au-aix-symbol-visibility/index.html) 1. [man ld](http://www.man7.org/linux/man-pages/man1/ld.1.html) 1. [将两个GCC编译的.o目标文件合并到第三个.o文件中](http://www.it1352.com/539295.html) 1. [export obly centain functioins in a static lib](https://stackoverflow.com/questions/1506346/with-gcc-how-do-i-export-only-certain-functions-in-a-static-library) 1. [visibility of GCC](https://gcc.gnu.org/wiki/Visibility)]]></content>
      <categories>
        <category>software</category>
        <category>build</category>
      </categories>
      <tags>
        <tag>software</tag>
        <tag>build</tag>
        <tag>c-lang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Machine Learning笔记]]></title>
    <url>%2F2018%2F02%2F04%2Fmachine_learning_notes%2F</url>
    <content type="text"><![CDATA[title: Machine Learning笔记 categories: - AI tags: - AI comments: true layout: post date: 2018-02-04 20:38:54 modified: 2018-02-25 20:38:54 --- 学习吴恩达的machine learning课程笔记。 # resources ## website http://cs229.stanford.edu/ https://see.stanford.edu/Course/CS229 ## tool 商业软件[Matlab](https://www.mathworks.com/) or 免费开源软件[Octave](http://www.gnu.org/software/octave/) # 动机与应用 ## why？ 很多程序是无法手动编写出来的，eg. 手写文字识别，自动飞行器，自然语言处理NLP ## 应用 * learning algorithm容易实现手动无法编写程序的问题。 * learning algorithm在数据挖掘（data mining）有很好的效果，eg.电子化病例数据，帮助医生更好地决策 * zip code识别 * amazon，netflix推荐系统 ## machine learning definiton 1. Arthur Samuel (1959). Machine Learning: Field of study that gives computers the ability to learn without being explicitly programmed. `Checkers program` 1. Tom Mitchell (1998). Well-posed Learning Problem: A computer program is said to learn from experience E with respect to some task T and some performance measure P, if its performance on T, as measured by P, improves with experience E. ## 课程由4部分组成 ### Supervised Learning(监督学习) 监督学习中所有的样本都是带有标记的，“正确答案”已经在样本中。 1. regression problem（回归问题） 预测的值是连续（continuous）的。 {% asset_img regression_problem_continuous.png regression problem %} 2. classification problem（分类问题） 预测的值是离散（discreet）的,eg. SVM(supported vector machine) {% asset_img classification_problem_discreet.png classification problem %} ### Learning Theory learning algorith 为什么是有效的；可以证明什么时候（eg.多大的数据量）可以保证算法有效（eg.>99.9%的正确率)。 ### Unspervised Learning（无监督学习） 无监督学习的样本是不带有标记的，无监督学习需要从数据中自己发现特定的结构。 * [Cluster Analysis Algorithm](https://en.wikipedia.org/wiki/Cluster_analysis) 给定一个训练数据集，从中找到某种结构，即将数据集分为几个聚类。（让算法自己从数据中发现规律） * [ICA(Independent Component Analysis) Algorithm](https://en.wikipedia.org/wiki/Independent_component_analysis) Cocktail party problem 在嘈杂的鸡尾酒会区分不同人的语音 ```matlab [W,s,v] = svd((repmat(sum(x.*x,1),size(x,1),1).*x)*x'); ``` ### Reinforcement Learning（增强学习） reward function（回报函数） # Supervised Learning ## Linear regression {% asset_img supervised_learning_notation_1.png %} {% asset_img supervised_learning_notation_2.png %} {% asset_img supervised_learning_notation_3.png %} ### [Gradient descent](https://en.wikipedia.org/wiki/Gradient_descent) {% asset_img gradient_descent.png %} 随机选择一个点（特征参数），通过梯度算法找到下降最陡的方向，一步一步迭代，直到找到一个局部最优解（cost函数取最小值）。 如果初始化的值不一样，得到的局部最优解可能会不一样。 适用于：局部最优解等于全局最优解的情况，想象一个碗形的代价函数。 #### Batch gradient descent 每次迭代都要遍历所有的训练数据，适用于数据量小的训练集合。 {% asset_img batch_gradient_descent.png %} 这种迭代规则，称为LMS(Least Mean Squares) update rule. #### Stochastic gradient descent(Incremental gradient descent) 只需要遍历一次训练数据，适用于数据量很大的训练集合。 {% asset_img stochastic_gradient_descent.png %} $ \alpha $表示学习速率，训练的步进，可以随着梯度的下降，减小该值。 ### Normal equations 通过矩阵（matrix）的方法推导出的一种不需要迭代，直接可以计算出特征向量的方法。 {% asset_img normal_equation.png %} $(X^TX)$不可逆的可能原因： * 存在冗余特征（$\theta $中存在重复） * 特征数量n过多，训练样本数m太少 ### Non-parameterical learning algorithm * parameterical learning algorithm 的参数数量n是固定的，训练完成后不需要样本。 特征参数过少，导致欠拟合（underfitting）；特征数过多，导致过拟合（overfitting）。 可以通过Feature slection algorithm来自动选取特征参数。 * Non-parameterical learning algorithm 的参数数量n是随着样本数m的增加而增加的，每次输出结果都需要重新评估训练样本。 LWR(Locally weighted linear regressioin)是一种无参数的算法 {% asset_img LWR_1.png %} {% asset_img LWR_2.png %} ### Probabilistic interpretatioin 最小二乘法的概率学解释：假设误差服从正态分布（高斯分布），最小二乘法求得的特征参数，可以使代价函数最小。 ## Classification and logistic regression 除了y的取值是离散的之外，分类问题与线性回归问题类似。 ### Logistic regression #### sigmoid function {% asset_img logistic_regression_1.png %} {% asset_img logistic_regression_2.png %} {% asset_img logistic_regression_3.png %} #### Newton's method {% asset_img Newtons_method_1.png %} {% asset_img Newtons_method_2.png %} ### Perceptron learning algorithm {% asset_img perceptron_learning_algorithm.png %} ## GLM(Generalized Linear Models) ### Exponential family 之前的例子中，线性回归算法（最小二乘法）服从高斯分布，逻辑回归算法（sigmoid函数）服从伯努利分布。而这些都是GLM的一些特例。 {% asset_img exponential_family.png %} 以下分布都属于指数家族： 高斯分布（Gaussian）：结果是连续的 伯努利分布（Bernoulli）：结果是离散的，只有两种结果 多项式分布（multinomial）：结果是离散的，有k种结果 泊松分布（Poisson）：计数问题，eg.网站访客量，放射性衰变数目。 伽马分布（gamma）：时间间隔，eg.等公交车的时间 指数分布 beta分布 Dirichlet分布 ### Constructing GLMs 一个重要的设计决策是： {% asset_img GLM_design_decision.png %} #### Ordinary Least Squares 高斯分布在指数家族的表示如下： {% asset_img Gaussian_in_exponential_family.png %} 可以推导出，最小二乘法是GLM的一个特例： {% asset_img ordianary_least_squares_in_GLM.png %} #### Logistic regression 伯努利分布在指数家族表示如下： {% asset_img Bernoulli_in_exponential_family.png %} 可以推导出，逻辑回归是GLM的一个特例： {% asset_img logistic_regression_in_GLM.png %} #### Softmax regression 多项式分布在指数家族表示如下： {% asset_img multinomial_in_exponential_family.png %} softmax函数： {% asset_img softmax_functin.png %} 可以推导出，softmax回归是GLM的一个特例： {% asset_img softmax_regression_in_GLM.png %} logistic回归是softmax回归在k=2时的特例。 ## Generative learning algorithms * 判别（discriminative）学习算法 如逻辑回归，直接学习p(y|x)；或者如感知器算法（perceptron），直接尝试学习从输入到输出的映射（mapping）。 * 生成（generative）学习算法 对每种类别分别建模,然后通过贝叶斯公式计算出在给定x条件下y的后验分布。 {% asset_img generative_learning_algorithm_1.png %} {% asset_img generative_learning_algorithm_2.png %} ### GDA（Gaussian Discriminant Analysis） GDA假设p(x|y)服从多元正态分布（multivariate normal distribution）。 #### 多元正态分布 {% asset_img multivariant_normal_distribution_1.png %} {% asset_img multivariant_normal_distribution_2.png %} #### 高斯判定分析模型 {% asset_img GDA_1.png %} 通过计算最大化的似然函数，可以得到参数$\phi \mu_0 \mu_1 \Sigma$的值。 {% asset_img GDA_2.png %} #### GDA与逻辑回归 如果我们将$p(y=1|x;\phi, \mu_0, \mu_1, \Sigma)$视为$x$的函数，那么我们发现可以有如下表示形式： $$ p(y=1|x;\phi, \mu_0, \mu_1, \Sigma)={1 \over {1+exp(-\theta^T x)}}$$ 这就是逻辑回归---一种判定算法---用来给$p(y=1|x)$建模的形式。 也就是说，如果数据服从多元高斯分布，那后验分布是逻辑函数；反之，不成立。 如果$x|y=0 ~ Poisson(\lamda_0), x|y=1 ~Poisson(\lamda_1$,那么$p(y|x)$也是逻辑的（logistic）。 也就是说，如果数据服从泊松分布，那后验分布也是逻辑函数；反之，不成立。 逻辑回归对多元高斯分布，泊松分布等都有效。 相比逻辑回归，GDA使用了更强的（stronger）假设。 如果模型假设正确（服从多元高斯分布），那么GDA可以更好地fit数据，可以通过更少的数据达到更好的效果，这种情况下GDA是更好的模型； 与之相对，逻辑回归使用了更弱（weaker）的假设，所以逻辑回归更健壮（robust），且对不正确的模型假设更不敏感。 如果数据不符合高斯分布，使用GDA得不到更好的估算，此时使用逻辑回归更好。 ### 朴素贝叶斯算法（Naive Bayes） #### Naive Bayes * GDA的特征向量是连续的实数向量。 * Naive Bayes的特征向量是离散的值。 以垃圾邮件分类器（email span filter）为例,这个模型也称为多元伯努利事件模型（multi-variate Bernoulli event model）： {% asset_img NB_feature_vector_1.png %} {% asset_img NB_feature_vector_2.png %} 朴素贝叶斯算法假设： {% asset_img NB_assumption.png %} 朴素贝叶斯算法的参数： {% asset_img NB_1.png %} {% asset_img NB_2.png %} {% asset_img NB_3.png %} {% asset_img NB_4.png %} #### Laplace smoothing 设想如下场景： 一个从来没有在训练邮件中出现过的单词，但是这个单词在字典里，如果有一天收到一封邮件里包含这类单词。 会导致$\phi\_{i|y=1}=0$,且$\phi\_{i|y=0}=0$ 从而 $$ p(y=1|x) = {0 \over 0}$$ 这是一个未定义的值，无法作出估计。 {% asset_img Laplace_smoothing.png %} 计算明天太阳升起来的概率(假设太阳已经连续n天升起来了) 明天太阳不会升起来的概率： $$ \phi_0 = {1 \over n+2}$$ 明天太阳还会升起来的概率： $$ \phi_1 = {n+1 \over n+2}$$ #### Event models for text classification {% asset_img multinomial_event_model_1.png %} {% asset_img multinomial_event_model_2.png %} {% asset_img multinomial_event_model_3.png %} {% asset_img multinomial_event_model_4.png %} References: 1. [机器学习笔记03：Normal equation与梯度下降的比较](http://blog.csdn.net/artprog/article/details/51172025) 1. [深度学习算法原理——Softmax Regression](http://blog.csdn.net/google19890102/article/details/49738427) 1. [生成模型（Generative）和判别模型（Discriminative)](https://www.cnblogs.com/realkate1/p/5683939.html)]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ABZ计划]]></title>
    <url>%2F2017%2F12%2F31%2FABZ-Plan%2F</url>
    <content type="text"><![CDATA[title: ABZ计划 categories: - management tags: - management comments: true layout: post date: 2017-12-31 20:38:54 modified: 2017-12-31 20:38:54 --- {% asset_img ABZ_plan.png %} 今天是2017年最后一天了，可以按照`ABZ理论`好好计划一下2018年的计划了。 《至关重要的关系》(The Start-up of You)一书中提出的“ABZ计划”理论。 现在的世界变化太快（VUCA时代），我们需要一个人生规划：能让我们最大限度做好当前工作（A计划）；同时，在适当的时候可以转移到的下一份工作（B计划）；最差的情况，有个兜底的退路（Z计划）。 # A计划：当前的位置 A计划是当前正在从事的工作，是当前具有竞争优势的位置，并且值得持续投入。在A计划中，我们只需要对所学的知识技能做微调，并周期性地迭代。 # B计划：支点（Pivot Point） 你的支点是你围绕的中心，就像篮球运动员只要以一只脚为支撑点，可以在一个圆圈里自由移动。 B计划是当你需要改变目标或者改变达到目标的路径的时候，可以转换过去的支点。你可能因为A计划行不通或者发现了比A计划更好的机会，从而准想B计划。一旦你转向B计划，它就变成了新的A计划。 为什么需要B计划，因为这个时代变化太快，你不知道什么时候你的公司或者你所在的行业就会迎来拐点（inflection point）。这样根本性的变化会强迫你改变自己的技能或者换一个新的环境。因为拐点的不可预测性，为了减轻拐点到来时的冲击，我们可以未雨绸缪：建立个人的软技能，拥抱变化，随时准备快速切换的B计划。 最好的B计划通常与你当前所做的工作有所不同，但是又有很大的相关性。转换到相近的领域，既可以借力已有的技能，又可以在一个新的方向开发出新的技能。通常，需要利用晚上或者周末的时间。你可以在空余时间开始学习新的技能，并与相邻领域工作的人建立联系。 # Z计划：安全网 Z计划是你的安全撤退点（fallback point），你的救生船，它能让你承受失败的结果，并卷土重来。 如果你的职业生涯终结或者你的生活遭受重大变故，你的计划是什么？这就是Z计划。有了Z计划，你就可以在A计划和B计划里接受不确定性和风险。有了Z计划，你至少知道可以承受风险。没有Z计划，你可能在担心最坏情况的恐惧中束手束脚。 也许你会在恢复之前过一段简朴的生活，但是至少你知道不会无家可归，不会破产或者永远失业。 Z计划不是一个终点，它更像一张安全网，让你知道最差不过如此，这样你可以更加放心大胆地执行AB计划，甚至重新制定更加激进而不是更加保守的AB计划。 Reference： 1. [How to create an ABZ career plan mind map](http://mindmappingsoftwareblog.com/wp-content/bs-e197d/ABZ-Career-Plan-Map.pdf)]]></content>
      <categories>
        <category>management</category>
      </categories>
      <tags>
        <tag>management</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[技术炒作周期(Hype Cycle)]]></title>
    <url>%2F2017%2F09%2F21%2Fhype-cycle%2F</url>
    <content type="text"><![CDATA[title: 技术炒作周期(Hype Cycle) categories: - technical tags: - technical comments: true layout: post date: 2017-09-21 20:38:54 modified: 2018-12-08 17:38:54 --- Hype cycle直译过来是`炒作周期`的意思，是美国咨询公司Gartner从1995年开始每年发布的一个关于技术成熟度报告，从时间维度将技术的成熟度分成5个周期： `Innovation Trigger（萌芽期）` `Peak of Inflated Expectations（过热期）` `Trough of Disillusionment（低谷期）` `Slope of Enlightenment（复苏期）` `Plateau of Productivity（成熟期）`。 阿马拉法则（Amara's law）：人们常常高估技术的短期影响力，而低估技术的长期影响力。 Hype cycle可以看作是阿马拉法则的一种图像化描述。 Hype cycle可以看到不同技术随着时间的起起伏伏，也可以看到一项技术从萌芽到成熟的经过。 2018年Garnter整理的5个趋势 {% asset_img Trends_in_the_Emerging_Tech_Hype_Cycle_2018.png %} 历年的Garnter Hype Cycle图： {% asset_img Emerging-Technology-Hype-Cycle-for-2018.png %} {% asset_img Emerging-Technology-Hype-Cycle-for-2017.jpg %} {% asset_img Emerging-Technology-Hype-Cycle-for-2016.jpg %} {% asset_img Emerging-Technology-Hype-Cycle-for-2015.png %} {% asset_img Emerging-Technology-Hype-Cycle-for-2014.jpg %} {% asset_img Emerging-Technology-Hype-Cycle-for-2013.png %} {% asset_img Emerging-Technology-Hype-Cycle-for-2012.png %} {% asset_img Emerging-Technology-Hype-Cycle-for-2011.gif %} {% asset_img Emerging-Technology-Hype-Cycle-for-2010.png %} {% asset_img Emerging-Technology-Hype-Cycle-for-2009.jpeg %} References: 1. [Gartner hype clcle](http://www.gartner.com/technology/research/methodologies/hype-cycle.jsp) 2. [wiki hype cycle](https://en.wikipedia.org/wiki/Hype_cycle) 3. [AMARA'S LAW](https://spotlessdata.com/amaras-law) 4. [Hype Cycle for Emerging Technologies, 2018](https://www.gartner.com/smarterwithgartner/5-trends-emerge-in-gartner-hype-cycle-for-emerging-technologies-2018/)]]></content>
      <categories>
        <category>technical</category>
      </categories>
      <tags>
        <tag>technical</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序在哪里执行？]]></title>
    <url>%2F2017%2F05%2F30%2Fwhere-program-execute-in%2F</url>
    <content type="text"><![CDATA[title: 程序在哪里执行？ categories: - technical tags: - technical - software comments: true layout: post date: 2017-05-30 23:54:00 modified: 2017-06-15 23:54:00 --- 先上结论：计算机程序可以在ROM或者RAM里执行。 摘自RL78芯片datasheet： > The RL78/F13 and RL78/F14 incorporate the flash memory to which a program can be written, erased, and overwritten. The flash memory includes the “code flash memory”, in which programs can be executed, and the “data flash memory”, an area for storing data. 计算机设备，包括单片机，PC，DSP，FPGA等不同类型的电子设备，可以从ROM中执行程序（试想系统刚上电，也只有ROM中可以读取指令）。初始化完成后，为了提高执行速度可以将ROM中存储的程序到RAM中，再从RAM中执行。 由于RAM执行速度（～GHz）相较于NorFlash的XIP执行速度（～100MHz）快很多，所以如果RAM空间足够的情况下，从RAM执行程序速度更快。 但是由于成本原因，NorFlash在单片机（code flash一般从几K到几M大小）中作为存储程序的主存储器也是很常见的。 NorFlash支持XIP（[eXecute In Place](https://en.wikipedia.org/wiki/Execute_in_place)），CPU直接从NorFlash取指令、译码、执行。 NorFlash更像RAM，使用标准的存储接口，具有独立的地址总线和数据总线，支持随机访问，地址总线与数据总线共用；而NandFlash更像一个硬盘，需要特殊的驱动来访问，地址总线和数据总线是与I/O总线共享，只允许按页访问，。 NorFlash直接执行的设备，还是需要RAM的，因为NorFlash中只能存储不可变的指令或数据，运行过程中可变的数据还是需要存储在RAM中。 NorFlash的特点(线性存储空间，100%无坏点，随机访问)决定了支持XIP。 NorFlash的XIP最快执行速度～100MHz。 NorFlash的读取速度（～100ns）比NandFlash（us）快，NandFlash的擦除和写入速度比NorFlash快很多。 NandFlash只能保证98%无坏块（bad block），需要坏块处理；会有位翻转（bit-flipping）问题，需要EDC（Error Detection Code）/ECC（Error Correction Code）来检错纠错。 {% asset_img comparison_NOR_NAND.png %} * SRAM(Static Random Access Memory) - cache/register - faster but more expensive * DRAM(Dynamic Random Access Memory) - Main Memory - slower but cheaper 动态随机存取存储器，最为常见的系统内存。DRAM 只能将数据保持很短的时间。为了保持数据，DRAM使用电容存储，所以必须隔一段时间刷新（refresh）一次，如果存储单元没有被刷新，存储的信息就会丢失。 （关机就会丢失数据） * SDRAM(Synchronous Dynamic Random Access Memory): 同步动态随机存储器，同步是指内存工作需要同步时钟，内部的命令的发送与数据的传输都以它为基准. * DDR(Dual Data Rate) SDRAM:双倍速率同步动态随机存储器 * Flash * NorFlash * NandFlash * SD（Secure Digital）卡 * eMMC（embedded multi-media card） * SSD（Solid State Disk） * UFS（Universal Flash Storage） References： 1. [Flash Memory](https://en.wikipedia.org/wiki/Flash_memory) 2. [Execute In Place](https://en.wikipedia.org/wiki/Execute_in_place) 3. [norflash芯片内执行（XIP） ](http://www.blog.chinaunix.net/uid-26404697-id-3152290.html) 4. [Toshiba NAND vs. NOR Flash Memory Technology Overview](http://aturing.umcs.maine.edu/~meadow/courses/cos335/Toshiba%20NAND_vs_NOR_Flash_Memory_Technology_Overviewt.pdf) 5. [Two Flash Technologies Compared: NOR vs. NAND Two Flash Technologies Compared: NOR vs. NAND ](https://focus.ti.com/pdfs/omap/diskonchipvsnor.pdf) 6. [Does RAM access slow-down CPU?](https://superuser.com/questions/163425/does-ram-access-slow-down-cpu) 7. [flash-and-ram-code-execution](https://electronics.stackexchange.com/questions/102764/flash-and-ram-code-execution)]]></content>
      <categories>
        <category>technical</category>
      </categories>
      <tags>
        <tag>software</tag>
        <tag>technical</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程的事实与谬误 by Robert L·Glass]]></title>
    <url>%2F2017%2F05%2F12%2Freading-notes-3-Facts-and-fallacies-of-software-engineering%2F</url>
    <content type="text"><![CDATA[title: 软件工程的事实与谬误 by Robert L·Glass categories: - reading-notes tags: - reading-notes - technical comments: true layout: post date: 2017-05-12 23:54:00 modified: 2017-05-27 23:54:00 --- {% asset_img cover.jpg %} 软件工程的55个事实和5+5个谬误。 划重点： * 软件过程和软件产品的`复杂性`决定了我们在该领域的许多认识和行为。复杂性不可避免，我们不应该与之对立，而应该学会适应它。 * 在软件领域，糟糕的`估算`和由此带来的`时间表压力`一直在迫害我们。 * 在软件管理者和技术人员之间有`隔阂`。 * `鼓吹`和`通用`的观念影响了我们形成专注于有力的、明智的项目方案的能力。 # 管理 处于管理最底层且专长于干活的人通常比其他任何人有更大的威力。 ## 人员 1.`在软件开发中，最重要的因素不是程序员采用的工具和技术，而是程序员自身的质量。` CMM假设良好的过程会得到良好的软件。 Q：假如你的生命依靠某一软件，那么，关于该软件你最想知道什么？ A：与其他事情相比，我最想知道写该软件的人，这人一定才华横溢，严谨认真，狂热追求软件完美并按照需求运作。其他对我来说都是次要的。 2.`对“个体差异”的研究表明，最好的程序员要比最差的程序员强28倍之多，即使他们的报酬不同，优秀程序员也是软件业中最廉价的劳动力。` 3.`给延期的项目增加人手会使项目进一步延期。` Brooks法则，出自《人月神话》 4.`工作环境对工作效率和产品质量具有深刻影响。` 你必须找到优秀的人员并善待他们，特别是给她们提供舒适的环境。 ## 工具和技术 5.`夸大宣传是软件的瘟疫，多数软件工具对于效率和质量的提高幅度仅为5%～35%，但总有人反复说提高幅度是“数量级”的。` 6.`在学习新工具或者新技术的初期，程序员的工作效率和产品质量都会下降。只有克服了学习曲线之后，才可能得到实质性的收益。只有满足下面两个条件，采用新工具或者新技术才有意义：（a）新东西确实有用；（b）要想获得真正的收益，必须耐心等待。` 7.`软件开发者对于工具说的多，评估的少，买的多，用的少。` ## 估算 8.`项目失控的两个最主要的原因之一是糟糕的估算（另一个原因见事实23）。` 估算是确定项目成本和开发时间表的过程。 依靠专家---无论专家曾经做过什么项目，无论这些项目与当前项目何等相似，专家都不可能做出合理的推断（软件项目的重要特征之一是各个项目所解决的问题差异很大。） 依靠估算算法（复杂算法，Line of Code，Function Point）---采用一个假想的项目，按照各种建议算法输入相关数据，得到的结果差异很大（2～8倍）。 9.`许多估算是在软件生命周期开始时完成的。后来，我们才认识到在需求定义之前，即理解问题之前进行项目估算是不正确的；也就是说，估算时机是错误的。` 10.`许多软件项目都是由高层管理人员或者营销人员来估算，而不是由真正构建软件的人或者他们的主管来进行估算。因此，估算软件的人员是错误的。` 高级人员和营销人员搞“政治”预测；软件人员做“理性”预测。 许多（70%）估算是由与“人事部门”相关的人员完成的，很少（4%）由项目团队进行估算。 11.`软件估算很少根据项目进度进行调整。因此，这些估算通常是错误的人在错误的时间得出的错误结果。` 12.`因为估算的数据是如此糟糕，所以在软件项目不能达到估算目标时，不应该再考虑估算。但是无论如何，每个人都在考虑它。` 极限编程建议客户或者用户先确定成本、时间表、功能和质量这四个因素中的前三个，软件开发者再确定第四个。 我要求参与者完成一个小任务。我有意增加他的工作量，使工作时间不足。我希望参与者尽力正确地完成整体工作，这样他们会因为时间不够而得出一个未完成的作品。事实并非如此，这些参与者按照不可能的时间表勉强完成了工作。他们的作品粗糙而虚假，看起来完整但根本不可用。这说明人们为了满足不可能的时间表，以至于愿意为此牺牲作品的完整性和质量。 13.`在管理者和程序员之间存在隔阂。对于一个未满足估算目标的项目的调查表明：从管理者看来这是一个失败的项目，而在技术人员看来却是最成功的项目。` 根本就没有做过估计的项目进展速度最快，其次是技术人员做估计得项目，最糟糕的是由管理人员做估计。 在工作效率和驾驭感之间有非常强的关联性。也就是说，如果程序员感觉到能驾驭自己的结局，那么他们的工作效率会高很多。换句话说，高度控制的管理并不一定会得到最好的或者效率最高的项目。 14.`对于可行性调研的回答几乎总是“可行”。` ## 复用 15.`小规模的复用（子程序库）开始于50多年以前，这个问题已经得到很好的解决。` 16.`虽然每个人都认为大规模服用（组件）非常重要、非常急需，但是这个问题至今还没有基本解决。` 作者认为此问题无解，根源在于软件的多样性。 17.`大规模复用最好适用于相关的系统，也就是依赖于具体应用领域，这样就限制了它的应用范围。` 在一个更小的特定应用领域中采用大规模复用的方法，成功的概率就比较大。而在跨项目和跨应用领域中采用大规模复用方法的成功概率很小。（McBreen 2002）。 18.`有关复用问题，有两个“三倍法则”：（a）构建可复用的组件比使用组件难三倍；（b）在将组件收录到复用库并成为通用组件之前，应该在三个不同的应用中尝试使用该组件。` 19.`修改复用的代码特别容易引起错误。如果一个组件中超过20%～25%的代码需要修改，那么重新实现的效率会更高。` 20.`设计模式复用是解决代码复用中固有问题的一种方法。` 设计模式是对反复出现的问题以及该问题的解决方案的一种描述。 设计模式源于实践，而不是源于理论。 ## 复杂性 21.**`问题的复杂性每增加25%，解决方案的复杂性就增加100%。这不是一个可改变的条件（即使人们都努力降低复杂性），而是客观存在的。`** 22.`80%的软件工作是智力活动。相当大的比例是创造性的活动。很少是文书性的工作。` # 生命周期 生命周期（software life cycle）开始于`需求`的定义和开发，在这一阶段，定义和分析“什么”问题。接着是`设计`，在这一阶段确定如何解决问题。然后是`编码`，将设计转化为计算机上可运行的代码。随后，因为整个过程中极易出现错误，所以进行`错误消除`。最终，完成了全部测试之后，软件产品交付使用，便开始了`维护`. 不同的步骤形成了瀑布模型，螺旋模型等，这些模型只是将步骤的顺序调整，需求、设计、编码、错误消除和维护，这些步骤都需要完成。 ## 需求 23.`导致项目失控的两个最常见原因之一是不稳定的需求（另一个见事实8所说的项目估算失误）。` 24.`在产品完成时修订需求错误的代价最大，在开发早期修订需求错误的代价最小。` 错误在软件的存留时间越长，修订的代价越大。 怎么做？ * 计算机学者会坚持采用格式化的规格说明书技术； * 开发者则将复审放在首位； * 测试和质量人员要求有可测试的需求，并建立早期测试用例； * 系统分析员可能会要求采用建模的方法； * 极限编程者提倡在开发团队中吸纳一个客户代表。 25.`遗漏需求是最难修订的需求错误。` 最持久的软件错误是遗漏逻辑错误，它可以逃过软件测试过程，进入发布的产品中。遗漏需求会导致遗漏逻辑。 ## 设计 26.**`从需求转入设计时，因为制定方案过程的复杂性，会激增出大量的衍生需求（针对一种特定设计方案的需求）。设计需求时原始需求的50倍之多。`** 虽然大家都认为需求追溯很有必要，但是需求扩充在一定程度上影响了需求追溯。需求追溯是指在产品的各个阶段的制品中追溯原始需求。 27.`对于一个软件问题，通常不存在唯一的最佳设计方案。` > 在一个房间中坐满了顶级的软件设计人员，如果其中任意两个人达成一致，那就可以通过了。---Bill Curtis 28.`设计是一个复杂的、迭代的过程。最初的设计方案可能是错误的，当然也不是最优的。` “从难点开始”。 设计方案可能是启发式的、试验性的。 复杂的设计过程通常不能得出最佳的结果，但是我们必须尽力寻找一个“令人满意的”方案。找到最佳设计方案不可能或者代价太高，而“令人满意的”方案（而不是最佳方案）可以满足优秀设计标准，是值得（冒险）选择的解决问题的方法。 ## 编码 29.`从设计转到编码阶段时，设计者按照自己掌握的水平，已经将问题分解为“原语”。如果编程者和设计者不是同一个人，二者的“原语”不吻合，就会出问题。` 如果设计者的原语层次比编码者高，编码者无法将此设计作为起点。因此，编码者在真正编码之前需要花费时间完成额外的设计，填补中间的层次。 不要轻易将设计工作和编码工作分开。 30.`COBOL是一种糟糕的语言，但是其他的（用于商业数据处理的）语言也同样糟糕。` 31.`错误消除是软件生命周期中最耗时的阶段。` 对于许多软件产品而言，错误消除所用的时间比汇集需求、进行设计或编码都长，通常长一倍。 “需求-分析-编码-错误消除”所占比例：20-20-20-40 或者 25-25-20-30。 ## 测试 32.`普通程序员认为已经彻底测试过的软件其实只执行了55%～60%的逻辑路径。采用覆盖分析器等自动工具，可以将上述比例提高到85%～90，几乎不可能测试软件中100%的逻辑路径。` * 需求驱动测试（测试是否满足了所有需求） * 结构驱动测试（测试已构建的软件的所有组成部分是否正确运行） * 统计驱动测试（随机测试确定软件执行的时间和结果） * 风险驱动测试（测试确定是否已经消除了最主要的风险） 由于软件产品固有的复杂性，任何测试都不会是彻底的测试。因此，（a）测试工作实际上是一种折衷的活动，关键是作出适当的折衷选择；（b）许多重要软件的发行版中存在错误，这不足为奇（追求无瑕疵软件的想法是天真的）。 33.**`即使测试覆盖有可能达到100%，这种测试也不够。大约35%的错误是源于逻辑路径的缺失，还有40%的错误源于执行特定的路径组合。不可能实现100%的覆盖。`** 为了构建成功的、可靠的软件，需要综合采用多种错误消除方法，通常是越多越好。对于这个问题，没有神奇魔法。 34.`没有工具就无法做好错误消除工作。人们常用调试器，很少使用覆盖分析器等其他工具。` 35.`自动测试很少，也就是说有些测试可以也应该自动化，但是有许多测试任务不能自动完成。` 36.`程序员在程序中嵌入测试代码、目标代码中的编译参数等方法，都是测试工具的重要补充。` ## 评审和检查 37.`在运行第一个测试用例之前进行严格审查可以消除软件产品中多大90%的错误。` 要找到同一个错误，审查的成本低于测试的成本。 在软件生命周期各个阶段的产品都可以审查。 决定检查成败的关键不是采用形式化的过程，而是团队成员在审查过程中的严格程度和注意力集中程度。 38.`虽然严格审查有很多优点，但是不能也不应该代替测试。` 39.`通常认为，事后评审对于了解客户的满意程度和改进过程都很重要。但是很多软件公司不开展事后评审。` 软件业的智慧一直没有增长。 我们在疯狂追求新东西时，往往抛弃了许多旧东西（例如极限编程和敏捷开发等最新的软件方法倾向于拒绝老方法中积累的智慧）。 软件业一直忙于加速工作，以致于没有时间考虑如何做得更好，而不只是更快。 40.`同行评审涉及技术和社会两方面问题，忽视任何一方面都会产生严重的灾难。` 在评审过程中，参与者应该尽力熟知当前软件中的每一个决定和细节。 评审者必须从评审对象作者的角度来处理评审对象，而不是按照自己的方式，所以评审非常难。许多人穿上别人的鞋都寸步难行。 大多数人在软件产品中投入大量的情感和智力，因此如果被别人评头论足将会非常敏感。 禁止经理参加评审（他们倾向于评审开发者，而不是评审产品）； 禁止没有准备的人参加评审（他们会使有准备着失望，还会偏离主题）； 开发者不能作为评审主管（缩小可能涉及到开发者的自我因素）。 ## 维护 41.__`维护开支通常占软件成本的40%～80%（平均为60%）。因此，维护可能是软件生命周期中最重要的阶段。`__ 软件维护就是在发现错误时进行修订，并在必要时做修改。 > 古老的硬件会被抛弃，古老的软件每天都在使用。 42.__`增强功能大约占软件维护成本的60%，错误更正仅占17%。因此，软件维护的主体是在旧软件中加入新功能，而不是更正错误。`__ 60%: 改进，增强功能 18%: 适应性维护，即在改变工作环境时保证软件正常运行，如再另一台计算机上运行、在另一种操作系统上运行、与新的软件包交互、引入新设备等。 17%: 错误更正 5%: 为了使软件更容易维护所作出的维护工作（预防性维护Preventive Maintenance，重构refactoring） __60/60规则：60%的软件成本用于软件维护，维护成本60%用于功能增强。因此，增强旧软件是个大问题。__ 43.`维护是解决方案，而不是问题。` 假设软件维护只是修正错误，那么软件维护才是个问题。 只有维护才能解决在软件中独有的一个问题，即“我们已经构建了一个东西，但是现在需要一个稍微不同的东西。” 44.`比较软件开发和软件维护中的工作，除了维护中“理解现有的产品”这项工作之外，其他工作都一样。这项工作占据了大约30%的维护时间，是主要的维护活动，因此可以说维护比开发更难。` 45.__`更好的软件工程开发导致更多而不是更少的维护。`__ 与构建糟糕的系统相比，构建良好的系统更容易实现功能增强，这样人们对他们的修改更多，导致这些系统的维护时间更长。 如果我们把维护活动视为一种方案，那么维护越多越好。假如我们执意认为维护是一个问题，那么就无法将维护活动的增加视为一件好事。 # 质量 ## 质量 46.`质量是一组属性的组合。` 1. __可移植性__是指生成易于在不同平台之间移植的软件产品。 2. __可靠性__是指软件产品满足预期的要求，值得信赖。 3. __效率__是指软件产品在运行时间和空间消耗上的经济性。 4. __人类工程学__(又称为可用性)是指软件产品用起来既容易又舒服。 5. __可测试性__是指软件产品易于测试。 6. __易理解性__是指维护者易于理解软件产品。 7. __可修改性__是指维护者易于修改软件产品。 47.`软件质量不是用户满意、满足需求、满足成本和时间表目标，或者可靠性。` > 用户满意 = 满足需求 + 按时提交 + 适当的成本 + 产品质量 ## 可靠性 48. `绝大多数程序员都会犯某些错误。` 49.`错误通畅聚集在一起。` > 半数的错误发现在15%的模块中。 50.`没有唯一最好的消除软件错误的方法。` 51.`总会有残存的错误。我们的目标应该是消除严重错误，或者使之最少。` 一项2002年的研究：两个采用完全不同软件开发方法（一个团队使用传统方法，处于CMM4；另一个团队采用前卫的形式化方法）的团队都不能构建一个可靠性达到98%的简单产品。 关于残存错误： * 有经验的个人实践可以使错误的发生减少75% * 大约40%～50%的用户程序包含着较显著的缺陷。 * 你不会发现所有的bug 关于残存的严重错误： * 小于10%的错误导致90%故障的发生。 ## 效率 52.`效率主要来自于优秀的设计，而不是优秀的编码。` 数据结构是增加逻辑复杂性和改善数据访问效率之间的折衷。因此在设计阶段应认真选择正确的数据结构、文件结构或者数据库访问方法。 在设计阶段对效率的细微考虑比漂亮的编码更有意义。 53.`高级语言（High-order language，HOL）代码配合适当的编译器优化，大约可以达到汇编语言90%的效率。对于一些复杂的现代体系结构，效率更高。` 54.`在空间和时间之前存在折衷。通常，改进一方面会降低另一方面。` 三角函数：函数值列表，空间换时间。 Java: 编译后的字节码比机器码紧凑，但是时间效率很低；JIT（Just-In-Time）编译器可以将字节码编译为机器码。 # 研究 55.`许多软件研究者不是做调查，而是鼓吹。因此，（a）有些概念比鼓吹的糟糕、更少；（b）缺少有助于确定这些概念真实价值的评估性研究。` # 谬误 1.`你不能管理自己无法度量的东西。` 优秀的知识管理者趋向于定性度量，而非定量度量。 实际情况是度量对于软件管理非常重要，谬误存在于具体进行度量的手段和过程中。 2.`可以管理软件产品的质量。` 所有的质量属性都有很深刻的技术内容，只有技术人员才能处理这些技术内容。 3.`可以，也应该“忘我”地编程。` 我们不可能为了满足别人的需求来抑制自己的需求，我们也同样不太可能为了团队的利益而抑制自我。一个有效运行的系统必须承认人的个性，也必须在这些个性的范围内运作。 4.`工具和技术是通用（one site fits all）的。` 5.`软件需要更多的方法论。` 6.`要估算成本和时间表，应首先估算代码行数。` 7.`随机测试输入是优化测试的好方法。` 8.`如果有了足够多的关注，所有的bug都显而易见。` * 错误的深浅与查找错误的人数没有关系。 * 有关审查的研究表明：增加审查人数，发现错误数量的增加幅度会迅速减少。 * 没有数据表明这句话的正确性。 9.`估计将来的维护成本和做出产品更新的决策需要参考过去的成本数据。` 10.`教别人编程的方法是教别人写程序。` 就像写作一样，要先读后写。 * 要教授读代码，我们必须选择所读的范例。 * 要教授读代码，需要指导性的教科书，但是却没有。都是关于如何写代码的。 * 标准课程教授先写后读，形成了制度。 * 我们在软件中需要读代码的唯一时机是维护。维护很不受欢迎，理由之一是读代码是一项非常难的活动。发挥你的创造力写新代码比读别人的老代码有意思得多。 > 成为程序员最好的方法是写程序，研究别人所写的优秀的程序。。。我到计算机科学中心的垃圾桶里找到了他们操作系统的列表。 ---Bill Gates]]></content>
      <categories>
        <category>reading-notes</category>
      </categories>
      <tags>
        <tag>technical</tag>
        <tag>reading-notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一线架构师实践指南 by 温昱]]></title>
    <url>%2F2017%2F05%2F05%2Freading-notes-2-practice-guide-for-frontline-architects%2F</url>
    <content type="text"><![CDATA[title: 一线架构师实践指南 by 温昱 categories: - reading-notes tags: - reading-notes - technical comments: true layout: post date: 2017-05-05 23:54:00 modified: 2017-05-05 23:54:00 --- {% asset_img cover.png %} 本书从架构师实际困惑出发，提出一套具有可操作性的方法体系来解决这些问题，作者很擅长用图例、表格来阐述观点，让人很受用。 思维导图： {% asset_img 一线架构师实践指南.png %}]]></content>
      <categories>
        <category>reading-notes</category>
      </categories>
      <tags>
        <tag>technical</tag>
        <tag>reading-notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rust语言(4):格式化输出]]></title>
    <url>%2F2017%2F03%2F19%2FRust-lang-4-std-fmt%2F</url>
    <content type="text"><![CDATA[title: Rust语言(4):格式化输出 categories: - Rust - Python tags: - Rust - Python - fmt comments: true layout: post date: 2017-03-19 20:35:24 modified: 2017-03-19 20:35:24 --- 本文对比Rust与Python语言的格式化输出。 # 写在前面 本文所用Rust版本为`1.14.0`，Python为`2.7.12`。 可以使用在线编译调试工具来测试本文所举示例代码。 [Rust playground](https://play.rust-lang.org/) [Python playground](http://ideone.com/) # basic usage Rust与Python都可以用`{}`来表示将要被替换变量的占位符。 ## Rust * `print!`将格式化文本输出到控制台，不带换行符。 * `println!`将格式化文本输出到控制到，末尾加一个换行符。 * `format!`将格式化文本输出到字符串。 ```Rust Rust print!("{}.print is output to console w/o newline.", 1); print!("Continue..."); print!("\n"); println!("{}.println is string to console w/ newline.", 2); let str = format!("{}.format is output to a string.", 3); assert_eq!(str, "3.format is output to a string."); println!("{}", str); ``` ## Python2.7 * `print`来打印文本到控制台，末尾加一个换行符。 * `str.format()`将格式化文本输出到字符串。 ```Python Python2.7 print("{} world".format("Hello")) ``` # with arguments * more arguments * positional arguments * named arguments ```Rust Rust println!("{}, {}", "Hello", "world"); println!("{0}, this is {1}. {1}, this is {0}.", "Hellen", "Tom"); println!("{subject} {verb} {object}", object="the lazy dog", subject="the quick brwon fox", verb="jumps over"); ``` ```Python Python2.7 print("{},{}".format("hello", "world")) print("{0}, this is {1}. {1}, this is {0}.".format("Hellen", "Tom")) print("{subject} {verb} {object}".format(object="the lazy dog", subject="the quick brown fox", verb="jumps over")) ``` # special format |* 数字 *|* Rust格式 *|* Python格式 *|* 输出 *|* 描述 *| |:-------------:|:-------------:|:-----------------:|:-------------------:|:-------------------------:| | 3.1415926 | {:.2} | {:.2f} | 3.14 | 保留小数点后两位 | | 3.1415926 | {:+.2} | {:+.2f} | +3.14 | 带符号保留小数点后两位 | | -1 | {:+.2} | {:+.2f} | -1(R)/-1.00(P) | 带符号保留小数点后两位 | | -1.0 | {:+.2} | {:+.2f} | -1.00 | 带符号保留小数点后两位 | | 2.71828 | {:.0}} | {:.0f} | 3 | 不带小数 | | 5 | {:0>2}/{:02} | {:0>2d}/{:02d} | 05 | 数字补0 (填充左边, 宽度为2)| | 5 | {:x^10} | {:x^10d} | xxxx5xxxxx | 居中对齐 | | 5 | {:x]]></content>
      <categories>
        <category>Rust</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Python</tag>
        <tag>fmt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[software development(2):variant handling]]></title>
    <url>%2F2017%2F02%2F27%2Fsoftware-design-2-variant-handling%2F</url>
    <content type="text"><![CDATA[title: software development(2):variant handling categories: - software tags: - software comments: true layout: post date: 2017-02-27 21:11:23 modified: 2017-03-19 21:11:23 --- we should always avoid to use variant handling in software development, because one solution for all variants is the best solution.But sometimes we should compromise due to some limits. Here are some scenarios I can see now: 1. one platform solution for different microconroller/hardware. [pre-compile](#pre-compile). [link different libs](#link-different-libs) 1. confilict functions. [during-compile](#during-compile) 1. cross platform(algorithm development on PC, target is other MCU). [during-compile](#during-compile). [link different libs](#link-different-libs) 1. one ECU for different vehicle models. [one-time configuraton](#one-time-configuraton). [bootloader](#bootloader) 1. differnt Transmission type for one vehicle model. [constant configuration](#constant-configuration) # pre-compile copy choosed target files to target directory ```directory two targets(A and B),before compile copy targetA or targetB to copied_target, only files in copied_target are included in makefile _____componentA |______targetA |______targetB |______copied_target ``` # during-compile compile switch(macro) ```c compile switch #if (GS_MAJOR_VER == GS_TARGET_A) // implementation for GS_TARGET_A #else (GS_MAJOR_VER == GS_TARGET_B) // implementation for GS_TARGET_B #else #error "no such target" #endif ``` # on the fly ## one-time configuraton parameter is seleted by vehicle configuration shored in NVM/flash. ```c parametes in flash, variant in NVM typedef enum { varaint1_enm, variant2_enm }Variants; const VariantPar_st parameters[]={variant1_par, variant2_par};//all parametes for variants stored in flash g_variant_u8 = getVariant();//getVariant() read variant from NVM. if(varaint1_enm == g_variant_u8) { //load variant1 parameter or doing something special for variant1 } else { //loac variant2 paramter or doing something special for variant2 } ``` ## constant configuration ### Signal Multiplexing One signal in the frame is used as a multiplexor and the remaining payload is interpreted depending on the value of the multiplexor signal. {% asset_img signal_multiplexing.png %} ### adaptive algorithm differnt parameter according different condition(eg.temperature/huminity/speed...) # post-compile ## link different libs ```link check your linker user manual and link different lib according to different target -L{path to file containing library} -l${library name} ``` ## merge different parameters pre-condition: parameter size for different variants is the same ```txt executable file structure ------ Application area ------ Calibration area ------ ``` ```txt variant1.hex/exe ------ Application area ------ Calibration area for variant1 ------ ``` # version control manage by version tools using branch, development path. # deployment ## bootloader use bootloader to flash seperate calibartion data during End of Line according to different vehilce models. ```txt executable file structure ------ Bootloader area ------ Application area ------ Calibration area ------ ``` ## sample label different executable files for differnt ECUs. References: 1. [Extended Signal Multiplexing in DBC Databases](https://vector.com/portal/medien/cmc/application_notes/AN-ION-1-0521_Extended_Multiplexing_in_DBC_Databases.pdf)]]></content>
      <categories>
        <category>software</category>
      </categories>
      <tags>
        <tag>software</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人博客搭建hexo+github(9):本地搜索]]></title>
    <url>%2F2017%2F02%2F15%2FStatic-Blog-hexo-github-9-local-search%2F</url>
    <content type="text"><![CDATA[title: 个人博客搭建hexo+github(9):本地搜索 categories: - hexo tags: [hexo, github, blog] comments: true layout: post date: 2017-02-15 23:14:57 modified: 2017-02-15 23:14:57 --- 本地搜索，不需要依赖外部的搜索服务，简单易用。 # 安装hexo-generator-searchdb `npm install hexo-generator-searchdb --save` # 配置 在`hexo`(~不是主题的~)的 `_config.yml` 中增加配置 ``` search: path: search.xml field: post format: raw limit: 10000 ``` * path - file path. Default is search.xml . * field - the search scope you want to search, you can chose: * post (Default) - will only covers all the posts of your blog. * page - will only covers all the pages of your blog. * all - will covers all the posts and pages of your blog. * format - the form of the page contents, options are: * html (Default) - original html string being minified. * raw - markdown text of each posts or pages. * excerpt - only collect excerpt. * more - act as you think. * limit - define the maximum number of posts being indexed, always prefer the newest. # 效果 {% asset_img local_search_example.png %} Reference: 1. [hexo-generator-searchdb](https://www.npmjs.com/package/hexo-generator-searchdb)]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TeX(2):Mac下安装TeX]]></title>
    <url>%2F2017%2F02%2F15%2FTeX-2-MacTex%2F</url>
    <content type="text"><![CDATA[title: TeX(2):Mac下安装TeX categories: - TeX tags: - TeX comments: true layout: post date: 2017-02-15 21:37:13 modified: 2017-02-15 21:37:13 --- Mac下TeX环境搭建 简要步骤： 1. 下载[MacTeX](http://tug.org/mactex/)，MacTeX是基于TeX Live之上的封装，即下即装，即装即用。 2. 安装字库。由于我的latex文件原来是在windows下调试好字体的，所以一些字体在mac上是没有的，需要从windows把字库拷贝出来，在mac上安装好。 3. 执行`xelatex ／your／file.tex`。 没有错误就打完收工。 Reference: 1. [如何在 OS X 上使用 LaTeX ？](https://www.zhihu.com/question/20928639) 2. [TeX(1):简介](http://wuchenxu.com/2016/09/28/TeX-1-introduction/)]]></content>
      <categories>
        <category>TeX</category>
      </categories>
      <tags>
        <tag>TeX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人类简史：从动物到上帝 by 尤瓦尔·赫拉利]]></title>
    <url>%2F2017%2F01%2F30%2Freading-notes-1-history-of-humankind%2F</url>
    <content type="text"><![CDATA[title: 人类简史：从动物到上帝 by 尤瓦尔·赫拉利 categories: - reading-notes tags: - reading-notes - history comments: true layout: post date: 2017-01-30 13:09:04 modified: 2017-01-30 13:09:04 --- 在历史的路上，有三大重要革命：大约7万年前，“认知革命”（Cognitive Revolution）让历史正式启动。大约12000年前，“农业革命”（Agricultural Revolution）让历史加速发展。而到了大约不过是500年前，“科学革命”（Scientific Revolution）可以说是让历史画下句点而另创新局。这本书的内容，讲述的就是这三大革命如何改变了人类和其他生物。 {% asset_img cover_of_a_brief_history_of_humankind.jpg %} # 点评 作者论述了物理学诞生，到化学， 生物学的产生；意识革命之后开始有历史，产生了语言，人类能够互相沟通，创造出“虚构”的故事；农业革命后，文字出现，有了“想象的共同体”，能够大规模协作智人占据食物链顶端；金钱、帝国、宗教使得人类融合统一，构建全球秩序；科学革命，承认人类的无知，科技的飞速进步使得财富的总量大规模增加，人类也面临着生态环境恶化，人是否比以前幸福快乐的问题；但是未来的路怎么走 是人类内耗灭亡还是第二次生物学革命产生新物种，还是未知之数，毕竟历史只是历史，可以拓宽我们能的思维，但是未来的路还是要人类自己走。 作者以宏观的视角，纵观整个人类史，不但精通西方世界的历史，而且对东亚，南美的历史也是信手拈来，这是真正的从时间的维度全球的角度来看待的人类史。 # 历史年表 距今年代 * 135亿年 物质和能量出现。物理学的开始。 * 原子和分子出现。化学的开始。 * 45亿年 地球形成。 * 38亿年 有机生物形成。生物学的开始。 * 600万年 人类和黑猩猩最后的共同祖先。 * 250万年 非洲的人属开始演化。出现最早的石器。 * 200万年 人类由非洲传播到欧亚大陆。 * 演化为不同人种。 * 50万年 尼安德特人在欧洲和中东演化。 * 30万年 开始日常用火。 * 20万年 智人在东非演化。 * 7万年 认知革命。出现能够描述虚拟故事的语言。 * 历史学的开始。智人传播至非洲之外。 * 4.5万年 智人抵达澳大利亚。澳大利亚巨型动物绝种。 * 3万年 尼安德特人绝种。 * 1.6万年 智人抵达美洲。美洲巨型动物绝种。 * 1.3万年 弗洛里斯人绝种。智人成为唯一存活的人类物种。 * 1.2万年 农业革命。驯化动植物。 * 出现永久聚落。 * 5000年 出现最早的王国、文字和金钱。多神教信仰。 * 4250年 出现最早的帝国：萨尔贡大帝的阿卡德帝国。 * 2500年 出现最早的硬币：通用的金钱。 * 波斯帝国：普世的政治秩序（“为全人类的福祉而努力”）。 * 印度佛教：普世的真理（“让所有人类解脱痛苦”）。 * 2000年 中国汉帝国。地中海罗马帝国。基督教。 * 1400年 伊斯兰教。500年 科学革命。人类承认自己的无知，开始取得前所未有的能力。 * 欧洲人开始征服美洲和各大洋。整个地球形成单一历史场域。资本主义兴起。 * 200年 工业革命。家庭和社群被国家和市场取代。动植物大规模绝种。 * 现在 人类脱离了地球的疆域。 * 核武器威胁人类的生存。 * 生物开始越来越由智慧设计形塑，而非自然选择。 * 未来 智慧设计成为生命的基本原则？ * 智人被超人类取代？ # 第一部分 认知革命 ## 第一章 人类：一种也没什么特别的动物 从地球角度看，人类的历史其实很短。 > 不过就在6万年前，有一头母猿产下两个女儿，一头成了所有黑猩猩的祖先，另一头则成了所有人类的祖奶奶。 > 从大约200万年前到大约1万年前为止，整个世界其实同时存在多种不同人种。这其实也十分合理。就像今天，地球上还是有许多种的狐狸、熊或是猪，而在几十万年前的地球上，至少就有6种不同的人。从整个历史来看，过去多种人种共存其实是常态，现在地球上只有“一种人”，这才是异常。 > 庞大的大脑也是个庞大的负担。大脑结构脆弱，原本就不利于活动，更别说还得用个巨大的头骨把它装着。而且大脑消耗的能量惊人。对智人来说，大脑只占身体总重约2%～3%，但在身体休息而不活动时，大脑的能量消耗却占了25%。 这也是为啥人类历史上屡屡出现野蛮民族暴虐所谓文明国家。 > 因为大脑较大，远古人类付出的代价有两种：首先是得花更多时间寻找食物，其次是肌肉退化萎缩。这就像是政府把国防预算转拨给了教育，人类也把手臂二头肌所需的能量拨给了大脑里的神经元。对于在非洲草原上这究竟是不是个好策略，事先只能说无人能知。虽然黑猩猩要讲道理绝对讲不赢智人，但它却能直接把智人像个布娃娃一样扯个稀烂。 > 我们用两条腿直立行走。能够站起来，就更容易扫视整片草原，看看哪里有猎物或敌人，而且既然手不需负责移动身体，就能发挥其他用途，像是丢石块或是做信号。手能做的事情越多，可以说人就变得越厉害；于是人的演化也就越来越着重神经发展，也不断地对手掌和手指的肌肉做修正。于是，人类的手开始能够处理非常精细的任务，特别是能够生产、使用复杂的工具。 > 火带来的最大好处在于开始能够烹饪。有些食物，处于自然形态的时候无法为人类所消化吸收，像小麦、水稻、马铃薯，但正因有了烹饪技术，就成为我们的主食。黑猩猩要咀嚼生肉，每天得花上五个小时，但人类吃的是熟食，每天花上一小时就够。 ## 第二章 知善恶树 > 大约就是在距今7万到3万年前，出现了新的思维和沟通方式，这也正是所谓的认知革命。会发生认知革命的原因为何？我们无从得知。得到普遍认可的理论认为，某次偶然的基因突变，改变了智人的大脑内部连接方式，让他们以前所未有的方式来思考，用完全新式的语言来沟通。这次突变，几乎就像是吃了《圣经》里那棵知善恶树的果实一样。为什么这只发生在智人的DNA里，而没有发生在尼安德特人的DNA里？我们现在只能说这就是纯粹的偶然。 > 最常见的理论，认为人类语言最为灵活。虽然我们只能发出有限的声音，但组合起来却能产生无限多的句子，各有不同的含义。于是，我们就能吸收、储存和沟通惊人的信息量，并了解我们周遭的世界。 > 第二种理论，也同意人类语言是沟通关于世界的信息的方式。然而，最重要的信息不是关于狮子和野牛，而是关于人类自己。我们的语言发展成了一种八卦的工具。根据这一理论，智人主要是一种社会性的动物，社会合作是我们得以生存和繁衍的关键。对于个人来说，光是知道狮子和野牛的下落还不够。更重要的，是要知道自己的部落里谁讨厌谁，谁跟谁在交往，谁很诚实，谁又是骗子。 > 人类语言真正最独特的功能，并不在于能够传达关于人或狮子的信息，而是能够传达关于一些根本不存在的事物的信息。据我们所知，只有智人能够表达关于从来没有看过、碰过、耳闻过的事物，而且讲得煞有其事。 > 在认知革命之后，智人就能够说出：“狮子是我们部落的守护神。” > “讨论虚构的事物”正是智人语言最独特的功能。“虚构”这件事的重点不只在于让人类能够拥有想象，更重要的是可以“一起”想象，编织出种种共同的虚构故事，不管是《圣经》的《创世记》、澳大利亚原住民的“梦世记”（Dreamtime），甚至连现代所谓的国家其实也是种想象。这样的虚构故事赋予智人前所未有的能力，让我们得以集结大批人力、灵活合作。 > 即使到了今天，人类的团体还是继续受到这个神奇的数字影响。只要在150人以下，不论是社群、公司、社会网络还是军事单位，只要靠着大家都认识、彼此互通消息，就能够运作顺畅，而不需要规定出正式的阶层、职称、规范。 > 无论是现代国家、中世纪的教堂、古老的城市，或者古老的部落，任何大规模人类合作的根基，都在于某种只存在于集体想象中的虚构故事。 法人 > 标致公司只是我们的一个集体想象，这种想象在法律上称为“法律拟制”（legal fiction）。像是公司，我们没办法明确指着它，它不是一个实体对象，而是以一种法律实体的方式存在。这种法律实体就像你我，会受到所在国家法律的管辖，可以开立银行账户，拥有自己的财产，要纳税，也可能独立于所有拥有者或员工之外而遭到起诉。 > 事实就是所有动物只有智人能够进行贸易，而所有我们有详细证据证明存在的贸易网络都明显以虚构故事为基础。例如，如果没有信任，就不可能有贸易，而要相信陌生人又是件很困难的事。今天之所以能有全球贸易网络，正是因为我们相信着一些虚拟实体，像是美元、联邦储备银行，还有企业的商标。而在部落社会里，如果两个陌生人想要交易，往往也得先借助共同的神明、传说中的祖先或图腾动物建立信任。 {% asset_img chapter2.jpg %} > 和认知革命正是历史从生物学中脱离而独立存在的起点。在这之前，所有人类的行为都只称得上是生物学的范畴，也有人喜欢称为“史前史”（但我倾向避免用这个词汇，因为这种说法暗示着即使在认知革命之前，人类也是自成一格，与其他动物不同）。认知革命之后，我们要解释智人的发展，依赖的主要工具就不再是生物学理论，而改用历史叙事。就像是如果要理解为何儒家或共产主义能在中国传播，光知道基因、荷尔蒙和有机体这些还不够，另外也得考虑到各种想法、图像幻想的互动才行。 > 讲到认知革命之后生物学和历史的关系，我们可以简单整理成三点： 1. 基本上，生物学为智人的行为和能力设下了基本限制，像是定出了一个活动范围，而所有的历史都在这个范围之内发生。 2. 然而，这个范围非常大，能让智人有各种惊人的发挥空间。因为他们有创造虚构故事的能力，就能创造出更多、更复杂的游戏，代代相传也就不断发展精进。 3. 因此，想了解智人的行为，就必须描述人类行为的历史演化。 ## 第三章 亚当和夏娃的一天 > 演化心理学近来发展蓬勃，认为现在人类的各种社会和心理特征早从农业时代之前就已经开始形塑。这个领域的学者认为，即使到了现在，我们的大脑和心灵都还是以狩猎和采集的生活方式在思维 > 就算我们今天可能住在高楼大厦，家家户户的冰箱早就塞满食物，我们的DNA还记得那些在草原上的日子。正因如此，我们才会不知不觉就吃完一整桶的哈根达斯，可能还配着一大杯可口可乐。 > `语言和文化`正是认知革命的主要成就。而正因为虚构故事已经出现，即使是在类似的生态、同样的基因组成下出现的人类，也能够创造出非常不同的想象现实，表现出来就成了不同的规范和价值观。 ## 第四章 毁天灭地的人类洪水 > 对这些动物来说，需要靠演化才能学会惧怕人类，但时间根本不够，它们转眼便已灭绝。 > 智人的第一波殖民正是整个动物界最大也最快速的一场生态浩劫。 > 第一波的灭绝浪潮是由于采集者的扩张，接着第二波灭绝浪潮则是因为农民的扩张；这些教训，让我们得以从一个重要观点来看今日的第三波灭绝浪潮：由工业活动所造成的物种灭绝 # 第二部分 农业革命 ## 第五章 史上最大骗局 > 这一切在大约1万年前全然改观，人类开始投入几乎全部的心力，操纵着几种动植物的生命。从日升到日落，人类忙着播种、浇水、除草、牧羊，一心以为这样就能得到更多的水果、谷物和肉类。这是一场关于人类生活方式的革命：农业革命。 > 即使到了今天，虽然人类有着种种先进科技，但食物热量超过90%的来源仍然是来自人类祖先在公元前9500年到公元前3500年间驯化的植物：小麦、稻米、玉米、马铃薯、小米和大麦。在过去2000年间，人类并没有驯化什么特别值得一提的动植物。可以说，人到现代还有着远古狩猎采集者的心，以及远古农民的胃。 > 普遍来说，农民的工作要比采集者更辛苦，而且到头来的饮食还要更糟。农业革命可说是史上最大的一桩骗局。 > 真正的主要嫌疑人，就是那极少数的植物物种，其中包括小麦、稻米和马铃薯。人类以为自己驯化了植物，但其实是植物驯化了智人。 > 智人的身体演化目的并不是为了从事这些活动，我们适应的活动是爬爬果树、追追瞪羚，而不是弯腰清石块、努力挑水桶。于是，人类的脊椎、膝盖、脖子和脚底就得付出代价。研究古代骨骼发现，人类进到农业时代后出现了大量疾病，例如椎间盘突出、关节炎和疝气 > 如果要衡量某种物种演化成功与否，评断标准就在于世界上其DNA螺旋的拷贝数的多寡。 活下去就是胜利 > 这正是农业革命真正的本质：让更多的人却以更糟的状况活下去。 > 每个世代的人做出了当时最好的抉择，最后的结果不一定是最好的，至少某些方面不是。 每一代人都只是继续着上一代生活的方式，在这里修一点，那里改一些。但矛盾的是，一连串为了让生活更轻松的“进步”，最后却像是在这些农民的身上加了一道又一道沉重的枷锁。 积重难返 > 为什么他们不赶快放弃农耕，回到采集生活？部分原因在于，所有改变都必须点点滴滴累积，经过许多代的时间，才能够改变社会；等到那个时候，已经没有人记得过去曾经有不同的生活方式可选了。另一部分，是因为人口增长就像是破釜沉舟。一旦采用农耕之后，村落的人口从100人成长到110人，难道会有10个人自愿挨饿，好让其他人可以回到过去的美好时光？这已经再无回头路。人类发现时，已经深陷陷阱、无法自拔。 > 多少年轻的大学毕业生投身大企业、从事各种劳心劳力的工作，发誓要努力赚钱，好在35岁就退休，去从事他们真正有兴趣的事业？但等他们到了35岁，却发现自己背着巨额贷款，要付子女的学费，要养在高级住宅区的豪宅，每家得有两部车，而且觉得生活里不能没有高级红酒和国外的假期。他们该怎么做？他们会放下一切，回去野外采果子挖树根吗？当然不可能，而是加倍努力，继续把自己累得半死。 > 这个关于奢侈生活陷阱的故事，告诉我们一个重要的教训。人类一心追求更轻松的生活，于是释放出一股巨大的力量，改变了世界的面貌，但结果并没有任何人料想得到，甚至也不是任何人所乐见的。并没有人在背后操纵农业革命发生，或是意图让人依赖谷类维生。一开始只是各种小事，主要就是希望吃饱一点、生活安全一点，但最后累积引起的效应，就是让远古的采集者开始花上整天的时间，在烈日之下挑水务农。 > 贝克力石阵显示，很有可能其实是先建立起信仰中心，之后才围绕着它形成村子。 不幸的是，演化观点并不是唯一判断物种成功与否的标准。它一切只考虑到生存和繁殖，而不顾个体的痛苦或幸福。虽然就演化而言，驯化的鸡和牛很可能是最成功的代表，但它们过的其实是生物有史以来最惨的生活。动物的驯化是建立在一系列的野蛮作为上，而且随着时间的前行，残忍程度只增不减。 > 在许多新几内亚的部落社会里，想判断一个人富不富有，就要看他/她有几头猪。而为了确保猪跑不掉，新几内亚北部的农民会把猪的鼻子切掉一大块。这样一来，每次猪想闻东西，都会感到强烈的疼痛，不但无法觅食，甚至连找路都做不到，于是不得不完全依赖人类主人。在新几内亚的另一个地区，人们甚至还习惯直接把猪的眼睛挖掉，杜绝它们逃跑的可能。 ## 第六章 盖起金字塔 这就跟人的经验是一样的。经验越多看似好事，但是也限制了其他可能性。思维定式，路径依赖 > 人类发现自己已经很难离开这些人工岛屿了，所有的房子、田地、谷仓，放弃哪个都可能带来重大的损失。此外，随着时间过去，他们拥有的东西越来越多，不易搬运，也把他们绑得死死的。 知道从哪儿来，才能知道要到哪儿去。 > 农业革命之后，“未来”的重要性被提到史上新高。农民不仅时时刻刻都得想着未来，还几乎可以说是为了未来在服务。 正是这些征收来的多余食粮，养活了政治、战争、艺术和哲学，建起了宫殿、堡垒、纪念碑和庙宇。 > 所有这些合作网络，不管是古代美索不达米亚的城市，还是秦朝和古罗马的帝国，都只是“由想象所建构的秩序”。支持它们的社会规范既不是人类自然的天性本能，也不是人际的交流关系，而是他们都相信着共同的虚构神话故事。 > 不管是汉谟拉比还是美国的开国元勋，心中都有个想象的现实，想象着这个世界有着放诸四海皆准、永恒不变的正义原则（例如平等或阶级），但这种不变的原则其实只存在于智人丰富的想象力里，只存在于他们创造并告诉彼此的虚构故事中。这些原则，从来就没有客观的正确性。 > 伏尔泰就曾说：“世界上本来就没有神，但可别告诉我的仆人，免得他半夜偷偷把我宰了。 > 1. 想象建构的秩序深深与真实的世界结合。 2. 想象建构的秩序塑造了我们的欲望。 3. 想象建构的秩序存在于人和人之间思想的连接。 > “主体间”事物的存在，靠的是许多个人主观意识之间的连接网络。就算有某个人改变了想法，甚至过世，对这项事物的影响并不大。但如果是这个网络里面的大多数都死亡或是改变了想法，这种“主体间”的事物就会发生改变或是消失。之所以会有事物存在于主体之间，其目的并不是想存心骗人，也不是只想打哈哈敷衍。虽然它们不像放射线会直接造成实质影响，但对世界的影响仍然不容小觑。历史上有许多最重要的驱动因素，都是这种存在于主体之间的概念想法：法律、金钱、神、国家。 为了改变现有由想象建构出的秩序，就得先用想象建构出另一套秩序才行。 > 每一次我们以为自己打破了监狱的高墙、迈向自由的前方，其实只是到了另一间更大的监狱，把活动范围稍稍加以扩大。 ## 第七章 记忆过载 > 因为智人的社会秩序是通过想象建构，维持秩序所需的关键信息无法单纯靠DNA复制就传给后代，需要通过各种努力，才能维持种种法律、习俗、程序、礼仪，否则社会秩序很快就会崩溃。 > 正因为结绳语有效又准确，就算在西班牙人占领南美之后，还是用结绳语来管理他们建立的新帝国。 > 文字对人类历史所造成最重要的影响：它逐渐改变了人类思维和看待这个世界的方式。过去的自由连接、整体思考，已经转变为分割思考、官僚制度。 ## 第八章 历史从无正义 > 是人类创造出了由想象建构的秩序、发明了文字，以这两者补足我们基因中的不足。 > 讽刺的是，非洲人在基因上的优势（免疫力）竟造成了他们在社会上的劣势：正因为他们比欧洲人更能适应热带气候，反让他们成了遭到欧洲主人蹂躏的奴隶！由于这些环境因素，美洲的新兴社会也出现了另一个种姓阶级：欧洲白人的统治阶级，以及非洲黑人的奴隶阶级 > 黑人被困在这个恶性循环里，他们申请不到白领的工作，是因为别人以为他们笨，但证明他们笨的，又是因为白领中很少有黑人。 > 大多数社会政治阶级制度其实都没有逻辑或生物学的基础，不过就是由历史的偶然事件引起，再用虚构的故事延续壮大。这正是历史值得研究的一个很好的理由。 > 我们究竟要如何才能判断，什么是真正在生物学上有所不同，而什么又只是人类说得煞有介事、自找借口？一项黄金法则就是“天生带来允许，文化造成封闭”。天生自然的生物学，可能性几乎无穷无尽。然而，文化却要求必须实现某些可能性，而又封闭了其他可能性。例如女性天生能生小孩，但在某些文化里，女性却是非生不可。生物学上，男人就是能从彼此身上得到性愉悦，但某些文化却极力阻止他们实现这种可能。 # 第三部分 人类的融合统一 ## 第九章 历史的方向 > 人类几乎从出生到死亡都被种种虚构的故事和概念围绕，让他们以特定的方式思考，以特定的标准行事，想要特定的东西，也遵守特定的规范。就是这样，让数百万计的陌生人能遵照着这种人造而非天生的直觉，合作无间。这种人造的直觉就是“文化”。 > 自从法国大革命之后，全球人民逐渐同意“自由”和“平等”都是基本的价值观。然而这两者根本就互相抵触！想要确保“平等”，就得限制住那些较突出的人；而要人人都能“自由”，也就必然影响所有人的平等。 > 一般认为认知失调是人类心理上的一种问题，但这其实是一项重要的特性，如果人真的无法同时拥有互相抵触的信念和价值观，很可能所有的文化都将无从建立，也无以为继。 > 三种全球秩序，首先第一种是经济上的货币秩序，第二种是政治上的帝国秩序，而第三种则是宗教上的全球性宗教，像是佛教、基督教和伊斯兰教。 ## 第十章 金钱的味道 > 在以物易物的经济里，不管是鞋匠还是种苹果的，每天都得搞清楚几十种商品的相对价格。如果市场上有100种不同的商品，把汇率列出来就足足有洋洋洒洒的4950条。如果市场上有1000种不同的商品，汇率更足足有499500条！这怎么可能记得起来？ > 人们之所以愿意如此，正是因为他们接受了这个集体的想象。“信任”正是所有金钱形式最基本的原料。如果有个富裕的农民卖掉房舍田产换来一袋贝壳，还带着这袋贝壳前往远地的省份，那是因为他相信抵达之后，其他人会愿意用稻米、房屋和田地和他交换这些贝壳。所以，可以说金钱就是一种相互信任的系统，而且还不是随随便便的某种系统：金钱正是有史以来最普遍也最有效的互信系统。 ## 第十一章 帝国的愿景 > 要建立和维系帝国，确实通常就有惨烈的屠杀，而幸存者也会受到残酷的压迫。帝国的标准配备，常常就包括战争、奴役、驱逐和种族屠杀。 > 虽然居鲁士还是会强调统治者和被统治者之间的种族和文化差异，但认为整个世界基本上为一体，同样一套原则可以适用于所有时间地点，而且所有人类应互相负责。于是，人类就像是一个大家庭：父母享有特权，但同时也要负责孩子的幸福。这种新的帝国思想从居鲁士和波斯人传给了亚历山大大帝，再传给希腊国王、古罗马皇帝、穆斯林哈里发、印度君主，最后甚至还传给苏联总理和美国总统。 > 有一则著名的逸事，讲的是有个印度人雄心勃勃，把英语学得无懈可击，上了西式舞蹈的课程，甚至还养成了用刀叉进食的习惯。他把这一切学好之后前往英格兰，在伦敦大学学院读法律，还成为一名合格的律师。然而，后来这个读法律的年轻人到了英属南非，穿着西装、打着领带，却因为坚持自己该坐头等车厢，而不是像他一样的“有色人种”该坐的三等车厢，便被赶下火车。这个人就是甘地。 {% asset_img chapter11.jpg %} ## 第十二章 宗教的法则 ### 当崇拜对象是神 > 真正让多神论与一神论不同的观点，在于多神论认为主宰世界的最高权力不带有任何私心或偏见，因此对于人类各种世俗的欲望、担心和忧虑毫不在意。因此，要向这个最高权力祈求战争胜利、健康或下雨，可以说是完全没有意义，因为从他全知全观的角度来说，某个王国的战争输赢、某个城市的兴衰胜败，又或是某个人的生老病死，根本不构成任何差别。希腊人不会浪费祭品去祭拜命运女神，而印度教徒也并未兴建寺庙来祭拜阿特曼。要接近这个宇宙至高的权力，就代表要放下所有的欲望、接受福祸共存的事实，坦然面对失败、贫穷、疾病和死亡。 > 事实证明，就算把这些迫害的所有受害者全部加起来，在这3个世纪间，多神教古罗马处决基督徒的人数不超过几千人。但相对的是，在接下来的1500年间，虽然基督教号称主张爱与怜悯，但仅仅对信仰的诠释有些许差异，就引发基督徒自相残杀，死亡人数达到数百万。 > 在过去两千年间，一神论者多次发动以暴力消灭其他竞争对手的战争，目的就是要加强自己的掌控。 > 就像是泛神论会继续在多神论里延续，多神论也继续在一神论里存活。 > 一神论宗教大张旗鼓把其他神祇从大门赶了出去，但又从旁边的小窗把他们迎了回来。以基督教为例，就发展出了自己的圣人系统，但这套系统可说和多神教几乎殊无二致。 英格兰的守护圣人是圣乔治，苏格兰是圣安德鲁，匈牙利是圣史蒂芬，而法国是圣马丁。 > 这样看来，基督教的圣人和多神教的那些神祇几乎没有两样。但很多时候甚至还不只是类似而已，而根本就是这些神祇的伪装。举例来说，在信奉基督宗教之前，爱尔兰的主神是女神布里基德。等到爱尔兰被基督教化，就连布里基德也仿佛受了洗一样，成了“圣布里基德”。而且直到今天，还是天主教爱尔兰最受尊崇的圣人。 > “恶的难题”（Problem of Evil），苦苦无法解决。“为什么世界上会有邪恶？为什么有苦难？为什么会有坏事发生在好人身上？”如果神真的是如此无所不知、无所不能、事事完美，又怎么会允许世界上有这么多的苦难？ > “法则的难题”（Problem of Order）。如果世上就是有善恶两股力量在拉扯，它们拉扯的基础是什么法则？ "马自达“汽车的来源 > 善神阿胡拉·马兹达（Ahura Mazda） 从历史的角度看宗教 > 从历史上来看，一神论就像是个万花筒，承继了一神论、二元论、多神论和泛神论，收纳在同一个神圣论述之下。结果就是，基督徒大致上是信奉一神论的上帝，相信二元论的魔鬼，崇拜多神论的圣人，还相信泛神论的鬼魂。像这样同时有着不同甚至矛盾的思想，而又结合各种不同来源的仪式和做法，宗教学上有一个特别的名称：综摄（syncretism）。很有可能，综摄才是全球最大的单一宗教。 ### 崇拜对象时自然法则 > 在公元前1000年，亚非大陆开始出现全新的宗教及信仰类型。这些新型宗教信仰包括印度的耆那教（Jainism）和佛教，中国的道教和儒教，以及地中海的犬儒主义（Cynicism）和享乐主义（Epicureanism），共同的特征就是崇拜的并非神祇。 > 这些信仰也认为有某种超人类秩序控制着这个世界，但它们所崇拜的这个秩序是自然法则，而不是什么神圣的意志。这些自然法则的宗教信仰虽然某些也相信有神祇存在，但认为神祇就和人类、动物和植物一样会受到自然法则的限制。虽然神祇可以说在这个生态系统中有其优势（就算是大象或豪猪，也各有优势），但他们也像大象一样，并无法改变自然的法则。 现在人的小心思，喜怒哀乐，其实前人都有过，都经历过，思考过，并且给出了解决方案。只是每一代人都有自己独特的生存环境，都觉得自己是独特的，之前的解决方案不适合自己，也许到最后会得出同前人一样的结论。没办法，不经历过，怎知是非对错 > 人类追求财富和权力，获得知识和财富，生儿育女，建起宫殿和房屋。但不论取得多少成就，却仍然无法满足。穷人梦想着要变富，有一百万的想要两百万，有两百万的想要一千万。而且就算真的有钱了、有名了，他们还是不满意，还是有无尽的烦恼和忧虑，无法从生老病死中解脱 最后他体会到，一切苦难并非来自噩运、社会不公或是神祇的任性，而是出于每个人自己心中的思想模式。 > 在事物带来快乐或痛苦的时候，重点是要看清事物的本质，而不是着重在它带来的感受，于是就能不再为此所困。虽然感受悲伤，但不要希望悲伤结束，于是虽然仍有悲伤，也能不再为此而困。即使仍然悲伤，也是一种丰硕的经验。虽然感受快乐，但不要希望快乐继续，于是虽然仍有快乐，也能不失去心中的平静。 > 释迦牟尼制定一套冥想的技巧，能够训练心灵感受事物的本质而排除种种欲求。通过训练，心灵专注在“我现在是什么感受？”，而不是问：“为什么是我？” > 佛陀的教诲一言以蔽之：痛苦来自欲望；要从痛苦中解脱，就要放下欲望；而要放下欲望，就必须训练心智，体验事物的本质。 > 佛教徒还是崇拜着各种神祇，像是在印度的佛教徒拜着印度的神，西藏的佛教徒拜着本教（Bon）的神，日本的佛教徒也拜着神道教的神。 > 诸佛菩萨是人也非人，他们已经能够达到涅槃、解脱痛苦，但为了解脱和帮助还在轮回中的芸芸众生，倒驾慈航重入世间 ### 当崇拜的对象变成了人 {% asset_img chapter12.jpg %} ## 第十三章 成功的秘密 > “如何”和“为何”之间有何不同？描述“如何”的时候，是要重建一连串从一点导致另一点的事件顺序。至于要解释“为何”的时候，则是要找出因果关系，看看究竟为什么发生的是这一连串的事件，而不是另一连串的事件。 > 历史的铁则就是：事后看来无可避免的事，在当时看来总是毫不明显。直到今天，情况仍是如此。我们已经走出全球经济危机了吗？还是前面还有更大的打击？中国会不会继续成长、成为全球第一的超级大国？美国会不会丧失霸主地位？ 不能觉得什么都是理所当然的，战争，经济危机，说不定随时可能发生 > 在1913年10月，布尔什维克党还只是一个很小的俄国激进党派。任何理性的人都想不到，不过短短4年后，他们就接掌了俄国。在公元600年，如果说一小群住在沙漠里的阿拉伯部落会征服从大西洋到印度的辽阔土地，更是如痴人说梦。 > 这也不是说一切都有可能发生。地理、生物和经济力量确实会造成限制。但限制下仍然有许多发展空间，目前还没有什么确实加以制约的法则。 > 历史就是这样的一团混沌，历史就是无法解释得斩钉截铁，无法预测得十拿九稳。在同一时间，有多方力量互相影响、互相牵制，只要某方力量有了极小的改变，结果就会有巨大的不同。 > 混沌系统分成两级，一级混沌指的是“不会因为预测而改变”。例如天气就属于一级混沌系统。 至于二级混沌系统，指的是“会受到预测的影响而改变”，因此就永远无法准确预测。例如市场就属于二级混沌系统。 政治也属于二级混沌系统。很多人批评研究苏联的学者没能预测到1989年的苏联解体，也嘲笑中东专家没想到2011年会爆发阿拉伯之春革命。但这是不公平的。从定义上，革命就是无法预测。如果真能预测有革命，革命就永远不会成真。 举例 > 假设在2010年，有某些天才政治学者与某个计算机鬼才合作，开发出某种绝对准确的算法还有个漂亮的界面，号称能够预测是否发生革命。于是，他们向埃及总统穆巴拉克兜售这项服务，换取了一大笔可观的酬劳，告诉穆巴拉克，他们预测来年在埃及必然爆发大规模革命。穆巴拉克会如何反应？最有可能的是他会立刻降税，用数十亿美元补助人民，顺便也大幅加强秘密警察部队，以防万一。于是，这一切的准备工作发挥了效果。一年很快就过去，而且没有发生革命，真是太让人意想不到了，不是吗？于是，穆巴拉克要求退款。他向科学家大吼大叫：“你这套算法是骗人的！要不是你这套东西，我才不会把钱都拱手让人，我大可多盖一座宫殿！”科学家会辩白道：“可是，正是因为我们预测到了，革命才没有发生啊。”“你是说，你们预测到了，只是没有发生？”穆巴拉克一边说，一边示意叫警卫把他们全部抓起来。“这种神棍，开罗的市场到处都有。” 以史为镜 可以知兴替 > 我们之所以研究历史，不是为了要知道未来，而是要拓展视野，要了解现在的种种绝非“自然”，也并非无可避免。未来的可能性远超过我们的想象。 > 虽然我们无法解释历史做出的选择，但有一点可以确定：历史的选择绝不是为了人类的利益。 > 根据这种说法，文化并不是某些人为了剥削他人而设计出的阴谋，而是因为种种机缘巧合所出现的心理寄生虫，从出现之后就开始剥削所有受到感染的人。 迷因学假设，就像是生物演化是基于“基因”这种有机信息单位的复制，文化演化则是基于“迷因”（meme）这种文化信息单位的复制。而所谓成功的文化，就是特别善于复制其迷因，而丝毫不论这对于其人类宿主的成本或利益。 # 第四部分 科学革命 ## 第十四章 发现自己的无知 大杀器 > 如果要在过去500年间挑出一个最重大、具代表性的一刻，一定就是1945年7月16日上午5点29分45秒。就在这一秒，美国科学家在新墨西哥的阿拉莫戈多引爆了第一颗原子弹。从这时开始，人类不仅有了改变历史进程的能力，更有了结束历史进程的能力。 > 现代科学与先前的知识体系有三大不同之处： 1.愿意承认自己的无知 2.以观察和数学为中心。 3.取得新能力。 > 现代科学是一套独特的知识体系，独特之处也就在于公开承认这“整套体系”都对一些“最重要的问题”一无所知 > 现代科学愿意承认自己的无知，就让它比所有先前的知识体系更具活力、更有弹性，也更有求知欲。 > 现代想要维持社会政治秩序稳定，只能靠着两种不科学的方法，其他别无选择。 1.虽然采用科学理论，但必须违反一般科学做法：宣称这就是绝对的真理。纳粹就是采用这种方式，声称他们的种族政策是来自生物事实的推论。 2.不要采取科学方法，而诉诸“非科学的绝对真理”。这一直是自由人文主义的策略。自由人文主义的基础在于坚持主张人类的特殊价值和权利，但很尴尬的是，对智人的科学研究并不认同这种看法。但我们也不该太过惊讶。毕竟，科学还是得倚靠着种种宗教和意识形态信仰，才能取得经费，并将研究正当化。 > 现代科学没有需要严格遵守的教条，但研究方法有一个共同的核心：收集各种实证观察（可以用感官感受到的），并以数学工具整理。 > 有些学者想仿照牛顿，将生物学、经济学和心理学整理成简单的公式，却发现这些领域实在太复杂，不可能依样画葫芦。然而，这并不代表他们就放弃了数学。在过去两百年间，为了处理现实中更复杂的层面，数学发展出一个新的分支：统计学。 > 纵观历史，社会上有两种贫穷：（1）社会性的贫穷，指的是某些人掌握了机会，却不愿意释出给他人；（2）生物性的贫穷，指的是因为缺乏食物和住所，而使人的生存受到威胁。或许社会性的贫穷永远都会存在、无法根除，但在全球许多国家中，生物性的贫穷都已经成了过去式。 ## 第十五章 科学与帝国的联姻 > 究竟欧洲在现代早期培养了什么潜力，让它能在现代晚期称霸全球？这个问题有两个答案、相辅相成：现代科学和资本主义。 > 有一天，航天员受训的时候刚好碰到一位上了年纪的美国原住民。老人问他们在那里做什么。航天员说他们属于一个研究探险队，不久之后就要上月球了。听到他们这么说，老人沉吟了一会儿，问他们能不能帮个忙。“要帮什么忙呢？”他们问。“是这样的，我们族人都相信我们的圣灵住在月亮上。不知道你们能不能为我们族人带个重要的口信？”老人问。“要带什么话呢？”航天员问。这位老人用族语说了一串，并要求航天员重复再三，直到确定他们背得滚瓜烂熟为止。“这是什么意思？”航天员问。“啊，这个是族人和月亮上的圣灵之间的秘密。”等到航天员回了基地，好不容易才找到了一位会讲当地族语的人，希望能翻译这段话的意思。他们把这段话叽里咕噜背出来，让这位翻译简直笑翻了。等到翻译好不容易平静下来，航天员问他，这段话究竟说的是什么。翻译说，这些航天员费尽心力背下来的这句话是：“不管这些人跟您说什么，千万别相信他们。他们只是要来偷走您的土地。” > 因此“美洲”这个名词就这样广为流传。说来也算是老天有眼，到头来，全球有1/4的陆地、七大洲之中的两洲，名字就是来自一个名不见经传的意大利人，而他唯一做的事就只是有勇气说出“我们不知道”。 > 阿兹特克的卫生水平远高于西班牙。西班牙人第一次来到墨西哥的时候，不论到了哪里，当地人都派人带着熏香随行。西班牙人原本以为这是代表无上的荣耀。但我们从当地文献发现，这其实是因为当地人觉得这些新来的人实在是臭不可闻。 > 梵语竟然和希腊文、拉丁文有惊人的相似之处，而且这些语言也都和哥特语、凯尔特语、古波斯语、德语、法语和英语若合符节。例如梵文的“母亲”是“matar”，而古凯尔特语则是“mathir”。据琼斯推测，所有这些语言一开始必定有共同的来源，那是个古老而已经被遗忘的语言祖先。就这样，他是第一个发现后来称为“印欧语系”这套体系的人。 ## 第十六章 资本主义教条 > 在1500年，全球商品和服务总产值约是2500亿美元；而今天是大约60兆美元。更重要的是，在1500年，每人年平均产值约为550美元，但今天不论男女老幼，每人年平均产值高达8800美元。 > “信任”就是世上绝大多数金钱的唯一后盾。 原来是这个逻辑。 明天不一定比之前好，所以觉得财富总量有限，所以限制商人，一个人集中了财富就等于其他人损失了财富。 > 正因如此，许多文化都认为赚大钱是种罪恶 > 1776年，苏格兰经济学家亚当·斯密出版了《国富论》，这可以说是史上最重要的经济学著作。在《国富论》的第一卷第八章，亚当·斯密提出了以下的创新论述：如果地主、织工或鞋匠赚得的利润高于养家糊口基本所需，就会雇用更多助手，好进一步提高自己的利润。利润越高，能雇的助手也越多。由此可见，民间企业的获利正是社会整体财富和繁荣的基础。 > 他其实告诉我们：贪婪是好的，而且我们让自己过得好的时候，不只是自己得利，还能让他人受益。“利己”就是“利他”。 > 现代资本主义经济的一大重点，就在于出现了一种新的道德标准：应该把利润拿出来，继续投资生产。 > 新的资本主义教条里，最神圣的开宗明义第一条就是：“生产的利润，必须再投资于提高产量。” 作者对未来还是担忧的 > 一切指望，就在于那些实验室里的人。像是生物科技、纳米科技的新发现，就可能创造出全新的产业，带来庞大的利润，于是就能拿来打平那些银行和政府从2008年以来虚拟创造出的几万亿数字。而如果实验室的脚步不敌泡沫破灭的速度，可以想见经济前景就会令人十分担忧。 华尔街的来历 > 荷兰的西印度公司（WIC）也在大西洋大展身手。为了掌控哈德孙河这个重要商业通道，西印度公司在河口的一座小岛上开拓了一个殖民地，名为“新阿姆斯特丹”（New Amsterdam）。这个殖民地不断遭受美国原住民威胁，英国人也多次入侵，最后在1664年落入英国手中。英国人将这个城市改名“纽约”（New York，即“新约克”，约克为英国郡名）。当时西印度公司曾在殖民地筑起一道墙，用来抵御英国人和美国原住民，这道墙的位置现在成了世界上最著名的街道：华尔街（Wall Street，直译为“墙街”）。 密西西比公司利用其政治影响力操纵股价、推动购买热潮，结果让法国人民对法国金融系统和国王的金融智慧都失去信心。路易十五越来越难推动各种信贷计划，而这也成为法国海外领土逐渐落入英国手中的主因之一。 > 在中世纪，糖在欧洲是难得的奢侈品，必须由中东进口，而且价钱令人咋舌，使用的时候百般珍惜，视为某种秘密成分，加进各种美食或是蛇油为底的药物中。等到美洲开始有了一片又一片的大型甘蔗园，就开始有越来越多的糖运抵欧洲。糖价开始下跌，而欧洲对甜食也越来越贪得无厌。 > 这是自由市场资本主义美中不足之处。它无法保证利润会以公平的方式取得或是以公平的方式分配。而且相反的是，因为人类有追求利润和经济成长的渴望，就会决定盲目扫除一切可能的阻挠。等到“成长”成了无上的目标、不受其他道德伦理考虑的制衡，就很容易衍生成一场灾难。 > 有一些宗教（例如基督教和纳粹）杀害了数百万人，原因是出于仇恨。然而，资本主义也杀害了数百万人，原因则是出于冷漠和贪婪 ## 第十七章 工业的巨轮 能量转化靠人 > 在当时想要转换能量，只能靠一种东西：人类或动物自己的身体。在自然的代谢过程里，人类和其他动物燃烧有机燃料（也就是食物），把能量转换为肌肉运动。于是，男男女女或动物摄取谷物和肉类，燃烧碳水化合物和脂肪，再用这些能量来拉车或犁田。 > 由此看来，历史上人类成就的几乎所有事情，第一步靠的都是将植物取得的太阳能转换为肌肉的力量。 > 每次有哪个家庭主妇或仆人想要烧水泡茶，或是把装满了马铃薯的锅放在炉子上煮，这项发明就这样明显地在他们眼前。在水煮沸的那一刻，水壶或锅的盖子会开始跳上跳下。这时热能转换为动能，但是我们过去都只觉得这样乱跳有点烦人，至于一时忘记而让水煮干就更麻烦了。没人注意到这件事的真正潜力。 > 直到后来（起因可能是某些炸弹专家在研钵里磨火药，磨杵却被大力炸飞？），才终于发明了枪 > 1830年9月15日，第一条商业化铁路开通，连接了利物浦与曼彻斯特，用的同样是与抽水或纺织相同的蒸汽动力。 > 工业革命的核心，其实就是能源转换的革命。 > 如果与太阳任何一天放射出的能量相比，全球所有化石燃料所储存的能源简直是微不足道。太阳的能量只有一小部分会到达地球，但即使是这一小部分，就已经高达每年3766800艾焦（焦耳是能量单位，在地心引力下将一颗小苹果抬升一米，所需的能量就是一焦耳；至于艾焦则是1018焦耳，这可是很多很多颗苹果。）全球所有植物进行光合作用，也只能保留大约3000艾焦的能量。现在人类所有活动和产业每年约消耗500艾焦，而地球只要大约短短90分钟，就能从太阳接收到这么多能量。 > 19世纪60年代，法国皇帝拿破仑三世还会用铝质餐具来宴请最尊贵的客人，至于那些二等的客人，就只能用黄金的刀叉来凑合凑合。 > 工业革命最重要的一点，其实在于它就是第二次的农业革命。 > 猪的智商和好奇心在哺乳动物里数一数二，可能只低于巨猿。 > 大西洋奴隶贸易并非出于对非洲人的仇恨，而现代畜牧业也同样不是出于对动物的仇恨。这两者背后共同的推手，就是冷漠。 > 随着农业工业化，只需要越来越少的农民数量，就足以养活越来越多的办公或工厂人口。 > 正是因为农业释放出了数十亿的人力，由工厂和办公室吸纳，才开始像雪崩一样有各种新产品倾泻而出 > 资本主义和消费主义的伦理可以说是一枚硬币的正反两面，将这两种秩序合而为一。有钱人的最高指导原则是——“投资！”而我们这些其他人的最高指导原则则是——“购买！” ## 第十八章 一场永远的革命 > 工业革命找出新方法来进行能量转换和商品生产，于是人类对于周遭生态系统的依赖大减 > 工业革命不仅为人类带来了时刻表和生产线的概念，更将这些概念推广到几乎所有的人类活动当中 > 因为火车的速度比传统马车快上太多，所以各地时间的微小差异就造成了巨大的困扰。1847年，英国各家火车业者齐聚一堂，研拟同意统一协调所有火车时刻表，一概以格林尼治天文台的时间为准，而不再遵循利物浦、曼彻斯特、格拉斯哥或任何其他城市的当地时间 > 最后在1880年，英国政府迈出了前所未有的一步，立法规定全英国的时刻表都必须以格林尼治时间为准。这是史上第一次有国家采取了全国统一的时刻表，要求人民依据人工的时钟来过生活，而不是依据当地的日升日落周期有所调整。 > 这一切都比不上有史以来人类最大的社会革命：家庭和地方社群崩溃，改由国家和市场取代。 > 很多时候，王国和帝国就像是收着保护费的黑道集团。国王就是黑道大哥，收了保护费就得罩着自己的人民，不受附近其他黑道集团或当地小混混骚扰。除此之外，其实也没什么功用。 > 随着时间过去，国家和市场的权力不断扩大，也不断削弱家庭和社群过去对成员的紧密连接。国家开始派出警察，制止家族里的私刑，改用法院判决取代。市场也派出小贩和商人，让各地悠久的传统逐渐消失，只剩下不断汰换的流行商业文化。 > 国家与市场找上家庭和社群的各个成员，开出了他们无法拒绝的条件。他们说：“做自己吧！想娶想嫁都随你的意，别管父母准不准。想挑什么工作都可以，别担心什么大家长说的话。想住哪就住哪，就算没办法每周和家人吃上一次饭又有什么关系呢？你不用再依赖家庭或社群了。我们，也就是国家和市场，让我们来照顾你吧。我们会给你食物、住房、教育、保健、福利和就业机会。我们也会给你退休金、保险和保障。” > 市场和国家要增强这些情感面，靠的就是塑造“想象的社群”（imagined communities，另译“想象的共同体” 现代所兴起的两大想象社群，就是“民族”和“消费大众”。所谓民族，是国家的想象社群。而所谓消费大众，则是市场的想象社群。 > 我们现在之所以有叙利亚人、黎巴嫩人、约旦人、伊拉克人的区别，只是因为当初英法两国的外交官在完全不顾当地历史、地理和经济的情况下，在一片沙漠之中确定出了所谓的边界。 宏观角度 > 我们比较容易体会个人的辛酸，而不是人类整体的苦难。但为了从宏观角度来看历史进程，我们需要看整体统计数据，而不只是看个人的故事而已。在公元2000年，全球战争造成31万人丧生，而暴力犯罪造成52万人死亡。当然，对每一个受害者来说这都是世界的毁灭，家破人亡，朋友和亲戚悲痛欲绝。但从宏观的角度来看，在2000年总共83万的死亡者只占了全球5600万总死亡人数的1.5%。在同样一年，车祸死亡的人数达到126万（占总死亡人数2.25%），自杀人数达81.5万（占总死亡人数1.45%） 恐怖平衡 > 如果说有个最高诺贝尔和平奖，应该把奖颁给罗伯特·奥本海默以及和他一起研发出原子弹的同事。有了核武器之后，超级大国之间如果再开战，无异等于集体自杀。因此，想要武力征服全球也成了不可能的任务。其次，正因为战争的成本飙升，也就代表其利润下降。 > 虽然现在世界上仍然偶尔会发生大规模国际战争（例如伊拉克入侵科威特），但原因在于这些地方的财富多半属于传统的实质财富。 > 同时，虽然战争已经不再那么有利可图，但和平却成了一笔越来越划算的生意。在过去的农业经济中，长途贸易和外国投资并非重点，因此和平顶多只是省下战争费用，其他并无太大好处。 > 最后一项重点，在于全球政治文化也有了结构性的大变动。 > 现在有四大因素形成了一个良性循环。核子末日的威胁促进了和平主义；和平主义大行其道，于是战争退散、贸易兴旺；贸易成长，也就让和平的利润更高，而战争的成本也更高。 ## 第十九章 从此过着幸福快乐的日子 ### 快感 > 目前有一项耐人寻味的结论：金钱确实会带来快乐，但是有一定限度，超过限度之后的效果就不那么明显。所以，对于在经济阶层底层的人来说，确实是钱越多就越快乐。 知足常乐 > 快乐并不在于任何像是财富、健康甚至社群之类的客观条件，而在于客观条件和主观期望之间是否相符 > 如果说快乐要由期望来决定，那么我们社会的两大支柱（大众媒体和广告业）很有可能正在不知不觉地让全球越来越不开心。 赚钱买门票啊 > 穷人和受压迫者之所以还能自我安慰，就是因为死亡是唯一完全公平的事。不论再富有、权力再大，人也难逃一死。光是想到自己得死，但有钱人居然能长生不老，就会让穷人怒火中烧、不可遏抑。 > 我们能够快乐的唯一原因，就是身体内发出快感的感官感受。 > 演化就把快感当成奖赏，鼓励男性和女性发生性行为、将自己的基因传下去。如果性交没有高潮，大概很多男性就不会那么热衷。但同时，演化也确保高潮得迅速退去。如果性高潮永续不退，可以想象男性会非常开心，但连觅食的动力都没了，最后死于饥饿 > 我们就不用再浪费时间处理政治和社会改革、叛乱和意识形态，而是开始全力研究唯一能真正让我们快乐的方法：操纵人类的生化机制 以后人类就插着管子 戴着VR活着好了 > 百忧解（Prozac）之所以让人不再沮丧，靠的就不是对任何体制的改革，而只是提高血清素的浓度。 ### 赋予生命意义 > 正如尼采所言，只要有了活下去的理由，几乎什么都能够忍受。生活有意义，就算在困境中也能甘之如饴；生活无意义，就算在顺境中也度日如年。 > 从我们所知的纯粹科学角度来看，人类的生命本来就完全没有意义。人类只是在没有特定目标的演化过程中，盲目产生的结果。人类的行动没有什么神圣的整体计划，而且如果整个地球明天早上就爆炸消失，整个宇宙很可能还是一样这么继续运行下去。 > 我们对生活所赋予的任何意义，其实都只是错觉 > 如果快乐是在于感受快感，想要更快乐，就得操纵我们的生化系统。如果快乐是在于觉得生命有意义，想要更快乐，就得要骗自己骗得更彻底 > DNA就像撒旦，用一些稍纵即逝的快乐作为引诱，令人为之臣服。 ### 放下追求主观感受 > 佛教认为，快乐既不是主观感受到愉悦，也不是主观觉得生命有意义，反而是在于放下追求主观感受这件事。 > 苦的根源既不在于感到悲伤或疼痛，也不在于感觉一切没有意义。苦真正的根源就在于“追求”主观感受这件事，不管追求的是什么，都会让人陷入持续的紧张、困惑和不满之中。 > 人想要离苦得乐，就必须了解自己所有的主观感受都只是一瞬间的波动，而且别再追求某种感受。如此一来，虽然感受疼痛，但不再感到悲惨；虽然愉悦，但不再干扰心灵的平静。于是，心灵变得一片澄明、自在。这样产生的心灵平静力量强大，那些穷极一生疯狂追求愉悦心情的人完全难以想象。这就像是有人已经在海滩上站了数十年，总是想抓住“好的海浪”，让这些海浪永远留下来，同时又想躲开某些“坏的海浪”，希望这些海浪永远别靠近。就这样一天又一天，这个人站在海滩上徒劳无功，被自己累得几近发疯。最后终于气力用尽，瘫坐在海滩上，让海浪就这样自由来去。忽然发现，这样多么平静啊！ ## 第二十章 智人末日 > 达尔文理论美妙的地方，就是并不需要有某位智慧过人的设计者来解释为什么长颈鹿会有长脖子。 > 经过40亿年的自然选择之后，阿巴可说是站在新时代曙光乍现的时间点，生命即将改由智能设计来操控 > 有三种方式可能让智慧设计取代自然选择： 生物工程（biological engineering）、 仿生工程（cyborg engineering）与 无机生命（inorganic life）工程。 ### 生物工程 > 所谓生物工程，指的是人类刻意在生物层次进行的干预行为（例如植入基因），目的在于改变生物体的外形、能力、需求或欲望，以实现某些预设的文化概念（例如爱德华多·卡茨心中的那种艺术）。 > 在英文里，未阉割的公牛称为“bull”，阉割后的称为“ox”，这种将牛阉割的做法已经有大约一万年之久，阉割后的牛比较不具侵略性，也就比较容易训练拉犁。 人类可以让尼安德特人再现，可以改变人类的生理、免疫系统和寿命长短。 > 许多人都认为，现在人类太快看到太多的机会，手中已经握有基因修改能力，却还无法做出明智、有远见的决定。 > 由俄罗斯、日本和韩国组成的科学家团队最近已经完成长毛象的基因定序。他们正在计划要拿一个现代大象的受精卵细胞，将大象的DNA换成长毛象DNA，再重新植回大象的子宫。只要再经过大约22个月，长毛象就能在绝迹近5000年后再次重现于地球。 ### 仿生工程 > 仿生工程结合有机和无机组织，创造出“生化人”（cyborg），例如为人类装上生化手就是一例。 这不是三体人吗？ > 在所有目前进行的研究当中，最革命性的就是要建构一个直接的大脑–计算机双向接口，让计算机能够读取人脑的电子信号，并且同时输回人脑能够了解的电子信号。如果这种设备成功，再直接将大脑连上网络，或是让几个大脑彼此相连，形成“脑际网络”，情况会如何？ ### 无机生命 > 创造完全无机的生命。最明显的例子，就是能够自行独立演化的计算机程序和计算机病毒。 基因程序设计（genetic programming）]]></content>
      <categories>
        <category>reading-notes</category>
      </categories>
      <tags>
        <tag>reading-notes</tag>
        <tag>history</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rust语言(3):引用依赖库]]></title>
    <url>%2F2017%2F01%2F25%2FRust-lang-3-crate%2F</url>
    <content type="text"><![CDATA[title: Rust语言(3):引用依赖库 categories: - Rust tags: - Rust - crate comments: true layout: post date: 2017-01-25 22:13:03 modified: 2017-01-25 22:13:03 --- [crate.io](https://crates.io/)是Rust社区的中心package仓库，该仓库有各种不同功能的Rust软件库。 （过年喽，年前最后一篇了，还有很多坑没填。2017，Year of Rooster，加油，fighting！） # Introduction [crate.io](https://crates.io/)是Rust社区的中心package仓库，`cargo`用来管理package，下载、版本管理、编译、运行依赖的packages。 `crate`本身是`木箱`的意思，而`cargo`有`货运`的意思，`cargo`承载着各种`货物`，其中有一些是封装好的`木箱`。这个比喻倒也贴切。 # add package ## packages from crate.io 使用Rust（当前版本`1.14.0`）过程中，如果需要使用一些非核心库（Rust的核心库功能有限，使用到其他的库是大概率事件），则需要在`Cargo.toml`文件添加依赖的package。这些package可以是来自[crate.io](https://crates.io/)，或者`git仓库`，或者本地路径。 以下是一个从 crate.io 引用 crate 的例子，两个步骤： 1. 在 Cargo.toml 文件中增加dependencies的package名字以及版本。 ```toml Cargo.toml [dependencies] webbrowser = "0.2.2" ``` 2. 在rust源文件中引入 crate。 ```rs Rust import external crate extern crate webbrowser; ``` ## packages from git repository ```toml dependencies from git repository [dependencies] rand = { git = "https://github.com/rust-lang-nursery/rand", branch = "next" } ``` 如果不加`branch="next"`，则默认获取最新的commit，当然可以用`rev`、`tag`、`branch`来指定不同的版本。 ## packages from local path ```toml dependencies from local directory [dependencies] my_crate_name = { path = "../my-crate-directory", version = "0.1.0" } ``` 如果不加`version="0.1.0"`，则不会进行版本检查。 # package version ## Semver 版本号`0.2.2`有讲究，这是符合[语义化版本控制(Semantic Versioning)](http://semver.org/)格式，这种格式制定了严格的版本号更新要求，严格遵守可以防止`dependency hell(依赖地狱)`问题。 > Given a version number MAJOR.MINOR.PATCH, increment the: MAJOR version when you make incompatible API changes, MINOR version when you add functionality in a backwards-compatible manner, and PATCH version when you make backwards-compatible bug fixes. Additional labels for pre-release and build metadata are available as extensions to the MAJOR.MINOR.PATCH format. ## Caret requirements 版本号还可以有另外一种crate格式，这种格式`^x.y.z`允许升级到与要求版本号兼容的最新版本上。 ```txt Crate format ^1.2.3 := >=1.2.3 =1.2.0 =1.0.0 =0.2.3 =0.0.3 =0.0.0 =0.0.0 =1.2.3 =1.2.0 =1.0.0 =0.0.0 1.* := >=1.0.0 =1.2.0 cargo build Updating registry `https://github.com/rust-lang/crates.io-index` Downloading webbrowser v0.2.2 Compiling webbrowser v0.2.2 Compiling take_a_break v0.1.0 (file:///Users/alta/github/Rust/04_take_a_break) Finished debug [unoptimized + debuginfo] target(s) in 0.66 secs ``` # update a project with dependencies ``` >cargo update Updating registry `https://github.com/rust-lang/crates.io-index` ``` Reference: 1. [Cargo Guide](http://doc.crates.io/guide.html) 2. [Rust semver](https://github.com/steveklabnik/semver) 3. [semver](http://semver.org/lang/zh-CN/) 4. [take a break](https://github.com/WuChenxu/Rust/tree/master/04_take_a_break)]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>crate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件开发(1):state machine]]></title>
    <url>%2F2017%2F01%2F16%2Fsoftware-design-1-state-machine%2F</url>
    <content type="text"><![CDATA[title: 软件开发(1):state machine categories: - software tags: - software - design comments: true layout: post date: 2017-01-16 21:23:45 modified: 2017-02-18 21:23:45 --- FSM,HSM,Model-Base... # state machine ## 状态机是什么 ## 硬件 ## 软件 ## 通信 # FSM(Finite State Machine) ## 三段式 ## 状态转移表 # HSM(hierarchical State Machine) # Modeling design integration simulate validation generate code ## [Matlab Stateflow](https://www.mathworks.com/products/stateflow.html) ## [YAKINDU Statechart Tools (SCT)](https://www.itemis.com/en/yakindu/statechart-tools/)]]></content>
      <categories>
        <category>software</category>
      </categories>
      <tags>
        <tag>software</tag>
        <tag>design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[怎样开发一个产品]]></title>
    <url>%2F2017%2F01%2F11%2Fhow-to-develop-a-product%2F</url>
    <content type="text"><![CDATA[title: 怎样开发一个产品 categories: - product tags: - idea comments: true layout: post date: 2017-01-11 22:02:34 modified: 2017-01-11 22:02:34 --- 个人的一点看法，欢迎讨论。谢绝转载。 # 逆向开发 如果是一个成熟产品，市面上有很多现成的产品，那么一个快速开发的捷径是"抄"。硬件可以模仿甚至抄板，软件可以通过学习市场上其他产品的功能，算法可以参考一些公开的论文，结合对其他产品的反向分析。 曾经有过极端的案例是，硬件抄板成一模一样，软件读出来，直接烧录进去就可以出货了。当然了这种极端的做法是侵犯了别人的知识产权，我是不支持的。 # 正向开发 按照顺序： 1. 定义问题 2. 寻找解决方案 3. 系统架构设计 4. 硬件设计设计 5. 软件架构设计 6. 软件开发 7. 软件测试 8. 系统测试 核心竞争力：建立开发（development）和系统性能调优（system preformance tuning）的能力（know-how，toolchain...）。 系统设计可以划分子系统，子系统下面可以划分子模块，每个模块可独立演进，每个模块的算法可以优化迭代。 软件模块开发可以考虑用基于模型的设计（Model-Based design），如Matlab，既可以做SIL（Software In the Loop）或者HIL（Hardware In the Loop），也可以生成代码在嵌入式设备中运行。 有前瞻性的预研团队，可以与高校或者研究所合作，确保技术上不断更新。 当然对汽车行业还要考虑更多：A-SPICE、ISO26262（functional safety），AUTOSAR。 # 混合模式 就算是已正向开发为主的大公司，也会进行所谓"竞争对手分析"，对比市场上的产品与一家产品的功能及性能差距，优点可以在向客户的推介材料里展示，缺点可以称为改进的方向，以确保产品在市场上有竞争力。 如果一家刚起步的公司两种方法： 1. 集中精力开发核心模块，其他模块都外包，如Mobieye专攻图像处理器和算法，可以集成到Tier1或者OEM的video里。 2. 先逆向开发出产品，杀入市场，占领一部分市场，然后慢慢建立自己的正向研发能力，如国内主机厂，华为手机原来是白牌。 reference： 1. [Mobieye](https://en.wikipedia.org/wiki/Mobileye)]]></content>
      <categories>
        <category>product</category>
      </categories>
      <tags>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows command(20):date time]]></title>
    <url>%2F2016%2F12%2F18%2Fwindows-cmd-20-date-time%2F</url>
    <content type="text"><![CDATA[title: windows command(20):date time categories: - windows cmd tags: - cmd - date - time comments: true layout: post date: 2016-12-18 20:32:28 modified: 2016-12-26 --- `data`命令用来显示日期；`time`命令用来显示时间。 # Basics ```bat date >echo %date% Sun 12/18/2016 ``` ```bat time >echo %time% 17:00:35.87 ``` note: 1. `%`可以替换为`!`，效果一样。 2. 注册表里`HKCU\Control Panel\International`下的一些键值： `sShortDate`键值为`M/d/yyyy` `sTimeFormat`键值为`h:mm:ss tt` 以上键值不同则输出的格式会有不同。 # format output ## `:`截取字符串 ```bat date year >echo %date：~10,4% 2016 ``` `date`后的`:`表示对变量作处理，`~10`表示从第10个字符开始取内容（从0开始计数），`,4`表示去4个字符。 ```bat date month >echo %date：~4,2% 12 ``` ```bat date day >echo %date：~7,2% 18 ``` ```bat time hour >echo !time:~,2! 19 ``` ```bat time minute >echo !time:~3,2! 58 ``` ```bat time second >echo !time:~6,2! 20 ``` ## `for`语句 ```bat for-date >for /F "tokens=1-4 delims=/ " %i in ("%date%") do @echo %i-%j-%k-%l Sun-12-18-2016 >for /F "tokens=1-4 delims=/ " %i in ("%date%") do @echo %l-%j-%k 2016-12-18 ``` ```bat for-time >for /F "tokens=1-4 delims=:." %i in ("%time%") do @echo %i-%j-%k-%l 20-29-30-71 >for /F "tokens=1-4 delims=:." %i in ("%time%") do @echo %i%j 2029 ``` # unified output format in different operation settings 由于Windows语言和日期格式设置不同，可能的输出也不同： ```text date format 星期日 2016-12-18 2016-12-18 星期日 12/18/2016 Sun Sun 12/18/2016 ``` 不同的格式用[上一节](#format-output)所述方法，在不同设置的操作系统上，会得到不同的结果，有可能是错误的结果； 通过修改注册表中的`sShortDate`键值来保证不同的操作系统设置都能输出正确的格式。 ```bat date.bat @echo off for /f "delims=" %%a in ('reg query "HKEY_CURRENT_USER\Control Panel\International" /v sShortDate') do ( set "RegDateOld=%%a" ) set RegDateOld=%RegDateOld:~-8% reg add "HKEY_CURRENT_USER\Control Panel\International" /v sShortDate /t REG_SZ /d yyyy-M-d /f>nul set Today=%date: =% reg add "HKEY_CURRENT_USER\Control Panel\International" /v sShortDate /t REG_SZ /d %RegDateOld% /f>nul if "%Today:~0,1%" gtr "9" ( set Today=%Today:~-10% ) else ( set Today=%Today:~0,10% ) echo,%Today% ``` ```bat execute date.bat >.\date.bat 2016-12-18 ``` References: 1. [再谈DOS批处理下格式化日期字符串的三种方法(详解)](http://www.jb51.net/article/44361.htm) 2. [批处理bat标准化获取当前系统日期的几种方法](http://www.jb51.net/article/52749.htm)]]></content>
      <categories>
        <category>windows cmd</category>
      </categories>
      <tags>
        <tag>cmd</tag>
        <tag>date</tag>
        <tag>time</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows command(19):console颜色 color]]></title>
    <url>%2F2016%2F12%2F07%2Fwindows-cmd-19-color%2F</url>
    <content type="text"><![CDATA[title: windows command(19):console颜色 color categories: - windows cmd tags: - cmd - color comments: true layout: post date: 2016-12-07 20:32:28 modified: 2016-12-26 --- color命令用来设置console的前景色或者背景色。 # Usage 用法很简单，`color [fb]`，其中`f`表示前景色，`b`表示背景色，取值范围为`0`-`F`，也就是十六进制数的一位。 color definition: 0 = Black 1 = Blue 2 = Green 3 = Aqua 4 = Red 5 = Purple 6 = Yellow 7 = White 8 = Gray 9 = Light Blue A = Light Green B = Light Aqua C = Light Red D = Light Purple E = Light Yellow F = Bright White # Examples ## foreground {% asset_img image cmd_color_02.png %} ## background {% asset_img image cmd_color_20.png %} ## same color 如果前景色与背景色设置为一样，如`color 00`，设置不会生效，结果是保持当前的前景色和背景色不变。 {% asset_img cmd_color_same_color_error.png %} ## start new console 在改变console颜色之后，再通过`start`来创建一个新的console，新的控制台颜色还是保持 {% asset_img change_color_start_console.png %} # Advanced 修改注册表`HKEY_CURRENT_USER\Software\Microsoft\Command Processor\DefaultColor`的键值，可以修改通过`cmd.exe`或者`start`启动的窗口的颜色。 ```text help COLOR Sets the default console foreground and background colors. COLOR [attr] attr Specifies color attribute of console output Color attributes are specified by TWO hex digits -- the first corresponds to the background; the second the foreground. Each digit can be any of the following values: 0 = Black 8 = Gray 1 = Blue 9 = Light Blue 2 = Green A = Light Green 3 = Aqua B = Light Aqua 4 = Red C = Light Red 5 = Purple D = Light Purple 6 = Yellow E = Light Yellow 7 = White F = Bright White If no argument is given, this command restores the color to what it was when CMD.EXE started. This value either comes from the current console window, the /T command line switch or from the DefaultColor registry value. The COLOR command sets ERRORLEVEL to 1 if an attempt is made to execute the COLOR command with a foreground and background color that are the same. Example: "COLOR fc" produces light red on bright white ```]]></content>
      <categories>
        <category>windows cmd</category>
      </categories>
      <tags>
        <tag>cmd</tag>
        <tag>color</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[康威定律（Conway's law）]]></title>
    <url>%2F2016%2F11%2F20%2FConways-law%2F</url>
    <content type="text"><![CDATA[title: 康威定律（Conway's law） categories: - software tags: - architecture - programmer comments: true layout: post date: 2016-11-20 22:37:54 modified: 2016-11-20 22:37:54 --- {%asset_img tech_organization_structure.png %} 系统是设计该系统的组织结构的映射。 # 来源 Conway's law 最初是Conway在1967年发表的论文《[How Do Committees Invent?](http://www.melconway.com/Home/Committees_Paper.html)》，然后 Fred Brooks 在《人月神话》（The Mythical Man-Month）这本书中引用了这篇论文的结论，并命名为康威定律（Conway's law）。 # 观点 ## 康威定律的结论 > **Organizations which design systems (in the broad sense used here) are constrained to produce designs which are copies of the communication structures of these organizations.** We have seen that this fact has important implications for the management of system design. Primarily, we have found a criterion for the structuring of design organizations: a design effort should be organized according to the need for communication. > This criterion creates problems because the need to communicate at any time depends on the system concept in effect at that time. Because the design which occurs first is almost never the best possible, the prevailing system concept may need to change. Therefore, flexibility of organization is important to effective design. > Ways must be found to reward design managers for keeping their organizations **lean and flexible**. There is need for a philosophy of system design management which is not based on the assumption that adding manpower simply adds to productivity. The development of such a philosophy promises to unearth basic questions about value of resources and techniques of communication which will need to be answered before our system-building technology can proceed with confidence. 论文主要的观点：系统的结构受限于设计这个系统的组织的沟通结构。由于系统的结构可能会随着设计的深入而变化，所以必须保持设计组织结构的精简与灵活。 原论文是基于一种社会学的观察得出来的结论，所以这里的`系统`可以指代广义的系统，一个政府，一架飞机，一个芯片都可以认为是一个系统。 ## 变体 > The organization of the software and the organization of the software team will be congruent. 软件本身的组织结构与软件团队的组织结构式一致的。 > If the parts of an organization (e.g. teams, departments, or subdivisions) do not closely reflect the essential parts of the product, or if the relationship between organizations do not reflect the relationships between product parts, then the project will be in trouble... Therefore: Make sure the organization is compatible with the product architecture". 如果组织（团队，部门，或者分支部门）的组成部分不能正确地与产品的必要组成部门相对应，或者组织之间的关系不能反映产品组成部分之间的关系，那么这个项目就会有麻烦。。。所以：必须保证组织与产品架构的相互兼容。 > The structure of a problem reflects the structure of the organization that created it. 问题的结构反应了产生问题的组织的结构。 # 论据 ## compiler Conway博士在一个研究组织中作了如下实验：分别给COBOL编译器开发团队安排5个人，给ALGOL编译器开发团队安排3个人，最后COBOL编译器和ALGOL编译器分别是5个步骤和3个步骤的。 ## interface 只有模块A的开发者和模块B的开发者有沟通，模块A和模块B才能有良好的接口（interface）。所以系统的接口结构会反应开发这个系统的组织的结构。 # TODO “康威定律” 没有提供相应的诊断工具，帮助执行团队判断自己的组织框架是否合理，以及公司在什么时候进行重组比较合适。它只引发了一个问题：公司的组织架构能否为用户提供最好的产品？ Reference： 1. [CONWAY'S LAW](http://www.melconway.com/Home/Conways_Law.html) 2. [Conway's law in wiki](https://en.wikipedia.org/wiki/Conway%27s_law) 3. [How to Design With Conway’s Law in Mind](https://dzone.com/articles/how-to-design-with-conways-law-in-mind)]]></content>
      <categories>
        <category>software</category>
      </categories>
      <tags>
        <tag>architecture</tag>
        <tag>programmer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TeX(1):简介]]></title>
    <url>%2F2016%2F09%2F28%2FTeX-1-introduction%2F</url>
    <content type="text"><![CDATA[title: TeX(1):简介 categories: - TeX tags: - TeX comments: true layout: post date: 2016-09-28 20:44:27 modified: 2016-09-28 20:44:27 --- 本文介绍了在Windows下TeX的安装及使用。 # What TeX是一个排版软件，LaTeX从TeX衍生而来，命令较为简单. > TeX provides an unusual macro language; The TeX macro language has been successfully used to extend TeX to, for instance, LaTeX and ConTeXt. When TeX "compiles" a document, it follows (from the user's point of view) the following processing sequence: Macros → TeX → Driver → Output. # Install 安装[CTeX](http://www.ctex.org/)，CTeX打包了MiTeX以及其他一些宏包、字体等。 直接用原生的latex需要加载宏包才能支持汉字，否则编译会报错：`Invalid UTF-8 byte or sequence at line 4 replaced by U+FFFD.` XeTeX就是为了支持多语言而重新设计的新一代TeX系统，这意味着在XeTeX眼里，中文文档和英文文档再没有任何区别，无需额外的外挂包；而且，XeTeX原生支持系统字体，这意味着我们无需再额外编译字体，系统安装了什么字体，我们就能使用什么字体。 使用xelatex编译，不需要写`\begin{CJK*}{UTF8}{song}` ```tex example.tex \documentclass[12pt,a4paper]{article} \usepackage{fontspec} \setmainfont{Microsoft YaHei} \begin{document} Hello,World！ 这是一个测试的中文文档！ \end{document} ``` 用notepad输入，`保存成utf-8格式`, 后用xelatex example.tex编译，生成pdf。 # Usage & Warning * `\fontsize{字号}{基本行距}` 其中字号和基本行距两个参数是纯数字，单位是 pt。命令也在 \selectfont 后生效。 * `Overfull \hbox (76.35919pt too wide) in paragraph at lines 11--15`找到对应的提示行，然后将最后几个单词任意截断，然后另起一行即可。 * `texdoc fontspec`可以查看宏包`fontspec`的帮助文档。 * `fc-list`可以查看电脑中安装了哪些字体；`fc-list ;lang=zh-cn`可以查看安装了哪些中文字体。 附上一个台湾版cwTeX中的示例(台湾的明体应该对应大陆的宋体) {% include_code TeX TeX/排版的原则.tex %} 效果 {% asset_link 排版的原则.pdf %} References: 1. [TeX](https://en.wikipedia.org/wiki/TeX) 2. [LaTex](https://en.wikipedia.org/wiki/LaTeX) 3. [使用xelatex生成中文pdf](http://blog.jqian.net/post/xelatex.html) 4. [LaTeX/Errors and Warnings](https://en.wikibooks.org/wiki/LaTeX/Errors_and_Warnings) 5. [cwTeX排版系統](http://homepage.ntu.edu.tw/~ntut019/cwtex/cxbook3.pdf)]]></content>
      <categories>
        <category>TeX</category>
      </categories>
      <tags>
        <tag>TeX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows command(18):打印目录结构tree]]></title>
    <url>%2F2016%2F09%2F17%2Fwindows-cmd-18-tree%2F</url>
    <content type="text"><![CDATA[title: windows command(18):打印目录结构tree categories: - windows cmd tags: - cmd - tree comments: true layout: post date: 2016-09-17 14:30:33 modified: 2016-09-17 14:30:33 --- tree命令用来打印文件夹目录结构。 # tree打印目录结构 ```bat tree打印目录结构 D:\test\tree>tree 卷 LENOVO 的文件夹 PATH 列表 卷序列号为 0005-42D7 D:. ├─node1 └─node2 ``` # tree /F打印目录结构及每个目录下的文件 显示每个目录的文件名 ```bat tree /F D:\test\tree>tree /F 卷 LENOVO 的文件夹 PATH 列表 卷序列号为 0005-42D7 D:. │ tree.txt │ ├─node1 │ node1.txt │ └─node2 node2.txt ``` # 打印结果输出到到文件 `tree /f > file.txt` References: ```text help tree 以图形显示驱动器或路径的文件夹结构。 TREE [drive:][path] [/F] [/A] /F 显示每个文件夹中文件的名称。 /A 使用 ASCII 字符，而不使用扩展字符。 ```]]></content>
      <categories>
        <category>windows cmd</category>
      </categories>
      <tags>
        <tag>cmd</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rust语言(2):Cargo]]></title>
    <url>%2F2016%2F09%2F13%2FRust-lang-2-Cargo%2F</url>
    <content type="text"><![CDATA[title: Rust语言(2):Cargo categories: - Rust tags: - Rust - Cargo comments: true layout: post date: 2016-09-13 21:59:05 modified: 2016-09-13 21:59:05 --- 陈粒-奇妙能力歌 本文介绍了Rust自带的编译和包管理工具Cargo. # Carog的存在意义 > Cargo is a tool that allows Rust projects to declare their various dependencies and ensure that you’ll always get a repeatable build. > To accomplish this goal, Cargo does four things: * Introduces two metadata files with various bits of project information. * Fetches and builds your project’s dependencies. * Invokes rustc or another build tool with the correct parameters to build your project. * Introduces conventions to make working with Rust projects easier. # 新建项目 执行命令`cargo new hello_world --bin`可以生成一个可用cargo来编译运行的目录结构。 `--bin`表示生成可执行文件。 ```tree Cargo目录结构 │ Cargo.toml │ ├─src │ main.rs ``` Cargo.toml是TOML(Tom's Obvious, Minimal Language)格式的配置文件： ```toml Cargo.toml [package] name = "hello_world" version = "0.0.1" authors = [ "Your name " ] ``` main.rs存放Rust文件: ```rust hello_world.rs fn main() { println!("Hello, world!"); } ``` # 编译运行 `cargo build`编译。 `cargo run`文件未改动则直接运行，文件改动则重新编译并运行。 `cargo build --release`编译release版本，带优化功能。 # 包管理 ## 从crates.io增加依赖库 在Cargo.toml增加 ```toml [dependencies] time = "0.1.12" ``` ## 从github增加依赖库 ```toml Cargo.toml [dependencies] rand = { git = "https://github.com/rust-lang-nursery/rand.git" } ``` References: 1. [Cargo official website](http://doc.crates.io/guide.html)]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Cargo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rust语言(1):hello world]]></title>
    <url>%2F2016%2F09%2F12%2FRust-lang-1-hello-world%2F</url>
    <content type="text"><![CDATA[title: Rust语言(1):hello world categories: - Rust tags: - Rust comments: true layout: post date: 2016-09-12 21:56:20 modified: 2016-09-12 21:56:20 --- {% asset_img rust-logo-blk.svg %} 本文介绍了Rust语言在Windows下的环境安装，编译，执行。 # 简介 Rust是静态强类型的编译型语言，非动态解释型语言，无垃圾回收。 > Rust is a systems programming language that runs blazingly fast, prevents segfaults, and guarantees thread safety. * zero-cost abstractions * move semantics * guaranteed memory safety * threads without data races * trait-based generics * pattern matching * type inference * minimal runtime * efficient C bindings # 安装 进入[Rust官网](www.rust-lang.org),首页会根据当前操作系统推荐下载安装包。 支持Windows(GUN ABI 与 MSVC ABI)、Linux以及Mac。 安装完成后，在命令行输入`rustc`，如果有输出说明安装成功。 # 编写代码 ```rust hello.rs fn main() { println!("Hello, world!"); } ``` # 编译 ``` rustc hello.rs ``` # 执行 ``` >hello.exe Hello, world! ``` # 代码 [Code](https://github.com/WuChenxu/Rust/tree/master/01_HelloWorld) References: 1. [Rust official manual](https://doc.rust-lang.org/book/getting-started.html)]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MathJax(2):Markdown中使用MathJax]]></title>
    <url>%2F2016%2F09%2F08%2FMathJax-2-using-in-hexo-markdown%2F</url>
    <content type="text"><![CDATA[title: MathJax(2):Markdown中使用MathJax categories: - MathJax - tool tags: - MathJax - Markdown comments: true layout: post date: 2016-09-08 20:44:27 modified: 2016-08-08 20:44:27 --- 本文介绍了在Markdown文件中插入MathJax的方法。 # 直接插入 在html中插入以下代码，则可以用`$ $`来插入行内公式，`$$ $$`来插入单独成行的公式。 ```html MathJax.Hub.Config({ tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]} }); ``` 这是一个完整的可以工作的[例子](https://cdn.mathjax.org/mathjax/latest/test/sample-tex.html) ```html MathJax TeX Test Page MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}}); When $a \ne 0$, there are two solutions to \(ax^2 + bx + c = 0\) and they are $$x = {-b \pm \sqrt{b^2-4ac} \over 2a}.$$ ``` 在使用Markdown然后生成html的时候，Markdown有一些符号有特殊含义会被解析器转换成html的tag，如: 斜体`*被斜体的文字*`,斜体`_被斜体的文字_`等。 这样`$x _ i = y _ i$` 或者 `$x * y = y * x$` 会被解析成 $x _ i=y _ i$ 或者 $x * y = y * x$. 我们可以使用转义符号`\`来避免Markdown解析器对`* *`或`_ _`的转换。 写成`$x \_ i = y \_ i$ $x * y = y * x$`,就可以正确解析为$x\_i = y\_i$ $x \* y = y \* x$. 此方法优点: 简单，不需要插件辅助; 缺点: 不是原生的Tex语法。 # 使用插件 对于不同的markdown解析器应该会有不同的解决方案，如Hexo可以使用[hexo-math插件](https://github.com/akfish/hexo-math) hexo-math支持MathJax和KaTex. 使用标签则可以不需要对特殊符号进行转义。 ```markdown {% math %} \begin{aligned} \dot{x} & = \sigma(y-x) \\ \dot{y} & = \rho x - y - xz \\ \dot{z} & = -\beta z + xy \end{aligned} {% endmath %} ``` 此方法优点: 原生Tex语法; 缺点: 复杂，需要插件支持. Reference: 1. [TeX and LaTeX input](http://docs.mathjax.org/en/latest/start.html) 2. [hexo-math插件](https://github.com/akfish/hexo-math)]]></content>
      <categories>
        <category>MathJax</category>
        <category>tool</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>MathJax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件滤波算法的频率响应]]></title>
    <url>%2F2016%2F07%2F12%2Fsoftware-filtering-algorithm-and-frequency-response%2F</url>
    <content type="text"><![CDATA[title: 软件滤波算法的频率响应 categories: - filter tags: - filter - software comments: true layout: post date: 2016-07-12 01:03:42 modified: 2016-07-12 01:03:42 --- 本文从一种软件滤波算法切入，深入理解了滤波算法的频率响应。 # 引子 单片机大多资源小，算法占用的资源越小越好，有一种占用很小资源的算法，具体公式如下： $$ y[n] =y[n-1]- {y[n-1] \over m}+x[n]$$ 其中：x[n]为采样值，y[n]为滤波后的值，y[n-1]为上一次滤波值，m是放电比例(最好选2的幂次数，可用单片机移位)初始化时如果是跟踪一段时间后使用，可以是任何值，否则可以用采样值乘m初始化。 # 推导 如果写成这样 $$ y[n] = x[n] + (1- {1 \over m}) \* y[n-1]$$ (1) 然后令 $y[n]=m \* u[n]$,得 $$ n \* u[n] = x[n] + (1- {1 \over m}) \* m \* u[n-1]$$ 两边同时除m，得 $$ u[n] = {1 \over m} \* x[n] + (1- {1 \over m}) \* u[n-1]$$ 令 $ \alpha = {1 \over m}$，得 $$ u[n] = \alpha \* x[n] + (1-\alpha) \* u[n-1]$$ 这是典型的无限脉冲滤波器(IIR),也是最简单的低通滤波器。 如果直接由式(1)推导z变换 $$ Y(z) = X(z) + (1 - {1 \over m}) \* z^{-1}Y(z)$$ $$ H(z) = {Y(z) \over {X(z)}} = {1 \over {1-(1-{1 \over m}})z^{-1}}$$ 令$a={1-{1\over m}}$, $$ H(z)={1\over{1-az^{-1}} }$$ # IIR vs FIR IIR(Infinit Impulse Response)滤波器的[单位脉冲响应](https://en.wikipedia.org/wiki/Impulse_response)是无限长的，如例子中$H(z)={1\over{1-az^{-1}} }$时间域的序列是 $$ y[n] = x[n] + ay[n-1]$$ 根据单位脉冲响应的定义，即$x[n]= \delta[n]=\begin{cases} {1, n=0}\\\\{0, n \ne 0}\end{cases}$时的y[n]: $$ y[0] = x[0] + ay[-1] = 1, if n]]></content>
      <categories>
        <category>filter</category>
      </categories>
      <tags>
        <tag>software</tag>
        <tag>filter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib(1):简介]]></title>
    <url>%2F2016%2F07%2F01%2Fmatplotlib-1-introduction%2F</url>
    <content type="text"><![CDATA[title: matplotlib(1):简介 categories: - python - tool tags: - python - matplotlib comments: true layout: post date: 2016-07-01 21:11:08 modified: 2017-08-31 21:11:08 --- [matplotlib](http://matplotlib.org/)是一个python语言绘图库，本文介绍了matplotlib的安装和基本使用方法。 # what is matplotlib > matplotlib is a python 2D plotting library which produces publication quality figures in a variety of hardcopy formats and interactive environments across platforms. matplotlib can be used in python scripts, the python and ipython shell (ala MATLAB®* or Mathematica®†), web application servers, and six graphical user interface toolkits. * ala-法语，in the style/manner of * aka-also known as # install 1. python 参考[python download](http://www.python.org/download/) 本文安装的版本是2.7.8. 2. matplotlib 参考[matplotlib install](http://matplotlib.org/users/installing.html) 这里介绍windows的安装过程： 通过python的包管理工具[pip](https://pypi.python.org/pypi/pip)安装. 如果网络稳定，cmd下执行`pip install matplotlib`即可，pip会自动安装依赖包； 如果网络不稳定，需要下载[matplotlib的pip安装包](http://pypi.python.org/pypi/matplotlib/)，以及下列matplotlib依赖的安装包(注意版本兼容): [setuptools](https://pypi.python.org/pypi/setuptools/) [numpy](https://pypi.python.org/pypi/numpy/) [python-dateutil](https://pypi.python.org/pypi/python-dateutil/) [pytz](https://pypi.python.org/pypi/pytz) [pyparsing](https://pypi.python.org/pypi/pyparsing/) [cycler](https://pypi.python.org/pypi/Cycler) 然后`pip install /path/to/package/package-name.whl`来逐个安装。 安装完成后，在python命令行下执行`import matplotlib`，如果没有出错说明安装成功。 我的安装版本： {% asset_img matplotlib_version.png %} # play 通过numpy生成数据，pyplot来绘图。 ## simple plot {% include_code lang:python simple_plot python_matplot_simple_plot/simple_plot.py %} result: {% asset_img simple_plot.png %} Reference： 1. [Python-Matplotlib安装及简单使用](http://www.open-open.com/lib/view/open1393488232380.html) 2. [绘图: Python matplotlib简介](http://www.cnblogs.com/vamei/archive/2012/09/17/2689798.html)]]></content>
      <categories>
        <category>python</category>
        <category>tool</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MathJax(1):简介]]></title>
    <url>%2F2016%2F06%2F28%2FMathJax-1-introduction%2F</url>
    <content type="text"><![CDATA[title: MathJax(1):简介 categories: - MathJax - tool tags: - MathJax - TeX comments: true layout: post date: 2016-06-28 22:17:45 modified: 2016-06-28 22:17:45 --- 陈奕迅-不要说话 $$f(a)= {1 \over 2\pi i}\oint_\gamma {f(z) \over x-a}dz$$ MathJax入门简介，主要翻译MathJax的入门介绍。 # what is MathJax? [MathJax](https://www.mathjax.org)官网口号 > Beautiful math in all browsers > A JavaScript display engine for mathematics that works in all browsers. MathJax是为了解决浏览器中数学公式的显示问题而产生的一种解决方案，通过CSS或者SVG(而不是图片或Flash)来生成数学公式，可以实现无损缩放，可以拷贝到Office、LaTeX、wiki等；其输入形式可以是MathML、TeX或者ASCIImath，输出是HTML+CSS、SVG或者MathML. # how to learn? 官网[MathJax](https://www.mathjax.org)是最权威的。 推荐使用[StackEdit](https://stackedit.io/)学习MathJax的语法，它支持Markdown和MathJax. # how to use MathJax ## link to MathJax ### CDN 将 ``` ``` 放到``或者``里，然后就是在网页中放上TeX, MathML, 或者 AsciiMath 格式的数学公式就可以通过MathJax来渲染显示了。 其原理是：网页中包含的JS脚本会使网页从CDN服务器加载最新版本的MathJax，识别数学公式(Tex,MathML或者AsciiMath标记的)后输出HTML+CSS来显示数学公式。 ### local 下载MathJax到本地，然后link到网页。 方法参见[Installing Your Own Copy of MathJax](http://docs.mathjax.org/en/latest/start.html#installing-your-own-copy-of-mathjax). ## Put mathematics in web pages MathJax支持三种标记方法：Tex/LaTex、MathML和AsciiMath，可以[配置](http://docs.mathjax.org/en/latest/configuration.html)来告诉MathJax解析哪一种或哪几种标记方法，三种标记方法可以混用。 ### Tex/LaTex 默认的displayed公式分隔符有`$$...$$`和`\[…\]`,而默认的inline公式分隔符为`\(...\)`,当然这些都是可以自定义的，具体配置请[参考文档](http://docs.mathjax.org/en/latest/start.html#tex-and-latex-input)。由于修改了配置文件，我们在下文中使用`$...$`作为inline公式分隔符。 看一下效果： ```Tex Tex When $a \ne 0$, there are two solutions to \(ax^2 + bx + c = 0\) and they are $$x = {-b \pm \sqrt{b^2-4ac} \over 2a}.$$ ``` When $a \ne 0$, there are two solutions to \(ax^2 + bx + c = 0\) and they are $$x = {-b \pm \sqrt{b^2-4ac} \over 2a}.$$ ### MathML 效果参见[sample-mml.html](https://cdn.mathjax.org/mathjax/latest/test/sample-mml.html) ### AsciiMath 效果参见[sample-asciimath.html](https://cdn.mathjax.org/mathjax/latest/test/sample-asciimath.html) Reference: 1. [Getting Started](http://docs.mathjax.org/en/latest/start.html) 2. [Mathjax与LaTex公式简介](http://mlworks.cn/posts/introduction-to-mathjax-and-latex-expression/)]]></content>
      <categories>
        <category>MathJax</category>
        <category>tool</category>
      </categories>
      <tags>
        <tag>MathJax</tag>
        <tag>TeX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[湿度humidity]]></title>
    <url>%2F2016%2F06%2F01%2Fhumidity%2F</url>
    <content type="text"><![CDATA[title: 湿度humidity categories: - 气象 tags: - humidity comments: true layout: post date: 2016-06-01 16:12:30 modified: 2016-06-01 16:12:30 --- {% asset_img humidity.jpg %} 湿度(Humidity)用来表征空气中水蒸气(water vapor)的含量。有三种计量方式：绝对湿度(Absolute Humidity)、相对湿度(Relative Hmidity)、比湿度(Specific Humidity)。 # 绝对湿度 绝对湿度指每立方米空气中所含水蒸气的质量，即水蒸气密度，单位为g/m3。 随着温度和气压的变化，绝对湿度会变化。 温度越高，绝对湿度越小。 气压越高，绝对湿度越大。 # 相对湿度 相对湿度(RH)指空气中水蒸气压与相同情况下饱和水蒸气压的百分比，表示形式如90%RH。百分比越高，湿度越大。 相对湿度能反映降水的可能性，所以常用在天气预报中。 在炎热的夏天天气，相对湿度的上升会阻碍皮肤的汗水蒸发，从而增加人类的体感温度。 # 比湿度 一团由干空气和水汽组成的湿空气中的水汽质量与湿空气的总质量之比。若湿空气与外界无质量交换，且无相变，则比湿保持不变。以g/g或g/kg为单位，通常大气中比湿都小于40g/kg。 Reference: 1. [Humidity wiki](https://en.wikipedia.org/wiki/Humidity)]]></content>
      <categories>
        <category>气象</category>
      </categories>
      <tags>
        <tag>humidity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hamming Distance]]></title>
    <url>%2F2016%2F05%2F12%2Fhamming-distance%2F</url>
    <content type="text"><![CDATA[title: Hamming Distance categories: - distance - coding tags: - hamming-distance comments: true layout: post date: 2016-05-12 21:32:44 modified: 2016-05-12 21:32:44 --- 蔡健雅-达尔文 {% asset_img Hamming_distance_4_bit_binary_example Hamming_distance_4_bit_binary_example.svg.png %} Hamming distance is a metric to measure difference between two strings of equal length or two data with same length(eg. two binary data with same bits). # Definiton > In information theory, the [Hamming distance](https://en.wikipedia.org/wiki/Hamming_distance) between two strings of equal length is the number of positions at which the corresponding symbols are different. In another way, it measures the minimum number of substitutions required to change one string into the other, or the minimum number of errors that could have transformed one string into the other. # Example ## String the Hamming distance between below two strings is 8. "Hello,world" "world,hello" 11101011101 | 8 there is a [python distance lib](https://github.com/doukremt/distance) which can calculate hamming distance. ```python >>> import distance as ds >>> ds.hamming("hello,world", "world,hello") 8 ``` ## Data hamming distance between `1011101` and `1001001` is 2. Here data can be binary or octonary or decimal or hexadecimal, but the two data should be with same length in same system. # Application ## Coding theory In coding theory, hamming distance is used as error detecting and error correcting codes(ECC). a code with minimum Hamming distance d between its codewords can detect at most d-1 errors and can correct (d-1)/2 errors.The latter number is also called the error-correcting capability of the code. For error detecting, hammind distance is usde to evaluate the performace of algorithm. Let's say, there are fixed-length data d, then we count a checksum C using differet algorithm. then we have data(d, C). we can get the minimum hamming distance d in set(d, C). so the algorithm can detect d-1 errors and correct (d-1)/2 errors. CRC is generally better than modular sum. For error correcting, there is a kind of ECC named as [Hamming Code](https://en.wikipedia.org/wiki/Hamming_code). ## Programming In softwar programming, there is a simple method to protect data from unexpected bit inverse(eg. soft error). By define enum type like this: ```C typedef { Red = 0x0F, Blue = 0x33, Green = 0x3C }Color; ``` the minimum hamming distance between `Red`,`Blue` and `Green` is 4. # Generate data set with min hamming distance {% include_code lang:python min_hamming_distance_set hamming_distance/min_hamming_distance_set.py %} `data=[0]` defines the first number of data set; `min_hamming_distance` defines the min hanmming distance of the data set. ```text result 00000000(0x00) 00001111(0x0f) 00110011(0x33) 00111100(0x3c) 01010101(0x55) 01011010(0x5a) 01100110(0x66) 01101001(0x69) 10010110(0x96) 10011001(0x99) 10100101(0xa5) 10101010(0xaa) 11000011(0xc3) 11001100(0xcc) 11110000(0xf0) ``` Reference： 1. [Hamming distance in wiki](https://en.wikipedia.org/wiki/Hamming_distance) 2. [Hamming Code](https://en.wikipedia.org/wiki/Hamming_code) 3. [python distance lib](https://github.com/doukremt/distance) 4. [python format](https://docs.python.org/2/library/string.html#format-examples)]]></content>
      <categories>
        <category>distance</category>
        <category>coding</category>
      </categories>
      <tags>
        <tag>hamming-distance</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人博客搭建hexo+github(8):独立域名绑定github]]></title>
    <url>%2F2016%2F04%2F28%2FStatic-Blog-hexo-github-8-binding-domain%2F</url>
    <content type="text"><![CDATA[title: 个人博客搭建hexo+github(8):独立域名绑定github categories: - hexo tags: - hexo - github - DNS - blog comments: true layout: post date: 2016-04-28 19:43:26 modified: 2017-02-12 19:43:26 --- 独立域名绑定到github的方法。 attraction - 小泽正澄 # 购买域名 我是在[万网](https://wanwang.aliyun.com/)购买的，现在已经被阿里云收归旗下，比[狗爹](https://www.godaddy.com/)便宜，第一年45块。 # DNS设置 我使用的是国内的[DNSPod](https://www.dnspod.cn)。 ## DNS服务器 域名解析的DNS服务器设置为SNSPod的地址 {% asset_img DNS_server.png %} ## DNS记录 github Pages和coding Pages同时部署了，DNSPod的一个好处是可以将国内和国内的访问使用不同路线。 国内的访问路由到github,国外的路由到coding. 几种常用的记录类型： ``` A记录：地址记录，用来指定域名的IPv4地址（如：8.8.8.8），如果需要将域名指向一个IP地址，就需要添加A记录。 CNAME： 如果需要将域名指向另一个域名，再由另一个域名提供ip地址，就需要添加CNAME记录。 NS：域名服务器记录，如果需要把子域名交给其他DNS服务商解析，就需要添加NS记录。 ``` NS记录为不可修改的域名服务器记录。 A记录用来指定[github pages的IP地址](https://help.github.com/articles/troubleshooting-custom-domains/)，可不设置。 CNAME记录需要指定`www`和`@`两种主机记录（域名前缀）。 github的CNAME指向`username.github.io` 或者 `github.map.fastly.net`; coding的CNAME指向`pages.coding.me`。 {% asset_img DNSPod_set.png %} # CNAME重定向 在hexo/source目录下新建名为`CNAME`的文件，没有后缀。 内容为域名，我这里是`wuchenxu.com`，没有`www`的。 coding需要手动设置绑定域名 {% asset_img CNAME_CodingPages.png %} 绑定两个网址，一个带`www`，另一个不带`www`，这样两个网址都能够访问。一开始我只绑定了不带`www`的网址，导致输入`www.wuchenxu.com`无法解析。 # 启用 重新部署`hexo d -g`后，可以通过独立域名访问博客啦。 # 查看访问源 可以看到访问的是coding Pages。 {% asset_img ping_domain.png %} # Debug 发现用移动网络可以访问，但是连接家里的广电宽带就是访问不了，出现`DNS_PROBE_FINISHED_NXDOMAIN`错误。 通过[手动设置DNS](http://bbs.guanjia.qq.com/forum.php?mod=viewthread&tid=2092936&extra=)后问题解决。 {% asset_img PC_set_DNS_Server.png %} References: 1. [域名和github绑定的问题](http://www.jianshu.com/p/1d427e888dda) 2. [如何搭建一个独立博客](http://cnfeat.com/blog/2014/05/10/how-to-build-a-blog/) 3. [将独立域名与GitHub Pages的空间绑定](http://iread.io/2015/09/hexo-guide-4/)]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>blog</tag>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python脚本嵌入bat脚本执行]]></title>
    <url>%2F2016%2F04%2F26%2Fpython-srcipt-embedded-in-bat%2F</url>
    <content type="text"><![CDATA[title: python脚本嵌入bat脚本执行 categories: - windows cmd - python tags: - cmd - python comments: true layout: post date: 2016-04-26 21:58:37 modified: 2016-04-26 21:58:37 --- 通过bat脚本的注释`rem`以及python脚本的注释`"""`实现将python脚本嵌入到bat脚本中执行。 将python语句嵌入到bat脚本中，直接执行bat脚本的最终结果是执行python脚本。 python脚本可以接收bat脚本的命令行输入参数。 主要用到三个技巧： 1. bat的注释`rem` 2. python的多行注释`"""` 3. bat的goto label {% include_code lang:bat PythonScriptInBat PythonScriptInBat/pythonScriptInBat.bat %}]]></content>
      <categories>
        <category>windows cmd</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>cmd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows command(17):多线程 start call cmd]]></title>
    <url>%2F2016%2F04%2F01%2Fwindows-cmd-17-multiple-thread%2F</url>
    <content type="text"><![CDATA[title: windows command(17):多线程 start call cmd categories: - windows cmd tags: - cmd - start - call comments: true layout: post date: 2016-04-01 14:32:28 modified: 2016-06-13 --- 本多RuRu-美丽心情 start启动独立窗口;call调用另一个脚本;cmd启动Windows命令解释器的一个新实例. # start 启动一个单独的窗口以运行指定的程序或命令。 ```bat 以最大化方式启动画图板 start /max mspaint ``` ```bat 启动记事本，并打开a.txt，在关闭记事本之前cmd等待 start /wait notepad a.txt ``` ```bat 打开指定目录 start "" d:\test\" ``` ```bat 打开当前目录 start. ``` # call 从一个批处理程序调用另一个批处理程序，并且不终止父批处理程序。call 命令接受用作调用目标的标签。如果在脚本或批处理文件外使用 Call，它将不会在命令行起作用。 调用格式： `call :label arg` 被调用程序语法： ``` :label cmd1 ... cmdn goto :eof ``` 被调用程序中，参数%0 指标签:label. ## 例1：父子程序都被执行 ```test.bat @echo off call :label :label echo %0 %1 goto :eof ``` ``` >test.bat hello :label test.bat hello ``` ## 例2:加法 ``` @echo off set sum=0 call :add sum 10 20 30 echo result: %sum% goto :eof :add rem arg1 is return value set /a %1=%1+%2 shift /2 if not "%2"=="" goto add goto :eof ``` `:label`一样，call后面是必须是`:label`，而goto则可以是`label`或者`:label`。 # cmd 启动 Windows 命令解释器的一个新实例 Reference: ```text help start 启动一个单独的窗口以运行指定的程序或命令。 START ["title"] [/D path] [/I] [/MIN] [/MAX] [/SEPARATE | /SHARED] [/LOW | /NORMAL | /HIGH | /REALTIME | /ABOVENORMAL | /BELOWNORMAL] [/NODE ] [/AFFINITY ] [/WAIT] [/B] [command/program] [parameters] "title" 在窗口标题栏中显示的标题。 path 启动目录。 B 启动应用程序，但不创建新窗口。 应用程序已忽略 ^C 处理。除非应用程序 启用 ^C 处理，否则 ^Break 是唯一可以中断 该应用程序的方式。 I 新的环境将是传递 给 cmd.exe 的原始环境，而不是当前环境。 MIN 以最小化方式启动窗口。 MAX 以最大化方式启动窗口。 SEPARATE 在单独的内存空间中启动 16 位 Windows 程序。 SHARED 在共享内存空间中启动 16 位 Windows 程序。 LOW 在 IDLE 优先级类中启动应用程序。 NORMAL 在 NORMAL 优先级类中启动应用程序。 HIGH 在 HIGH 优先级类中启动应用程序。 REALTIME 在 REALTIME 优先级类中启动应用程序。 ABOVENORMAL 在 ABOVENORMAL 优先级类中启动应用程序。 BELOWNORMAL 在 BELOWNORMAL 优先级类中启动应用程序。 NODE 将首选非一致性内存结构(NUMA)节点指定为 十进制整数。 AFFINITY 将处理器关联掩码指定为十六进制数字。 进程被限制在这些处理器上运行。 将 /AFFINITY 和 /NODE 结合使用时，会对关联掩码 进行不同的解释。指定关联掩码，以便将零位作为起始位置(就如将 NUMA 节点的处理器掩码向右移位一样)。 进程被限制在指定关联掩码和 NUMA 节点之间的 那些通用处理器上运行。 如果没有通用处理器，则进程被限制在 指定的 NUMA 节点上运行。 WAIT 启动应用程序并等待它终止。 command/program 如果它是内部 cmd 命令或批文件，则 该命令处理器是使用 cmd.exe 的 /K 开关运行的。 这表示运行该命令之后，该窗口 将仍然存在。 如果它不是内部 cmd 命令或批文件，则 它就是一个程序，并将作为一个窗口化应用程序或 控制台应用程序运行。 parameters 这些是传递给 command/program 的参数。 注意: 在 64 位平台上不支持 SEPARATE 和 SHARED 选项。 通过指定 /NODE，可按照利用 NUMA 系统中的内存区域的方式 创建进程。例如，可以创建两个完全 通过共享内存互相通信的进程以共享相同的首选 NUMA 节点， 从而最大限度地减少内存延迟。只要有可能， 它们就会分配来自相同 NUMA 节点的 内存，并且会在指定节点之外的处理器上自由运行。 start /NODE 1 application1.exe start /NODE 1 application2.exe 这两个进程可被进一步限制在相同 NUMA 节点内的指定处理器 上运行。在以下示例中，application1 在 节点的两个低位处理器上运行，而 application2 在该节点的其后两个处理器上运行。该示例假定指定节点至少具有四个逻辑处理器。请注意，节点号可更改为该计算机的任何有效节点号， 而无需更改关联掩码。 start /NODE 1 /AFFINITY 0x3 application1.exe 启动 /NODE 1 /AFFINITY 0xc application2.exe 如果命令扩展被启用，通过命令行或 START 命令的外部命令 调用会如下改变: 将文件名作为命令键入，非可执行文件可以通过文件关联调用。 (例如，WORD.DOC 会调用跟 .DOC 文件扩展名关联的应用程序)。 关于如何从命令脚本内部创建这些关联，请参阅 ASSOC 和 FTYPE 命令。 执行的应用程序是 32 位 GUI 应用程序时，CMD.EXE 不等应用 程序终止就返回命令提示符。如果在命令脚本内执行，该新行为 则不会发生。 如果执行的命令行的第一个符号是不带扩展名或路径修饰符的 字符串 "CMD"，"CMD" 会被 COMSPEC 变量的数值所替换。这 防止从当前目录提取 CMD.EXE。 如果执行的命令行的第一个符号没有扩展名，CMD.EXE 会使用 PATHEXT 环境变量的数值来决定要以什么顺序寻找哪些扩展 名。PATHEXT 变量的默认值是: .COM;.EXE;.BAT;.CMD 请注意，该语法跟 PATH 变量的一样，分号隔开不同的元素。 查找可执行文件时，如果没有相配的扩展名，看一看该名称是否 与目录名相配。如果确实如此，START 会在那个路径上调用 Explorer。如果从命令行执行，则等同于对那个路径作 CD /D。 ``` ```text help call 从批处理程序调用另一个批处理程序。 CALL [drive:][path]filename [batch-parameters] batch-parameters 指定批处理程序所需的命令行信息。 如果命令扩展被启用，CALL 会如下改变: CALL 命令现在将卷标当作 CALL 的目标接受。语法是: CALL:label arguments 一个新的批文件上下文由指定的参数所创建，控制在卷标被指定 后传递到语句。你必须通过达到批脚本文件末两次来 "exit" 两次。 第一次读到文件末时，控制会回到 CALL 语句的紧后面。第二次 会退出批脚本。键入 GOTO /?，参看 GOTO :EOF 扩展的描述， 此描述允许你从一个批脚本返回。 另外，批脚本文本参数参照(%0、%1、等等)已如下改变: 批脚本里的 %* 指出所有的参数(如 %1 %2 %3 %4 %5 ...) 批参数(%n)的替代已被增强。你可以使用以下语法: %~1 - 删除引号(")，扩展 %1 %~f1 - 将 %1 扩展到一个完全合格的路径名 %~d1 - 仅将 %1 扩展到一个驱动器号 %~p1 - 仅将 %1 扩展到一个路径 %~n1 - 仅将 %1 扩展到一个文件名 %~x1 - 仅将 %1 扩展到一个文件扩展名 %~s1 - 扩展的路径只含有短名 %~a1 - 将 %1 扩展到文件属性 %~t1 - 将 %1 扩展到文件的日期/时间 %~z1 - 将 %1 扩展到文件的大小 %~$PATH:1 - 查找列在 PATH 环境变量的目录，并将 %1 扩展到找到的第一个完全合格的名称。如果 环境变量名未被定义，或者没有找到文件， 此修改符会扩展到空字符串 可以组合修改符来取得多重结果: %~dp1 - 只将 %1 扩展到驱动器号和路径 %~nx1 - 只将 %1 扩展到文件名和扩展名 %~dp$PATH:1 - 在列在 PATH 环境变量中的目录里查找 %1， 并扩展到找到的第一个文件的驱动器号和路径。 %~ftza1 - 将 %1 扩展到类似 DIR 的输出行。 在上面的例子中，%1 和 PATH 可以被其他有效数值替换。 %~ 语法被一个有效参数号码终止。%~ 修定符不能跟 %* 使用 ``` ```text help cmd 启动 Windows 命令解释器的一个新实例 CMD [/A | /U] [/Q] [/D] [/E:ON | /E:OFF] [/F:ON | /F:OFF] [/V:ON | /V:OFF] [[/S] [/C | /K] string] /C 执行字符串指定的命令然后终止 /K 执行字符串指定的命令但保留 /S 修改 /C 或 /K 之后的字符串处理(见下) /Q 关闭回显 /D 禁止从注册表执行 AutoRun 命令(见下) /A 使向管道或文件的内部命令输出成为 ANSI /U 使向管道或文件的内部命令输出成为 Unicode /T:fg 设置前台/背景颜色(详细信息见 COLOR /?) /E:ON 启用命令扩展(见下) /E:OFF 禁用命令扩展(见下) /F:ON 启用文件和目录名完成字符(见下) /F:OFF 禁用文件和目录名完成字符(见下) /V:ON 使用 ! 作为分隔符启用延迟的环境变量 扩展。例如，/V:ON 会允许 !var! 在执行时 扩展变量 var。var 语法会在输入时 扩展变量，这与在一个 FOR 循环内不同。 /V:OFF 禁用延迟的环境扩展。 注意，如果字符串加有引号，可以接受用命令分隔符 "&&" 分隔多个命令。另外，由于兼容性 原因，/X 与 /E:ON 相同，/Y 与 /E:OFF 相同，且 /R 与 /C 相同。任何其他开关都将被忽略。 如果指定了 /C 或 /K，则会将该开关之后的 命令行的剩余部分作为一个命令行处理，其中，会使用下列逻辑 处理引号(")字符: 1. 如果符合下列所有条件，则会保留 命令行上的引号字符: - 不带 /S 开关 - 正好两个引号字符 - 在两个引号字符之间无任何特殊字符， 特殊字符指下列字符: &()@^| - 在两个引号字符之间至少有 一个空格字符 - 在两个引号字符之间的字符串是某个 可执行文件的名称。 2. 否则，老办法是看第一个字符 是否是引号字符，如果是，则去掉首字符并 删除命令行上最后一个引号，保留 最后一个引号之后的所有文本。 如果 /D 未在命令行上被指定，当 CMD.EXE 开始时，它会寻找 以下 REG_SZ/REG_EXPAND_SZ 注册表变量。如果其中一个或 两个都存在，这两个变量会先被执行。 HKEY_LOCAL_MACHINE\Software\Microsoft\Command Processor\AutoRun 和/或 HKEY_CURRENT_USER\Software\Microsoft\Command Processor\AutoRun 命令扩展是按默认值启用的。你也可以使用 /E:OFF ，为某一 特定调用而停用扩展。你 可以在机器上和/或用户登录会话上 启用或停用 CMD.EXE 所有调用的扩展，这要通过设置使用 REGEDIT.EXE 的注册表中的一个或两个 REG_DWORD 值: HKEY_LOCAL_MACHINE\Software\Microsoft\Command Processor\EnableExtensions 和/或 HKEY_CURRENT_USER\Software\Microsoft\Command Processor\EnableExtensions 到 0x1 或 0x0。用户特定设置 比机器设置有优先权。命令行 开关比注册表设置有优先权。 在批处理文件中，SETLOCAL ENABLEEXTENSIONS 或 DISABLEEXTENSIONS 参数 比 /E:ON 或 /E:OFF 开关有优先权。请参阅 SETLOCAL /? 获取详细信息。 命令扩展包括对下列命令所做的 更改和/或添加: DEL or ERASE COLOR CD or CHDIR MD or MKDIR PROMPT PUSHD POPD SET SETLOCAL ENDLOCAL IF FOR CALL SHIFT GOTO START (同时包括对外部命令调用所做的更改) ASSOC FTYPE 有关特定详细信息，请键入 commandname /? 查看。 延迟环境变量扩展不按默认值启用。你 可以用/V:ON 或 /V:OFF 开关，为 CMD.EXE 的某个调用而 启用或停用延迟环境变量扩展。你 可以在机器上和/或用户登录会话上启用或停用 CMD.EXE 所有 调用的延迟扩展，这要通过设置使用 REGEDIT.EXE 的注册表中的 一个或两个 REG_DWORD 值: HKEY_LOCAL_MACHINE\Software\Microsoft\Command Processor\DelayedExpansion 和/或 HKEY_CURRENT_USER\Software\Microsoft\Command Processor\DelayedExpansion 到 0x1 或 0x0。用户特定设置 比机器设置有优先权。命令行开关 比注册表设置有优先权。 在批处理文件中，SETLOCAL ENABLEDELAYEDEXPANSION 或 DISABLEDELAYEDEXPANSION 参数比 /V:ON 或 /V:OFF 开关有优先权。请参阅 SETLOCAL /? 获取详细信息。 如果延迟环境变量扩展被启用， 惊叹号字符可在执行时间被用来 代替一个环境变量的数值。 你可以用 /F:ON 或 /F:OFF 开关为 CMD.EXE 的某个 调用而启用或禁用文件名完成。你可以在计算上和/或 用户登录会话上启用或禁用 CMD.EXE 所有调用的完成， 这可以通过使用 REGEDIT.EXE 设置注册表中的下列 REG_DWORD 的全部或其中之一: HKEY_LOCAL_MACHINE\Software\Microsoft\Command Processor\CompletionChar HKEY_LOCAL_MACHINE\Software\Microsoft\Command Processor\PathCompletionChar 和/或 HKEY_CURRENT_USER\Software\Microsoft\Command Processor\CompletionChar HKEY_CURRENT_USER\Software\Microsoft\Command Processor\PathCompletionChar 由一个控制字符的十六进制值作为一个特定参数(例如，0x4 是Ctrl-D，0x6 是 Ctrl-F)。用户特定设置优先于机器设置。 命令行开关优先于注册表设置。 如果完成是用 /F:ON 开关启用的，两个要使用的控制符是: 目录名完成用 Ctrl-D，文件名完成用 Ctrl-F。要停用 注册表中的某个字符，请用空格(0x20)的数值，因为此字符 不是控制字符。 如果键入两个控制字符中的一个，完成会被调用。完成功能将 路径字符串带到光标的左边，如果没有通配符，将通配符附加 到左边，并建立相符的路径列表。然后，显示第一个相符的路 径。如果没有相符的路径，则发出嘟嘟声，不影响显示。之后， 重复按同一个控制字符会循环显示相符路径的列表。将 Shift 键跟控制字符同时按下，会倒着显示列表。如果对该行进行了 任何编辑，并再次按下控制字符，保存的相符路径的列表会被 丢弃，新的会被生成。如果在文件和目录名完成之间切换，会 发生同样现象。两个控制字符之间的唯一区别是文件完成字符 符合文件和目录名，而目录完成字符只符合目录名。如果文件 完成被用于内置式目录命令(CD、MD 或 RD)，就会使用目录 完成。 用引号将相符路径括起来，完成代码可以正确处理含有空格 或其他特殊字符的文件名。同时，如果备份，然后从行内调用 文件完成，完成被调用时位于光标右方的文字会被调用。 需要引号的特殊字符是: ()[]{}^=;!'+,`~(&() ```]]></content>
      <categories>
        <category>windows cmd</category>
      </categories>
      <tags>
        <tag>cmd</tag>
        <tag>start</tag>
        <tag>call</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows command(16):组合命令 & |]]></title>
    <url>%2F2016%2F04%2F01%2Fwindows-cmd-16-compound-command%2F</url>
    <content type="text"><![CDATA[title: windows command(16):组合命令 & | categories: - windows cmd tags: - cmd comments: true layout: post date: 2016-04-01 14:29:48 modified: 2016-04-01 14:29:48 --- 组合命令(Compound Command)主要有`&` `&&` `|` `||`等。 # 顺序执行多个命令`&` `cmd1 & cmd2 [& cmd3 ...]` 相对于把多个语句并到一行了。 ```bat 不管前一个命令是否执行成功，都会执行下一个命令 D:\test\test>dir A & echo hello 驱动器 D 中的卷是 LENOVO 卷的序列号是 0005-42D7 D:\test\test 的目录 找不到文件 hello ``` # 执行失败则不执行下一条语句`&&` `cmd1 && cmd2 [&& cmd3 ...]` ```bat echo hello不能被执行 D:\test\test>dir A && echo hello 驱动器 D 中的卷是 LENOVO 卷的序列号是 0005-42D7 D:\test\test 的目录 找不到文件 ``` `dir A && echo hello`相当于 ``` dir A if %ERRORLEVEL% equ 0 (echo hello) ``` # 执行成功则不执行下一条语句`||` `cmd1 || cmd2 [|| cmd3 ...]` ```bat dir A不能被执行 D:\test\test>echo hello || dir A hello ``` `echo hello || dir A`相当于 ``` echo hello if %ERRORLEVEL% neq 0 (dir A) ``` # 管道`|` `cmd1 | cmd2 [| cmd3 ...]` 将前一条命令的执行结果作为后一条命令的参数。 `netstat -n -p tcp|find ":80"`]]></content>
      <categories>
        <category>windows cmd</category>
      </categories>
      <tags>
        <tag>cmd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows command(15):SHIFT及参数编辑符%~dp0]]></title>
    <url>%2F2016%2F04%2F01%2Fwindows-cmd-15-shift%2F</url>
    <content type="text"><![CDATA[title: windows command(15):SHIFT及参数编辑符%~dp0 categories: - windows cmd tags: - cmd - shift - parameter comments: true layout: post date: 2016-04-01 14:22:44 modified: 2016-04-03 20:33:44 --- {% asset_img shift.png %} 本文介绍了bat脚本支持的参数，SHIFT命令替换bat脚本参数位置。 # batch脚本支持的参数 支持%1~%9，9个参数，%0表示命令本身。如果写成%10，则是表示%1之后跟一个`0`. ```bat parameters.bat @echo off echo 0: %0 echo 1: %1 echo 2: %2 echo 3: %3 echo 4: %4 echo 5: %5 echo 6: %6 echo 7: %7 echo 8: %8 echo 9: %9 echo 10: %10 ``` 运行结果: ```bat result D:\test\test>paramters.bat hello 1 2 3 4 5 6 7 8 9 0: paramters.bat 1: hello 2: 1 3: 2 4: 3 5: 4 6: 5 7: 6 8: 7 9: 8 10: hello0 ``` # 参数编辑 可以在批处理参数中使用编辑符。编辑符使用当前的驱动器和目录信息将批处理参数作为部分或完整的文件或目录名进行扩展。要使用编辑符，请键入百分号 (%) 字符，后面是波形符号 (~) 字符，然后键入合适的编辑符（即 %~modifier）。 下表列出了可在扩展中使用的编辑符。 | modifier | Description | |:---------:|:--------------------------------:| | %~1 | 扩展 %1 并删除任何外围引号 ("") | | %~f1 | 将 %1 扩展到完全合格的路径名 | | %~d1 | 将 %1 扩展到驱动器盘符 | | %~p1 | 将 %1 扩展到路径 | | %~n1 | 将 %1 扩展到文件名 | | %~x1 | 将 %1 扩展到文件扩展名 | | %~s1 | 扩展的路径仅包含短名称 | | %~a1 | 将 %1 扩展到文件属性 | | %~t1 | 将 %1 扩展到文件日期/时间 | | %~z1 | 将 %1 扩展到文件大小 | | %~$PATH:1 |搜索 PATH 环境变量中列出的目录，并将 %1 扩展到第一个找到的目录的完全合格名称。如果没有定义环境变量名称，或没有找到文件，则此编辑符扩展成空字符串| 以上编辑符可以组合使用： | modifier | Description | |:-----------:|:--------------------------------:| | %~dp1 | 将 %1 扩展到驱动器盘符和路径 | | %~nx1 | 将 %1 扩展到文件名和扩展名 | | %~ftza1 | 将 %1 扩展到类似 dir 的输出行 | | %~dp$PATH:1 | 在 PATH 环境变量列出的目录中搜索 %1，并扩展到第一个找到的目录的驱动器盘符和路径 | ```bat parameters.bat @echo off echo ~0 : %~0 echo ~f0: %~f0 echo ~d0: %~d0 echo ~p0: %~p0 echo ~n0: %~n0 echo ~x0: %~x0 echo ~s0: %~s0 echo ~a0: %~a0 echo ~t0: %~t0 echo ~z0: %~z0 echo ~PATH0: %~$PATH:0 echo ~dp0: %~dp0 echo ~nx0: %~nx0 echo ~ftza0: %~ftza0 ``` ```text result ~0 : paramters.bat ~f0: D:\test\test\paramters.bat ~d0: D: ~p0: \test\test\ ~n0: paramters ~x0: .bat ~s0: D:\test\test\paramters.bat ~a0: --a-------- ~t0: 2016/04/03 21:37 ~z0: 536 ~PATH0: ~dp0: D:\test\test\ ~nx0: paramters.bat ~ftza0: --a-------- 2016/04/03 21:37 536 D:\test\test\paramters.bat ``` # 支持超过9个参数 SHIFT命令可以支持超过9个参数输入。 ```bat parameters_shift.bat @echo off echo 0: %0 echo 1: %1 echo 2: %2 echo 3: %3 echo 4: %4 echo 5: %5 echo 6: %6 echo 7: %7 echo 8: %8 echo 9: %9 echo 10: %10 shift echo 0: %0 echo 1: %1 echo 2: %2 echo 3: %3 echo 4: %4 echo 5: %5 echo 6: %6 echo 7: %7 echo 8: %8 echo 9: %9 echo 10: %10 ``` 运行结果: ``` D:\test\test>parameters_shift.bat hello 1 2 3 4 5 6 7 8 9 0: parameters_shift.bat 1: hello 2: 1 3: 2 4: 3 5: 4 6: 5 7: 6 8: 7 9: 8 10: hello0 0: hello 1: 1 2: 2 3: 3 4: 4 5: 5 6: 6 7: 7 8: 8 9: 9 10: 10 ``` # 选择性替换 如果命令扩展被启用，SHIFT 命令支持/n 命令行开关；该命令行开关告诉 命令从第 n 个参数开始移位；n 介于零和八之间。例如: SHIFT /2 会将 %3 移位到 %2，将 %4 移位到 %3，等等；并且不影响 %0 和 %1。 # 应用 拷贝任意个文件到指定文件夹 ```bat mycopy.bat @echo off rem MYCOPY.BAT copies any number of files rem to a directory. rem The command uses the following syntax: rem mycopy dir file1 file2 ... set todir=%1 :getfile shift if "%1"=="" goto end copy %1 %todir% goto getfile :end set todir= echo All done ``` Reference: ```text help SHIFT 更改批处理文件中可替换参数的位置。 SHIFT [/n] 如果命令扩展被启用，SHIFT 命令支持/n 命令行开关；该命令行开关告诉 命令从第 n 个参数开始移位；n 介于零和八之间。例如: SHIFT /2 会将 %3 移位到 %2，将 %4 移位到 %3，等等；并且不影响 %0 和 %1。 ``` [cmd批处理参数](http://www.cnblogs.com/top5/archive/2011/06/24/2089183.html)]]></content>
      <categories>
        <category>windows cmd</category>
      </categories>
      <tags>
        <tag>cmd</tag>
        <tag>shift</tag>
        <tag>parameter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows command(14):SET SETLOCAL ENDLOCAL]]></title>
    <url>%2F2016%2F04%2F01%2Fwindows-cmd-14-set-setlocal-endlocal%2F</url>
    <content type="text"><![CDATA[title: windows command(14):SET SETLOCAL ENDLOCAL categories: - windows cmd tags: - cmd - set comments: true layout: post date: 2016-04-01 14:21:57 modified: 2016-04-01 14:21:57 --- {% asset_img set.png %} 变量设置命令，非常有用。 # 基本语法 `set [[/a [expression]] [/p [variable=]] string]` ```bat D:\test\test>set a=1 D:\test\test>echo %a% 1 ``` # 无参数 `set`的执行结果是显示所有环境变量;如果跟字符串，会显示匹配字符串的环境变量。 ``` D:\test\test>set win windir=C:\WINDOWS ``` # 常规用法 ``` D:\test\test>set a=123 D:\test\test>echo %a% 123 rem cancel var a D:\test\test>set a= D:\test\test>echo %a% %a% ``` # 参数/A /A 命令行开关指定等号右边的字符串为被评估的数字表达式。 ```bat D:\test\test>set /a b=1+%a% 2 ``` # 参数/P /P 命令行开关允许将变量数值设成用户输入的一行输入。读取输入 行之前，显示指定的 promptString。promptString 可以是空的。 ```bat D:\test\test>set /p c= 123 D:\test\test>echo %c% 123 ``` # 变量格式化 ## 替换 Replace `%PATH:str1=str2%`会扩展 PATH 环境变量，用 "str2" 代替扩展结果中的每个 "str1"。要有效地从扩展结果中删除所有的 "str1"，"str2" 可以是空的。 "str1" 可以以星号打头；在这种情况下，"str1" 会从扩展结果的开始到 str1 剩余部分第一次出现的地方，都一直保持相配。 ```bat D:\test\test>set str=hello_world D:\test\test>echo %str:*o=hi% hi_world ``` ## 子集 Subset `%PATH:~10,5%`会扩展 PATH 环境变量，然后只使用在扩展结果中从第 11 个(偏移量 10)字符开始的五个字符。如果没有指定长度，则采用默认 值，即变量数值的余数。如果两个数字(偏移量和长度)都是负数，使用的数字则是环境变量数值长度加上指定的偏移量或长度。 `%PATH:~-10%`会提取 PATH 变量的最后十个字符。 `%PATH:~0,-2%`会提取 PATH 变量的所有字符，除了最后两个。 ```bat D:\test\test>echo %str:~0,5% hello D:\test\test>echo %str:~-2% ld ``` # 动态环境变量 %CD% - 扩展到当前目录字符串。 %DATE% - 用跟 DATE 命令同样的格式扩展到当前日期。 %TIME% - 用跟 TIME 命令同样的格式扩展到当前时间。 %RANDOM% - 扩展到 0 和 32767 之间的任意十进制数字。 %ERRORLEVEL% - 扩展到当前 ERRORLEVEL 数值。 ``` D:\test\test>echo %CD% D:\test\test D:\test\test>echo %DATE% 2016/04/19 周二 D:\test\test>echo %DATE:~0,10% 2016/04/19 D:\test\test>echo %TIME% 22:17:53.64 D:\test\test>echo %RANDOM% 21380 D:\test\test>echo %RANDOM% 9100 D:\test\test>echo %RANDOM% 26811 D:\test\test>echo %RANDOM% 10502 ``` # 环境变量本地化修改SETLOCAL ENDLOCAL 开始批处理文件中环境改动的本地化操作。在执行 SETLOCAL 之后所做的环境改动只限于批处理文件。要还原原先的设置，必须执行 ENDLOCAL。达到批处理文件结尾时，对于该批处理文件的每个尚未执行的 SETLOCAL 命令，都会有一个隐含的 ENDLOCAL 被执行。 一般在脚本文件开头加上SETLOCAL，结尾加上ENDLOCAL。 Reference: ```text help set 显示、设置或删除 cmd.exe 环境变量。 SET [variable=[string]] variable 指定环境变量名。 string 指定要指派给变量的一系列字符串。 要显示当前环境变量，键入不带参数的 SET。 如果命令扩展被启用，SET 会如下改变: 可仅用一个变量激活 SET 命令，等号或值不显示所有前缀匹配 SET 命令已使用的名称的所有变量的值。例如: SET P 会显示所有以字母 P 打头的变量 如果在当前环境中找不到该变量名称，SET 命令将把 ERRORLEVEL 设置成 1。 SET 命令不允许变量名含有等号。 在 SET 命令中添加了两个新命令行开关: SET /A expression SET /P variable=[promptString] /A 命令行开关指定等号右边的字符串为被评估的数字表达式。该表达式 评估器很简单并以递减的优先权顺序支持下列操作: () - 分组 ! ~ - - 一元运算符 * / % - 算数运算符 + - - 算数运算符 < >> - 逻辑移位 & - 按位“与” ^ - 按位“异” | - 按位“或” = *= /= %= += -= - 赋值 &= ^= |= nul SETLOCAL ENABLEEXTENSIONS IF ERRORLEVEL 1 echo Unable to enable extensions 此方法之所以有效，是因为在 CMD.EXE 的旧版本上，SETLOCAL 不设置 ERRORLEVEL 值。如果参数不正确，VERIFY 命令会将 ERRORLEVEL 值初始化为非零值。 ``` ```text help endlocal 结束批处理文件中环境改动的本地化操作。在执行ENDLOCAL 之后 所做的环境改动不再仅限于批处理文件。批处理文件结束后， 原先的设置无法还原。 ENDLOCAL 如果命令扩展被启用，ENDLOCAL 会如下改变: 如果相应的 SETLOCAL 用新的 ENABLEEXTENSIONS 或 DISABLEEXTENSIONS 选项启用或停用了命令扩展，那么，在 ENDLOCAL 之后，命令扩展的启用/停用状态会还原到执行 相应的 SETLOCAL 命令前的状态。 ``` [set in MS doc](https://technet.microsoft.com/en-us/library/bb490998.aspx)]]></content>
      <categories>
        <category>windows cmd</category>
      </categories>
      <tags>
        <tag>cmd</tag>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows command(13):GOTO :label]]></title>
    <url>%2F2016%2F04%2F01%2Fwindows-cmd-13-goto%2F</url>
    <content type="text"><![CDATA[title: windows command(13):GOTO :label categories: - windows cmd tags: - cmd - goto - label comments: true layout: post date: 2016-04-01 14:20:22 modified: 2016-04-12 14:20:22 --- {% asset_img goto.png %} goto命令，跳转命令。 # 基本语法 ```bat goto label rem some cmd :label rem cmd of lable ``` 跳转到标签行，并继续执行之后的语句。标签必须以`:`开头作为标签的指示。 标签名只可以使用常量，而不能使用变量。 # 条件 if或switch/case ```bat condition using goto set /p a=choose: if "%a%" == "A" goto CaseA if "%a%" == "B" goto CaseB if "%a%" == "C" goto CaseC goto default :CaseA echo "execute A" echo a=%a% goto end :CaseB echo "execute B" goto end :CaseC echo "execute C" goto end :default echo "nothing execute" :end ``` 注意`:CaseA`之后，如果不加`goto end`则会继续执行`:CaseB`之后的语句。 # 循环 Loop ```bat loop using goto cmd @echo off set index=0 set max=5 :loop set /a index+=1 echo %index% if %index% neq %max% goto loop ``` 相当于 ```bat loop using for set init=0 set step=1 set max=5 for /L %%i in (%init%,%step%,%max%) do echo %%i ``` 不过使用goto更加灵活，理论上for能实现的循环goto都能实现。 ```bat dead loop :loop dir goto loop ``` # goto :EOF 直接跳转到文件结尾。 Reference: ```text help goto 将 cmd.exe 定向到批处理程序中带标签的行。 GOTO label label 指定批处理程序中用作标签的文字字符串。 标签必须单独一行，并且以冒号打头。 如果命令扩展被启用，GOTO 会如下改变: GOTO 命令现在接受目标标签 :EOF，这个标签将控制转移到当前 批脚本文件的结尾。不定义就退出批脚本文件，这是一个容易的 办法。有关能使该功能有用的 CALL 命令的扩展描述，请键入 CALL /?。 ```]]></content>
      <categories>
        <category>windows cmd</category>
      </categories>
      <tags>
        <tag>cmd</tag>
        <tag>goto</tag>
        <tag>label</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows command(12):FOR]]></title>
    <url>%2F2016%2F04%2F01%2Fwindows-cmd-12-for%2F</url>
    <content type="text"><![CDATA[title: windows command(12):FOR categories: - windows cmd tags: - for - cmd comments: true layout: post date: 2016-04-01 14:18:08 modified: 2016-04-05 21:18:08 --- 戴荃-悟空 FOR语句，循环控制，可以解析文件，大杀器。 # 基本语法 ``` for {%% | %}variable in (set) do command [ CommandLineOptions] ``` 其中， `%variable`或`%%variable`必须，`%variable`用来表示从命令提示符传递过来的参数，`%%variable`表示bat脚本自身的参数，参数大小写敏感。 `(set)`必须，指定一个或多个文件、文件夹、一定范围的数值、字符串，可使用通配符，括号不可少。 `command`必须，指定对`(set)`集合中每一个元素执行的命令。 `CommandLineOptions`可选，主要有`/D`-目录,`/R`-递归目录,`/L`-数值,`/F`-过滤。 # 无参数 `for %%f in (*.doc *.txt) do type %%f` 当前目录中的.doc或者.txt文件，依次代替`%%f`的位置，然后作为`type`命令的参数执行。 `for %%f in (*.txt) do @echo %%f` 效果类似于`dir /B *.txt`。 # 参数/D 目录 ``` FOR /D {%% | %}variable IN (set) DO command [command-parameters] ``` 只能匹配当前目录，不匹配任何文件，也不会匹配下一级目录。 `for %%f in (D:\*) do @echo %%f` - D盘下所有的文件 `for /D %%f in (D:\*) do @echo %%f` - D盘下所有的目录 `for /D %%i in (???) do echo %%i` - 显示当前目录下名字只有1-3个字母的目录 # 参数/R 递归目录 ``` FOR /R [[drive:]path] {%% | %}variable IN (set) DO command [command-parameters] ``` 此命令会搜索指定路径`[[drive:]path]`及所有子目录中与set相符合的所有文件，注意是指定路径及所有子目录。 * set中的文件名如果含有通配符(?或*)，则列举/R参数指定的目录及其下面的所用子目录中与set相符合的所有文件，无相符文件的目录则不列举。 * 如果set中为具体文件名，不含通配符，则枚举该目录树（即列举该目录及其下面的所有子目录）,并在每个目录后面加上具体的文件名，而不管set中的指定文件是否存在。 `for /r c:\ %%i in (*.exe) do echo %%i` - 把C盘根目录,和每个目录的子目录下面全部的EXE文件都列出来了 `for /r c:\ %%i in (boot.ini) do echo %%i` - 枚举了c盘所有目录,并在目录后面加上boot.ini,不管是否存在该文件 `for /r c:\ %%i in (boot.ini) do if exist %%i echo %%i` - 很好的搜索命令，列举boot.ini存在的目录 # 参数/L 数列 ``` FOR /L {%% | %}ariable IN (start#,step#,end#) DO command [command-parameters] ``` 该集表示以增量形式从开始到结束的一个数字序列。因此，(1,1,5)将产生序列1 2 3 4 5，(5,-1,1)将产生序列(5 4 3 2 1). `for /l %%i in (1,2,10) do @echo %%i` - 输出1 3 5 7 9 `for /l %%i in (100,-20,1) do @echo %%i` - 输出100,80,60,40,20 `for /l %%i in (1,1,5) do start cmd` - 打开5个CMD窗口 `for /l %%i in (1,1,5) do md %%i` - 建立从1~5共5个文件夹 `for /l %%i in (1,1,5) do rd /q %%i` - 删除从1~5共5个文件夹 # 参数/F 迭代文件解析 Use file parsing to process command output, strings and file content. Use iterative variables to define the content or strings you want to examine and use the various ParsingKeywords options to further modify the parsing. Use the ParsingKeywords token option to specify which tokens should be passed as iterator variables. Note that when used without the token option, /F will only examine the first token. File parsing consists of reading the output, string or file content, `breaking it up into individual lines of text and then parsing each line into zero or more tokens`. The for loop is then called with the iterator variable value set to the token. By default, /F passes the first blank separated token from each line of each file. Blank lines are skipped. The different syntaxes are: ``` for /F ["ParsingKeywords"] {%% | %}variable in (filenameset) do command [CommandLineOptions] for /F ["ParsingKeywords"] {%% | %}variable in ("LiteralString") do command [CommandLineOptions] for /F ["ParsingKeywords"] {%% | %}variable in ('command') do command [CommandLineOptions] ``` The filenameset argument specifies one or more file names. Each file is opened, read and processed before going on to the next file in filenameset. To override the default parsing behavior, specify "ParsingKeywords". This is a quoted string that contains one or more keywords to specify different parsing options. If you use the usebackq option, use one of the following syntaxes: ``` for /F ["usebackqParsingKeywords"] {%% | %}variable in ("filenameset") do command [CommandLineOptions] for /F ["usebackqParsingKeywords"] {%% | %}variable in ('LiteralString') do command [CommandLineOptions] for /F ["usebackqParsingKeywords"] {%% | %}variable in (`command`) do command [CommandLineOptions] ``` when using `usebackq` option, be careful about the difference: `filenameset` -> `"filenameset"` `"LiteralString"` -> `'LiteralString'` `'command'` -> \`command\` The following table lists the parsing keywords that you can use for ParsingKeywords. eol=c - 指一个行注释字符的结尾(就一个) skip=n - 指在文件开始时忽略的行数。 delims=xxx - 指分隔符集。这个替换了空格和制表符的默认分隔符集。 tokens=x,y,m-n - 指每行的哪一个符号被传递到每个迭代的 for 本身。这会导致额外变量名称的分配。m-n 格式为一个范围。通过 nth 符号指定 mth。如果符号字符串中的最后一个字符星号，那么额外的变量将在最后一个符号解析之后 分配并接受行的保留文本。 usebackq - 指定新语法已在下类情况中使用: 在作为命令执行一个后引号的字符串并且一个单引号字符为文字字符串命令并允许在 file-set 中使用双引号扩起文件名称。 如`eol=;`表示忽略`;`开头的行； `skip=1`表示忽略第一行； `delims=, `表示用`,`或` `对字符串分隔； `tokens=2,3*`将每行中的第二个和第三个符号传递给 for 程序体 ```bat %k takes the left content of string for /F "eol=; tokens=2,3* delims=, " %%i in ("A1,A2,A3,A4,A5") do echo %%i %%j %%k A2 A3 A4,A5 ``` ```bat command FOR /F "tokens=1* delims==" %%i IN ('set') DO @echo [%%i----%%j] [OS----Windows_NT] ``` ```bat command with substitude for /F "usebackq delims==" %%x in (`dir /b`) do @echo %%~fx ``` Reference: ```text help FOR 对一组文件中的每一个文件执行某个特定命令。 FOR %variable IN (set) DO command [command-parameters] %variable 指定一个单一字母可替换的参数。 (set) 指定一个或一组文件。可以使用通配符。 command 指定对每个文件执行的命令。 command-parameters 为特定命令指定参数或命令行开关。 在批处理程序中使用 FOR 命令时，指定变量请使用 %%variable 而不要用 %variable。变量名称是区分大小写的，所以 %i 不同于 %I. 如果启用命令扩展，则会支持下列 FOR 命令的其他格式: FOR /D %variable IN (set) DO command [command-parameters] 如果集中包含通配符，则指定与目录名匹配，而不与文件名匹配。 FOR /R [[drive:]path] %variable IN (set) DO command [command-parameters] 检查以 [drive:]path 为根的目录树，指向每个目录中的 FOR 语句。 如果在 /R 后没有指定目录规范，则使用当前目录。如果集仅为一个单点(.)字符， 则枚举该目录树。 FOR /L %variable IN (start,step,end) DO command [command-parameters] 该集表示以增量形式从开始到结束的一个数字序列。因此，(1,1,5)将产生序列 1 2 3 4 5，(5,-1,1)将产生序列(5 4 3 2 1) FOR /F ["options"] %variable IN (file-set) DO command [command-parameters] FOR /F ["options"] %variable IN ("string") DO command [command-parameters] FOR /F ["options"] %variable IN ('command') DO command [command-parameters] 或者，如果有 usebackq 选项: FOR /F ["usebackqoptions"] %variable IN ("file-set") DO command [command-parameters] FOR /F ["usebackqoptions"] %variable IN ('string') DO command [command-parameters] FOR /F ["usebackqoptions"] %variable IN (`command`) DO command [command-parameters] fileset 为一个或多个文件名。继续到 fileset 中的下一个文件之前， 每份文件都被打开、读取并经过处理。处理包括读取文件，将其分成一行行的文字， 然后将每行解析成零或更多的符号。然后用已找到的符号字符串变量值调用 For 循环 。 以默认方式，/F 通过每个文件的每一行中分开的第一个空白符号。跳过空白行。 你可通过指定可选 "options" 参数替代默认解析操作。这个带引号的字符串包括一个 或多个指定不同解析选项的关键字。这些关键字为: eol=c - 指一个行注释字符的结尾(就一个) skip=n - 指在文件开始时忽略的行数。 delims=xxx - 指分隔符集。这个替换了空格和制表符的 默认分隔符集。 tokens=x,y,m-n - 指每行的哪一个符号被传递到每个迭代 的 for 本身。这会导致额外变量名称的分配。m-n 格式为一个范围。通过 nth 符号指定 mth。如果 符号字符串中的最后一个字符星号， 那么额外的变量将在最后一个符号解析之后 分配并接受行的保留文本。 usebackq - 指定新语法已在下类情况中使用: 在作为命令执行一个后引号的字符串并且一个单 引号字符为文字字符串命令并允许在 file-set 中使用双引号扩起文件名称。 某些范例可能有助: FOR /F "eol=; tokens=2,3* delims=, " %i in (myfile.txt) do @echo %i %j %k 会分析 myfile.txt 中的每一行，忽略以分号打头的那些行，将 每行中的第二个和第三个符号传递给 for 函数体，用逗号和/或 空格分隔符号。请注意，此 for 函数体的语句引用 %i 来 获得第二个符号，引用 %j 来获得第三个符号，引用 %k 来获得第三个符号后的所有剩余符号。对于带有空格的文件 名，你需要用双引号将文件名括起来。为了用这种方式来使 用双引号，还需要使用 usebackq 选项，否则，双引号会 被理解成是用作定义某个要分析的字符串的。 %i 在 for 语句中显式声明，%j 和 %k 是通过 tokens= 选项隐式声明的。可以通过 tokens= 一行 指定最多 26 个符号，只要不试图声明一个高于字母 "z" 或 "Z" 的变量。请记住，FOR 变量是单一字母、分大小写和全局的变量； 而且，不能同时使用超过 52 个。 还可以在相邻字符串上使用 FOR /F 分析逻辑，方法是， 用单引号将括号之间的 file-set 括起来。这样，该字符 串会被当作一个文件中的一个单一输入行进行解析。 最后，可以用 FOR /F 命令来分析命令的输出。方法是，将 括号之间的 file-set 变成一个反括字符串。该字符串会 被当作命令行，传递到一个子 CMD.EXE，其输出会被捕获到 内存中，并被当作文件分析。如以下例子所示: FOR /F "usebackq delims==" %i IN (`set`) DO @echo %i 会枚举当前环境中的环境变量名称。 另外，FOR 变量参照的替换已被增强。你现在可以使用下列 选项语法: %~I - 删除任何引号(")，扩展 %I %~fI - 将 %I 扩展到一个完全合格的路径名 %~dI - 仅将 %I 扩展到一个驱动器号 %~pI - 仅将 %I 扩展到一个路径 %~nI - 仅将 %I 扩展到一个文件名 %~xI - 仅将 %I 扩展到一个文件扩展名 %~sI - 扩展的路径只含有短名 %~aI - 将 %I 扩展到文件的文件属性 %~tI - 将 %I 扩展到文件的日期/时间 %~zI - 将 %I 扩展到文件的大小 %~$PATH:I - 查找列在路径环境变量的目录，并将 %I 扩展 到找到的第一个完全合格的名称。如果环境变量名 未被定义，或者没有找到文件，此组合键会扩展到 空字符串 可以组合修饰符来得到多重结果: %~dpI - 仅将 %I 扩展到一个驱动器号和路径 %~nxI - 仅将 %I 扩展到一个文件名和扩展名 %~fsI - 仅将 %I 扩展到一个带有短名的完整路径名 %~dp$PATH:I - 搜索列在路径环境变量的目录，并将 %I 扩展 到找到的第一个驱动器号和路径。 %~ftzaI - 将 %I 扩展到类似输出线路的 DIR 在以上例子中，%I 和 PATH 可用其他有效数值代替。%~ 语法 用一个有效的 FOR 变量名终止。选取类似 %I 的大写变量名 比较易读，而且避免与不分大小写的组合键混淆。 ``` [for in MS doc](https://technet.microsoft.com/en-us/library/bb490909.aspx) [CMD批处理循环，太强大了](http://blog.csdn.net/xhhjin/article/details/7373524)]]></content>
      <categories>
        <category>windows cmd</category>
      </categories>
      <tags>
        <tag>cmd</tag>
        <tag>for</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows command(11):IF ELSE]]></title>
    <url>%2F2016%2F04%2F01%2Fwindows-cmd-11-if-else%2F</url>
    <content type="text"><![CDATA[title: windows command(11):IF ELSE categories: - windows cmd tags: - if - cmd comments: true layout: post date: 2016-04-01 14:15:54 modified: 2016-04-12 14:15:54 --- IF条件控制，脚本中控制流常用。 # 基本语法 ```bat w/o else if condition command ``` ```bat w/ else if condition (command) else (command) ``` 注意:`else与(之间必须要有空格`。 examples: ```bat if exist for1.bat echo for1.bat exist if exist for1.bat (echo for1.bat exist)else (echo for1.bat not exist) ``` # 字符串比较 `if hello == hello (echo euqal) else (echo not equal)` # 数字比较 `if 1 equ 2 (echo euqal) else (echo not equal)` # 文件或者目录是否存在 `if exist hi.txt echo hi.txt exist` # 变量是否已定义 `if defined x (echo defined) else (echo not defined)` # 上个命令的返回值 `if %errorlevel% equ 0 (echo OK) else (echo NOK)` Reference: ```text help IF 执行批处理程序中的条件处理。 IF [NOT] ERRORLEVEL number command IF [NOT] string1==string2 command IF [NOT] EXIST filename command NOT 指定只有条件为 false 的情况下，Windows 才 应该执行该命令。 ERRORLEVEL number 如果最后运行的程序返回一个等于或大于 指定数字的退出代码，指定条件为 true。 string1==string2 如果指定的文字字符串匹配，指定条件为 true。 EXIST filename 如果指定的文件名存在，指定条件为 true。 command 如果符合条件，指定要执行的命令。如果指定的 条件为 FALSE，命令后可跟 ELSE 命令，该命令将 在 ELSE 关键字之后执行该命令。 ELSE 子句必须出现在同一行上的 IF 之后。例如: IF EXIST filename. ( del filename. ) ELSE ( echo filename. missing. ) 由于 del 命令需要用新的一行终止，因此以下子句不会有效: IF EXIST filename. del filename. ELSE echo filename. missing 由于 ELSE 命令必须与 IF 命令的尾端在同一行上，以下子句也 不会有效: IF EXIST filename. del filename. ELSE echo filename. missing 如果都放在同一行上，以下子句有效: IF EXIST filename. (del filename.) ELSE echo filename. missing 如果命令扩展被启用，IF 会如下改变: IF [/I] string1 compare-op string2 command IF CMDEXTVERSION number command IF DEFINED variable command 其中， compare-op 可以是: EQU - 等于 NEQ - 不等于 LSS - 小于 LEQ - 小于或等于 GTR - 大于 GEQ - 大于或等于 而 /I 开关(如果指定)说明要进行的字符串比较不分大小写。 /I 开关可以用于 IF 的 string1==string2 的形式上。这些 比较都是通用的；原因是，如果 string1 和 string2 都是 由数字组成的，字符串会被转换成数字，进行数字比较。 CMDEXTVERSION 条件的作用跟 ERRORLEVEL 的一样，除了它 是在跟与命令扩展有关联的内部版本号比较。第一个版本 是 1。每次对命令扩展有相当大的增强时，版本号会增加一个。 命令扩展被停用时，CMDEXTVERSION 条件不是真的。 如果已定义环境变量，DEFINED 条件的作用跟 EXIST 的一样， 除了它取得一个环境变量，返回的结果是 true。 如果没有名为 ERRORLEVEL 的环境变量，%ERRORLEVEL% 会扩充为 ERROLEVEL 当前数值的字符串表达式；否则，你会得到 其数值。运行程序后，以下语句说明 ERRORLEVEL 的用法: goto answer%ERRORLEVEL% :answer0 echo Program had return code 0 :answer1 echo Program had return code 1 你也可以使用以上的数字比较: IF %ERRORLEVEL% LEQ 1 goto okay 如果没有名为 CMDCMDLINE 的环境变量，%CMDCMDLINE% 将在 CMD.EXE 进行任何处理前扩充为传递给 CMD.EXE 的原始 命令行；否则，你会得到其数值。 如果没有名为 CMDEXTVERSION 的环境变量， %CMDEXTVERSION% 会扩充为 CMDEXTVERSION 当前数值的 字串符表达式；否则，你会得到其数值。 ```]]></content>
      <categories>
        <category>windows cmd</category>
      </categories>
      <tags>
        <tag>cmd</tag>
        <tag>if</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows command(10):SORT]]></title>
    <url>%2F2016%2F04%2F01%2Fwindows-cmd-10-sort%2F</url>
    <content type="text"><![CDATA[title: windows command(10):SORT categories: - windows cmd tags: - sort - cmd comments: true layout: post date: 2016-04-01 14:10:59 modified: 2016-04-12 14:10:59 --- SORT 排序命令。 # 对文件内容排序 `sort filename` 排序顺序为0-9,A-Z,字母为小写在前。 # 逆向排序 `sort /r filename` 排序顺序为Z-A，9-0,字母也是小写在前。 # 命令结果排序 `findstr /s /i hello *.*|sort` # 键盘输入排序 1. `sort`不带参数 2. 输入字符串 3. Ctrl+Z结束输入 ```text help SORT SORT [/R] [/+n] [/M kilobytes] [/L locale] [/REC recordbytes] [[drive1:][path1]filename1] [/T [drive2:][path2]] [/O [drive3:][path3]filename3] /+n 指定开始每个比较的字符号码 n。/+3 说明每个 比较应从每行的第三个字符开始。少于 n 个字符 的行排在其他行之前。按默认值，从每行的第一 个字符开始比较。 /L[OCALE] locale 用指定的区域设置替代系统默认区域设置。 ""C"" 区域设置产生最快的排序顺序并且是当前 的唯一其他选择。排序总是不分大小写的。 /M[EMORY] kilobytes 指定用于排序的主内存量，单位为 KB。 最小内存量总是 160 KB。如果指定内存大小， 无论主内存的可用量是多少，指定的内存量会 全部用于排序。 要取得最佳性能，通常不指定内存大小。按默认 值，如果达到默认最大内存值，排序会一次完成 (非临时文件)；否则，排序会分两次完成(没有 完全排序的数据存储在临时文件中)；用于排序 和合并的内存量相等。如果输入和输出都是文 件，默认最大内存量为可用主内存的 90%; 否则，为主内存的 45%。 /REC[ORD_MAXIMUM] characters 指定记录中的最大字符数量 (默认值为 4096，最大值为 65535)。 /R[EVERSE] 颠倒排列顺序，即，从 Z 到 A，再从 9 到 0。 [drive1:][path1]filename1 指定要排序的文件。如果没有指定，则排序标准 输入。指定输入文件比将同一个文件重定向为标 准输入快。 /T[EMPORARY] [drive2:][path2] 指定保留排序工作存储的目录路径，以防主内 存无法容纳数据。默认值是使用系统临时目录。 /O[UTPUT] [drive3:][path3]filename3 指定在哪个文件中储存经过排序的输入。 如果没有指定，数据会被写入标准输出。指定 输出文件比将标准输出重定向到同一个文件快。 ```]]></content>
      <categories>
        <category>windows cmd</category>
      </categories>
      <tags>
        <tag>cmd</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows command(9):FIND FINDSTR]]></title>
    <url>%2F2016%2F03%2F30%2Fwindows-cmd-9-find-findstr%2F</url>
    <content type="text"><![CDATA[title: windows command(9):FIND FINDSTR categories: - windows cmd tags: - find - cmd comments: true layout: post date: 2016-03-30 20:06:28 modified: 2016-06-28 20:06:28 --- FIND和FINDSTR都是用来查找文件中的字符串的命令。FINDSTR支持通配符，是FIND的加强版本。 # 查找字符串 用空格隔开待查找的字符串`"str1 str2"`，在find中表示查找`str1 str1`整个字符串，比较符合直觉， 而在findstr中表示查找`str`或`str2`。findstr的待查字符串写成`/C:"str1 str2"`表示查找整个字符串. ```bat find D:\test\test>find "hello there" hi.txt ---------- HI.TXT hello there ``` ```bat findstr D:\test\test>findstr "hello there" hi.txt hello h"hello"h hello there D:\test\test>findstr /C:"hello there" hi.txt hello there ``` # 查找的字符串中有`"` 在要查找的字符串里`""`转义成一个`"`. ```bat find D:\test\test>find /N "h""hello""h" hi.txt ---------- HI.TXT [6]h"hello"h ``` ```bat findstr D:\test\test>findstr /N """hello""" hi.txt 6:h"hello"h ``` # 多文件查找 当前文件夹和所有子目录查找所有含有`Windows`的文件，忽略大小写。 ``` findstr /s /i Windows *.* ``` ```bat search the current directory for files that have the extension .bat and that contain the string "PROMPT," type for %%f in (*.bat) do find "PROMPT" %%f ``` # 查找目录 用管道。 ``` D:\test>dir /b /s |find /i "HI" D:\test\hi.txt ``` # 显示文件内容并添加行号 type命令只能显示文件内容，在不使用for语句的条件下，简洁地实现打印行号的功能。 ```bat display line number find /V /N "" filename findstr /V /N "\n" hi.txt ``` # 通配符查找 查找包含以任意个空格后是字符串`FOR`的字符串，打印行号(/n), ```bat findstr /b /n /c:" *FOR" *.bas ``` # 待查字符串从文件中读取 ```bat findstr /g:finddata.txt /f:filelist.txt > results.out ``` Reference: ```text help FIND 在文件中搜索字符串。 FIND [/V] [/C] [/N] [/I] [/OFF[LINE]] "string" [[drive:][path]filename[ ...]] /V 显示所有未包含指定字符串的行。 /C 仅显示包含字符串的行数。 /N 显示行号。 /I 搜索字符串时忽略大小写。 /OFF[LINE] 不要跳过具有脱机属性集的文件。 "string" 指定要搜索的文本字符串。 [drive:][path]filename 指定要搜索的文件。 如果没有指定路径，FIND 将搜索在提示符处键入 的文本或者由另一命令产生的文本。 ``` ```text help FINDSTR 在文件中寻找字符串。 FINDSTR [/B] [/E] [/L] [/R] [/S] [/I] [/X] [/V] [/N] [/M] [/O] [/P] [/F:file] [/C:string] [/G:file] [/D:dir list] [/A:color attributes] [/OFF[LINE]] strings [[drive:][path]filename[ ...]] /B 在一行的开始配对模式。 /E 在一行的结尾配对模式。 /L 按字使用搜索字符串。 /R 将搜索字符串作为一般表达式使用。 /S 在当前目录和所有子目录中搜索匹配文件。 /I 指定搜索不分大小写。 /X 打印完全匹配的行。 /V 只打印不包含匹配的行。 /N 在匹配的每行前打印行数。 /M 如果文件含有匹配项，只打印其文件名。 /O 在每个匹配行前打印字符偏移量。 /P 忽略有不可打印字符的文件。 /OFF[LINE] 不跳过带有脱机属性集的文件。 /A:attr 指定有十六进位数字的颜色属性。请见 "color /?" /F:file 从指定文件读文件列表 (/ 代表控制台)。 /C:string 使用指定字符串作为文字搜索字符串。 /G:file 从指定的文件获得搜索字符串。 (/ 代表控制台)。 /D:dir 查找以分号为分隔符的目录列表 strings 要查找的文字。 [drive:][path]filename 指定要查找的文件。 除非参数有 /C 前缀，请使用空格隔开搜索字符串。 例如: 'FINDSTR "hello there" x.y' 在文件 x.y 中寻找 "hello" 或 "there"。'FINDSTR /C:"hello there" x.y' 文件 x.y 寻找 "hello there"。 一般表达式的快速参考: . 通配符: 任何字符 * 重复: 以前字符或类出现零或零以上次数 ^ 行位置: 行的开始 $ 行位置: 行的终点 [class] 字符类: 任何在字符集中的字符 [^class] 补字符类: 任何不在字符集中的字符 [x-y] 范围: 在指定范围内的任何字符 \x Escape: 元字符 x 的文字用法 \ 字位置: 字的结束 ``` [find in M$ website](https://technet.microsoft.com/en-us/library/bb490906.aspx) [findstr in M$ website](https://technet.microsoft.com/en-us/library/bb490907.aspx)]]></content>
      <categories>
        <category>windows cmd</category>
      </categories>
      <tags>
        <tag>cmd</tag>
        <tag>find</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows command(8):MOVE]]></title>
    <url>%2F2016%2F03%2F30%2Fwindows-cmd-8-move%2F</url>
    <content type="text"><![CDATA[title: windows command(8):MOVE categories: - windows cmd tags: - move - cmd comments: true layout: post date: 2016-03-30 19:50:41 modified: 2016-03-30 19:50:41 --- MOVE命令除了用来移动文件，还可以用来重命名文件或目录。 # 批量移动文件 移动所有的xls文件 ```bat move \data\*.xls \second_q\reports\ ``` # 重命名文件 ```bat move src_dir dest_dir ``` # 重命名文件 ```bat move file1 file2 ``` Reference: ```text help MOVE 移动文件并重命名文件和目录。 要移动至少一个文件: MOVE [/Y | /-Y] [drive:][path]filename1[,...] destination 要重命名一个目录: MOVE [/Y | /-Y] [drive:][path]dirname1 dirname2 [drive:][path]filename1 指定你想移动的文件位置和名称。 destination 指定文件的新位置。目标可包含一个驱动器号 和冒号、一个目录名或组合。如果只移动一个文件 并在移动时将其重命名，你还可以包括文件名。 [drive:][path]dirname1 指定要重命名的目录。 dirname2 指定目录的新名称。 /Y 取消确认覆盖一个现有目标文件的提示。 /-Y 对确认覆盖一个现有目标文件发出提示。 命令行开关 /Y 可以出现在 COPYCMD 环境变量中。这可以用命令行上 的 /-Y 替代。默认值是，除非 MOVE 命令是从一个批脚本内 执行的，覆盖时都发出提示。 ``` [Move in M$ website](https://technet.microsoft.com/en-us/library/bb490935.aspx)]]></content>
      <categories>
        <category>windows cmd</category>
      </categories>
      <tags>
        <tag>cmd</tag>
        <tag>move</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows command(7):RENAME REPLACE]]></title>
    <url>%2F2016%2F03%2F28%2Fwindows-cmd-7-ren-replace%2F</url>
    <content type="text"><![CDATA[title: windows command(7):RENAME REPLACE categories: - windows cmd tags: - rename - replace - cmd comments: true layout: post date: 2016-03-28 22:30:38 modified: 2016-03-28 22:30:38 --- GALA - 追梦赤子心 rename(ren)重命名，可以给文件修改名字或者文件格式后缀名。 # 单个文件重命名 ren filename1 filename2 ```bat single file rename ren 1.jpg hello.png ``` # 多个文件重命名 ren filenames1 filenames2 可以使用`*`或者`?`作为通配符，如果通配符在filenames2中，则通配符代表的字符是通配符所匹配的filenames1中的字符。 ```bat multiple files rename ren *.jpg *.rar ``` 将所有的jpg文件改为rar格式，保持文件名不变。 # 替换文件 replace path\to\filename dest\path 替换文件为同名替换，不能修改名字 Reference: ```text help RENAME 重命名文件。 RENAME [drive:][path]filename1 filename2. REN [drive:][path]filename1 filename2. 请注意，你不能为目标文件指定新的驱动器或路径。 ``` ```text help REPLACE 替换文件。 REPLACE [drive1:][path1]filename [drive2:][path2] [/A] [/P] [/R] [/W] REPLACE [drive1:][path1]filename [drive2:][path2] [/P] [/R] [/S] [/W] [/U] [drive1:][path1]filename 指定源文件。 [drive2:][path2] 指定要替换文件的目录。 /A 把新文件加入目标目录。不能和/S 或 /U 命令行开关搭配使用。 /P 替换文件或加入源文件之前会先提示你进行确认。 /R 替换只读文件以及未受保护的文件。 /S 替换目标目录中所有子目录的文件。不能与 /A 命令开关搭 配使用。 /W 等你插入磁盘以后再运行。 /U 只会替换或更新比源文件日期早的文件。不能与 /A 命令行 开关搭配使用。 ```]]></content>
      <categories>
        <category>windows cmd</category>
      </categories>
      <tags>
        <tag>cmd</tag>
        <tag>rename</tag>
        <tag>replace</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据隐藏:jpeg+RAR]]></title>
    <url>%2F2016%2F03%2F28%2Fjpeg-rar%2F</url>
    <content type="text"><![CDATA[title: 数据隐藏:jpeg+RAR categories: - windows cmd tags: - data hiding - data encrypt comments: true layout: post date: 2016-03-28 21:55:44 modified: 2016-03-28 21:55:44 --- {% asset_img girl-running.png %} 这是一种简单的数据隐藏方法，将rar文件隐藏在图片文件里。 # 用法 ```bat copy /B 1.jpg+2.rar hidden_rar.jpg ``` 或者 ```bat type 1.jpg >> hidden_rar.jpg type 2.rar >> hidden_rar.jpg ``` 默认打开hidden_rar.jpg可以看到图片内容，重命名为hidden_rar.rar并用winRAR打开可以解压缩。 题图的图片就隐藏有一个rar文件。 # 为什么可行 1. jpg图片后面跟上无效数据，不会影响软件解析图片。 2. rar解析软件，确切的说是winRAR软件解析rar格式文件的时候是搜索到正确的文件头，并解析之后的文件内容。 # 延伸 对其他图片png/gif/bmp/jpeg格式也是可行的。 其实如果解析软件能够做到只解析自己关心的数据，那么所谓的信息隐藏可以变成任意文件格式的叠加。]]></content>
      <categories>
        <category>windows cmd</category>
      </categories>
      <tags>
        <tag>data hiding</tag>
        <tag>data encrypt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows command(6):ATTRIB]]></title>
    <url>%2F2016%2F03%2F26%2Fwindows-cmd-6-attrib%2F</url>
    <content type="text"><![CDATA[title: windows command(6):ATTRIB categories: - windows cmd tags: - attrib - cmd comments: true layout: post date: 2016-03-26 23:53:14 modified: 2016-03-26 23:53:14 --- {% asset_img attrib_win10.png %} ATTRIB用来显示或修改文件或者文件夹属性。 # Windows的文件属性 Windows OS文件夹或者文件属性主要有： * 只读(Read Only)-表示该文件不能被修改 * 隐藏(Hidden) -表示该文件在系统中是隐藏的，在默认情况下用户不能看见这些文件。 * 系统(System) - 表示该文件是操作系统的一部分。 * 存档(Archive)- 表示该文件在上次备份前已经修改过了，一些备份软件在备份系统后会把这些文件默认的设为存档属性。 存档属性在一般文件管理中意义不大，但是对于频繁的文件批量管理很有帮助。 # 显示属性 attrib filename ```bat show attrib D:\test>attrib .hello SHR D:\test\.hello ``` # 增加属性 attrib +[R|A|S|H|I] filename ```bat add attrib D:\test>attrib test D:\test\test D:\test>attrib +R test D:\test>attrib test R D:\test\test ``` # 去除属性 attrib -[R|A|S|H|I] filename ```bat 恢复被病毒隐藏的文件 attrib -r -s -h /s /d ``` Reference: ```text help ATTRIB 显示或更改文件属性。 ATTRIB [+R | -R] [+A | -A ] [+S | -S] [+H | -H] [+I | -I] [drive:][path][filename] [/S [/D] [/L]] + 设置属性。 - 清除属性。 R 只读文件属性。 A 存档文件属性。 S 系统文件属性。 H 隐藏文件属性。 I 无内容索引文件属性。 X 无清理文件属性。 V 完整性属性。 [drive:][path][filename] 指定 attrib 要处理的文件。 /S 处理当前文件夹 及其所有子文件夹中的匹配文件。 /D 也处理文件夹。 /L 处理符号链接和 符号链接目标的属性 ```]]></content>
      <categories>
        <category>windows cmd</category>
      </categories>
      <tags>
        <tag>cmd</tag>
        <tag>attrib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows command(5):TYPE]]></title>
    <url>%2F2016%2F03%2F25%2Fwindows-cmd-5-type%2F</url>
    <content type="text"><![CDATA[title: windows command(5):TYPE categories: - windows cmd tags: - type - cmd comments: true layout: post date: 2016-03-25 23:52:00 modified: 2016-03-25 23:52:00 --- TYPE命令用于显示文件内容，相当于bash的cat命令。 # 显示文件内容 TYPE filename ```bat display file content D:\test>type hello.txt hello this is a test file. ``` # 合并文件 ## 直接合并 TYPE file1 file2 > mergefile ```bat merge files D:\test>type a.txt i am a D:\test>type hello.txt hello this is a test file. D:\test>type a.txt hello.txt >new.txt a.txt hello.txt D:\test>type new.txt i am a hello this is a test file. ``` ## 多次合并 type file >> mergefile ```bat merge files type fileA.jpg >> file.jpg type fileB.rar >> file.jpg ``` Refrenece: ```text help 显示文本文件的内容。 TYPE [drive:][path]filename ```]]></content>
      <categories>
        <category>windows cmd</category>
      </categories>
      <tags>
        <tag>cmd</tag>
        <tag>type</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows command(4):ECHO]]></title>
    <url>%2F2016%2F03%2F23%2Fwindows-cmd-4-echo%2F</url>
    <content type="text"><![CDATA[title: windows command(4):ECHO categories: - windows cmd tags: - echo - cmd comments: true layout: post date: 2016-03-23 23:50:56 modified: 2016-03-25 23:50:56 --- {% asset_img echo.png %} ECHO命令是最常用的命令之一，用来回显命令到屏幕。 # ECHO [ON|OFF] 打开或关闭命令的回显,不加参数则显示当前的ECHO状态。 ```bat C:\Users\idea>echo ECHO 处于打开状态。 C:\Users\idea>echo off cd C:\Users\idea echo hello hello echo on C:\Users\idea> ``` # ECHO [message] ```bat output string "quote is not necessary" C:\Users\idea>echo hello world hello world ``` ```bat output a newline echo. ``` echo与`.`之间没有空格，`.`可以由`, : / \ + ='代替。 ```bat variable echo %path% echo %date% ``` # @ @字符放在命令前将关闭该命令回显，无论此时echo是否为打开状态。 在脚本中，如果`echo off`这条命令本身也不回显，在语句之前加`@`，写成`@echo off`. # create a new file or append a file ECHO [new content] > filename ECHO [append content] >> filename ```bat file edit D:\test>echo @echo off > batfile.bat D:\test>echo echo hello world >>batfile.bat D:\test>type batfile.bat @echo off echo hello world ``` # auto answer qustions in cmd ECHO [Y|N]| cmd ```bat D:\test>rd test /S test, 是否确认(Y/N)? D:\test>echo Y|rd test /S test, 是否确认(Y/N)? Y ``` # buzzer ring ``` echo ^G ``` `^G`是键盘输入`Ctrl`+`G`或者`Alt`+007。 Reference: ```text help ECHO 显示信息，或启用或关闭命令回显。 ECHO [ON | OFF] ECHO [message] 要显示当前回显设置，键入不带参数的 ECHO。 ``` [你不知道的CMD命令之Echo](https://www.douban.com/note/311537668/)]]></content>
      <categories>
        <category>windows cmd</category>
      </categories>
      <tags>
        <tag>cmd</tag>
        <tag>echo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows command(3):DIR MD RD CD]]></title>
    <url>%2F2016%2F03%2F15%2Fwindows-cmd-3-dir-mkdir-rmdir-chdir%2F</url>
    <content type="text"><![CDATA[title: windows command(3):DIR MD RD CD categories: - windows cmd tags: - dir - cmd comments: true layout: post date: 2016-03-15 23:47:01 modified: 2016-03-17 23:47:01 --- {% asset_img dir.png %} DIR相当于bash里的ls，列出目录或文件。 MKDIR(MD)创建目录。 RMDIR(RD)删除目录。 CHDIR(CD)显示当前目录名(CD不跟参数时，兼有bash pwd命令功能)或者改变当前目录。 # DIR ```bat list all non-dir files dir /A:-D ``` ```bat order by reverse alphabet dir /O:-N ``` ```bat order by date(latest at first) dir /O:-D ``` ```bat list all txt files in current dir dir *.txt ``` ```bat clean style dir /B ``` # MKDIR(MD) ```bat create dir A and the sub-dir B mkdir A\B ``` # RMDIR(RD) ```bat remove all sub-dir and files rmdir A /S /Q ``` # CHDIR(CD) ```bat show current dir D:\TOOLS\FreeMind\browser>cd D:\TOOLS\FreeMind\browser ``` ```bat go to upper level dir cd .. ``` CHDIR 命令不把空格当作分隔符，因此有可能将目录名改为一个 带有空格但不带有引号的子目录名。例如: ``` cd \winnt\profiles\username\programs\start menu ``` 与下列相同: ``` cd "\winnt\profiles\username\programs\start menu" ``` Reference: ```text help DIR 显示目录中的文件和子目录列表。 DIR [drive:][path][filename] [/A[[:]attributes]] [/B] [/C] [/D] [/L] [/N] [/O[[:]sortorder]] [/P] [/Q] [/R] [/S] [/T[[:]timefield]] [/W] [/X] [/4] [drive:][path][filename] 指定要列出的驱动器、目录和/或文件。 /A 显示具有指定属性的文件。 属性 D 目录 R 只读文件 H 隐藏文件 A 准备存档的文件 S 系统文件 I 无内容索引文件 L 解析点 - 表示“否”的前缀 /B 使用空格式(没有标题信息或摘要)。 /C 在文件大小中显示千位数分隔符。这是默认值。用 /-C 来 禁用分隔符显示。 /D 跟宽式相同，但文件是按栏分类列出的。 /L 用小写。 /N 新的长列表格式，其中文件名在最右边。 /O 用分类顺序列出文件。 排列顺序 N 按名称(字母顺序) S 按大小(从小到大) E 按扩展名(字母顺序) D 按日期/时间(从先到后) G 组目录优先 - 反转顺序的前缀 /P 在每个信息屏幕后暂停。 /Q 显示文件所有者。 /R 显示文件的备用数据流。 /S 显示指定目录和所有子目录中的文件。 /T 控制显示或用来分类的时间字符域。 时间段 C 创建时间 A 上次访问时间 W 上次写入的时间 /W 用宽列表格式。 /X 显示为非 8.3 文件名产生的短名称。格式是 /N 的格式， 短名称插在长名称前面。如果没有短名称，在其位置则 显示空白。 /4 用四位数字显示年 可以在 DIRCMD 环境变量中预先设定开关。通过添加前缀 - (破折号) 来替代预先设定的开关。例如，/-W。 ``` ```text help MKDIR 创建目录。 MKDIR [drive:]path MD [drive:]path 如果命令扩展被启用，MKDIR 会如下改变: 如果需要，MKDIR 会在路径中创建中级目录。例如: 假设 \a 不 存在，那么: mkdir \a\b\c\d 与: mkdir \a chdir \a mkdir b chdir b mkdir c chdir c mkdir d 相同。如果扩展被停用，则需要键入 mkdir \a\b\c\d。 ``` ```text help RMDIR 删除一个目录。 RMDIR [/S] [/Q] [drive:]path RD [/S] [/Q] [drive:]path /S 除目录本身外，还将删除指定目录下的所有子目录和 文件。用于删除目录树。 /Q 安静模式，带 /S 删除目录树时不要求确认 ``` ```text help CHDIR 显示当前目录名或改变当前目录。 CHDIR [/D] [drive:][path] CHDIR [..] CD [/D] [drive:][path] CD [..] .. 指定要改成父目录。 键入 CD drive: 显示指定驱动器中的当前目录。 不带参数只键入 CD，则显示当前驱动器和目录。 使用 /D 开关，除了改变驱动器的当前目录之外， 还可改变当前驱动器。 如果命令扩展被启用，CHDIR 会如下改变: 当前的目录字符串会被转换成使用磁盘名上的大小写。所以， 如果磁盘上的大小写如此，CD C:\TEMP 会将当前目录设为 C:\Temp。 CHDIR 命令不把空格当作分隔符，因此有可能将目录名改为一个 带有空格但不带有引号的子目录名。例如: cd \winnt\profiles\username\programs\start menu 与下列相同: cd "\winnt\profiles\username\programs\start menu" 在扩展停用的情况下，你必须键入以上命令。 ```]]></content>
      <categories>
        <category>windows cmd</category>
      </categories>
      <tags>
        <tag>cmd</tag>
        <tag>dir</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows command(2):DEL/ERASE]]></title>
    <url>%2F2016%2F03%2F15%2Fwindows-cmd-2-del-erase%2F</url>
    <content type="text"><![CDATA[title: windows command(2):DEL/ERASE categories: - windows cmd tags: - del - cmd comments: true layout: post date: 2016-03-15 22:50:19 modified: 2016-03-15 22:50:19 --- {% asset_img del.png %} 删除命令，用来删除一个或多个文件，不能删除目录(RD/RMDIR用来删除目录)。DEL和ERASE相当于互为别名，功能没有区别。 举例： # 删除单个文件 ```bat single file D:\doc>dir /B a.txt D:\doc>DEL a.txt D:\doc>dir /B ``` ## 如果文件不存在 ```bat not exist D:\doc>del b.txt 找不到 D:\doc\b.txt D:\doc>echo %ERRORLEVEL% 0 ``` ## 如果文件只读 ```bat readonly D:\doc>del a.txt D:\doc\a.txt 拒绝访问。 D:\doc>echo %ERRORLEVEL% 0 ``` # 删除只读文件 ```bat force del del a.txt /F del a.txt /A:R ``` # 删除文件夹内所有文件和子目录 ```bat del D:\doc /F /S /Q ``` Reference: ```text help DEL 删除一个或数个文件。 DEL [/P] [/F] [/S] [/Q] [/A[[:]attributes]] names ERASE [/P] [/F] [/S] [/Q] [/A[[:]attributes]] names names 指定一个或多个文件或者目录列表。 通配符可用来删除多个文件。 如果指定了一个目录，该目录中的所 有文件都会被删除。 /P 删除每一个文件之前提示确认。 /F 强制删除只读文件。 /S 删除所有子目录中的指定的文件。 /Q 安静模式。删除全局通配符时，不要求确认 /A 根据属性选择要删除的文件 属性 R 只读文件 S 系统文件 H 隐藏文件 A 存档文件 I 无内容索引文件 L 重分析点 - 表示“否”的前缀 如果命令扩展被启用，DEL 和 ERASE 更改如下: /S 开关的显示句法会颠倒，即只显示已经 删除的文件，而不显示找不到的文件。 ```]]></content>
      <categories>
        <category>windows cmd</category>
      </categories>
      <tags>
        <tag>cmd</tag>
        <tag>del</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows command(1):COPY XCOPY ROBOCOPY]]></title>
    <url>%2F2016%2F03%2F09%2Fwindows-cmd-1-copy-xcopy-robocopy%2F</url>
    <content type="text"><![CDATA[title: windows command(1):COPY XCOPY ROBOCOPY categories: - windows cmd tags: - copy - cmd comments: true layout: post date: 2016-03-09 21:21:27 modified: 2016-03-25 21:21:27 --- {% asset_img copy.png %} COPY可以将一个或多个文件复制到指定目录； XCOPY是COPY的加强版本，可以将目录或者文件拷贝到指定的目录； ROBOCOPY(Robost File Copy)是XCOPY的加强版本，支持断点传输，对文件属性的保留及去除，能跳过已经在目标文件夹中存在的指定文件的拷贝，多进程拷贝(win7 only)等。 举例： # 拷贝目录 拷贝source文件夹里所有的内容(包括"hidden"或者"system"属性的文件)到一个空的文件夹。 ```bat D:\>XCOPY D:\source D:\newcopy /S /E /I /H D:\source\a.xml D:\source\b.xml D:\source\file.txt 复制了 3 个文件 ``` # 拷贝文件 拷贝source文件夹里的所有xml文件到newcopy文件夹里,如果文件存在则覆盖，且要验证新文件是否正确。 ```bat D:\>XCOPY D:\source\*.xml D:\newcopy\ /A /Y /V D:\source\a.xml D:\source\b.xml 复制了 2 个文件 ``` 注意，如果目录不以反斜杠`\`结尾，在目标文件夹不存在时，则会询问是文件还是目录。 ``` D:\>XCOPY D:\source\*.xml D:\newcopy /A /Y 目标 D:\newcopy 是文件名 还是目录名 (F = 文件，D = 目录)? ``` # 路径名中有空格 ```bat D:\>XCOPY D:\source dir D:\newcopy /S /E /I /H 无效的参数数量 ``` 可以在路径加双引号 ```bat XCOPY "D:\source dir" D:\newcopy /S /E /I /H D:\source dir\a.xml D:\source dir\b.xml D:\source dir\file.txt 复制了 3 个文件 ``` # copy和xcopy的区别 1. 路径解析 用xcopy时，通配符`\*`会被先转义成`*`,实际去查找带有`*`的文件。 而用copy时，通配符前不管加几个`\`都不会被转义。 ```bat d:\test\test>xcopy .\\hello\*.txt hi\ /Y hello\123.txt hello\hi.txt 复制了 2 个文件 d:\test\test>xcopy hello\\*.txt hi\ /Y 找不到文件 - *.txt 复制了 0 个文件 d:\test\test>copy hello\\*.txt hi\ /Y hello\\123.txt hello\\hi.txt 已复制 2 个文件。 ``` 2. 文件合并 copy有一个文件合并的功能是xcopy所没有的。 ```bat merge files copy /B file1+file2+file3 mergefile ``` # ERRORLEVEL 通过`echo %errorlevel%`可以检查命令的退出码。 0 文件复制没有错误。 1 没有找到要复制的文件。 2 用户按 CTRL+C 终止了 xcopy。 4 出现了初始化错误。没有足够的内存或磁盘空间，或命令行上输入了无效的驱动器名称或语法。 5 出现了磁盘写入错误。 Reference: ```text help COPY 将一份或多份文件复制到另一个位置。 COPY [/D] [/V] [/N] [/Y | /-Y] [/Z] [/L] [/A | /B ] source [/A | /B] [+ source [/A | /B] [+ ...]] [destination [/A | /B]] source 指定要复制的文件。 /A 表示一个 ASCII 文本文件。 /B 表示一个二进位文件。 /D 允许解密要创建的目标文件 destination 为新文件指定目录和/或文件名。 /V 验证新文件写入是否正确。 /N 复制带有非 8dot3 名称的文件时， 尽可能使用短文件名。 /Y 不使用确认是否要覆盖现有目标文件 的提示。 /-Y 使用确认是否要覆盖现有目标文件 的提示。 /Z 用可重新启动模式复制已联网的文件。 /L 如果源是符号链接，请将链接复制 到目标而不是源链接指向的实际文件。 命令行开关 /Y 可以在 COPYCMD 环境变量中预先设定。 这可能会被命令行上的 /-Y 替代。除非 COPY 命令是在一个批处理脚本中执行的，默认值应为 在覆盖时进行提示。 要附加文件，请为目标指定一个文件，为源指定 数个文件(用通配符或 file1+file2+file3 格式)。 ``` ```text help XCOPY 复制文件和目录树。 XCOPY source [destination] [/A | /M] [/D[:date]] [/P] [/S [/E]] [/V] [/W] [/C] [/I] [/Q] [/F] [/L] [/G] [/H] [/R] [/T] [/U] [/K] [/N] [/O] [/X] [/Y] [/-Y] [/Z] [/B] [/J] [/EXCLUDE:file1[+file2][+file3]...] source 指定要复制的文件。 destination 指定新文件的位置和/或名称。 /A 仅复制有存档属性集的文件， 但不更改属性。 /M 仅复制有存档属性集的文件， 并关闭存档属性。 /D:m-d-y 复制在指定日期或指定日期以后更改的文件。 如果没有提供日期，只复制那些 源时间比目标时间新的文件。 /EXCLUDE:file1[+file2][+file3]... 指定含有字符串的文件列表。每个字符串 在文件中应位于单独的一行。如果任何 字符串与复制文件的绝对路径的任何部分相符， 则排除复制该文件。例如， 指定如 \obj\ 或 .obj 的字符串会分别 排除目录 obj 下面的所有文件或带有 .obj 扩展名的所有文件。 /P 创建每个目标文件之前提示你。 /S 复制目录和子目录，不包括空目录。 /E 复制目录和子目录，包括空目录。 与 /S /E 相同。可以用来修改 /T。 /V 验证每个新文件的大小。 /W 提示你在复制前按键。 /C 即使有错误，也继续复制。 /I 如果目标不存在，且要复制多个文件， 则假定目标必须是目录。 /Q 复制时不显示文件名。 /F 复制时显示完整的源文件名和目标文件名。 /L 显示要复制的文件。 /G 允许将加密文件复制到 不支持加密的目标。 /H 也复制隐藏文件和系统文件。 /R 覆盖只读文件。 /T 创建目录结构，但不复制文件。不 包括空目录或子目录。/T /E 包括 空目录和子目录。 /U 只复制已经存在于目标中的文件。 /K 复制属性。一般的 Xcopy 会重置只读属性。 /N 用生成的短名称复制。 /O 复制文件所有权和 ACL 信息。 /X 复制文件审核设置(隐含 /O)。 /Y 取消提示以确认要覆盖 现有目标文件。 /-Y 要提示以确认要覆盖 现有目标文件。 /Z 在可重新启动模式下复制网络文件。 /B 复制符号链接本身与链接目标。 /J 复制时不使用缓冲的 I/O。推荐复制大文件时使用。 开关 /Y 可以预先在 COPYCMD 环境变量中设置。 这可能被命令行上的 /-Y 覆盖。 ``` ```text help ROBOCOPY ------------------------------------------------------------------------------- ROBOCOPY :: Windows 的可靠文件复制 ------------------------------------------------------------------------------- 开始时间: 2016年3月9日 22:40:39 用法 :: ROBOCOPY source destination [file [file]...] [options] 源 :: 源目录(驱动器:\路径或\\服务器\共享\路径)。 目标 :: 目标目录(驱动器:\路径或\\服务器\共享\路径)。 文件 :: 要复制的文件(名称/通配符: 默认为 "*.*")。 :: :: 复制选项: :: /S :: 复制子目录，但不复制空的子目录。 /E :: 复制子目录，包括空的子目录。 /LEV:n :: 仅复制源目录树的前 n 层。 /Z :: 在可重新启动模式下复制文件。 /B :: 在备份模式下复制文件。 /ZB :: 使用可重新启动模式；如果拒绝访问，请使用备份模式。 /J :: 复制时使用未缓冲的 I/O (推荐在复制大文件时使用)。 /EFSRAW :: 在 EFS RAW 模式下复制所有加密的文件。 /COPY:复制标记:: 要复制的文件内容(默认为 /COPY:DAT)。 (复制标记: D=数据，A=属性，T=时间戳)。 (S=安全=NTFS ACL，O=所有者信息，U=审核信息)。 /SEC :: 复制具有安全性的文件(等同于 /COPY:DATS)。 /COPYALL :: 复制所有文件信息(等同于 /COPY:DATSOU)。 /NOCOPY :: 不复制任何文件信息(与 /PURGE 一起使用)。 /SECFIX :: 修复所有文件的文件安全性，即使是跳过的文件。 /TIMFIX :: 修复所有文件的文件时间，即使是跳过的文件。 /PURGE :: 删除源中不再存在的目标文件/目录。 /MIR :: 镜像目录树(等同于 /E 加 /PURGE)。 /MOV :: 移动文件(复制后从源中删除)。 /MOVE :: 移动文件和目录(复制后从源中删除)。 /A+:[RASHCNET] :: 将给定的属性添加到复制的文件。 /A-:[RASHCNET] :: 从复制的文件中删除给定的属性。 /CREATE :: 仅创建目录树和长度为零的文件。 /FAT :: 仅使用 8.3 FAT 文件名创建目标文件。 /256 :: 关闭超长路径(> 256 个字符)支持。 /MON:n :: 监视源；发现多于 n 个更改时再次运行。 /MOT:m :: 监视源；如果更改，在 m 分钟时间后再次运行。 /RH:hhmm-hhmm :: 可以启动新的复制时运行的小时数 - 时间。 /PF :: 基于每个文件(而不是每个步骤)来检查运行小时数。 /IPG:n :: 程序包间的间距(ms)，以释放低速线路上的带宽。 /SL :: 对照目标复制符号链接。 /MT[:n] :: 使用 n 个线程进行多线程复制(默认值为 8)。 n 必须至少为 1，但不得大于 128。 该选项与 /IPG 和 /EFSRAW 选项不兼容。 使用 /LOG 选项重定向输出以便获得最佳性能。 /DCOPY:复制标记:: 要复制的目录内容(默认为 /DCOPY:DA)。 (复制标记: D=数据，A=属性，T=时间戳)。 /NODCOPY :: 不复制任何目录信息(默认情况下，执行 /DCOPY:DA)。 /NOOFFLOAD :: 在不使用 Windows 复制卸载机制的情况下复制文件。 :: :: 文件选择选项: :: /A :: 仅复制具有存档属性集的文件。 /M :: 仅复制具有存档属性的文件并重置存档属性。 /IA:[RASHCNETO] :: 仅包含具有任意给定属性集的文件。 /XA:[RASHCNETO] :: 排除具有任意给定属性集的文件。 /XF 文件[文件]... :: 排除与给定名称/路径/通配符匹配的文件。 /XD 目录[目录]... :: 排除与给定名称/路径匹配的目录。 /XC :: 排除已更改的文件。 /XN :: 排除较新的文件。 /XO :: 排除较旧的文件。 /XX :: 排除多余的文件和目录。 /XL :: 排除孤立的文件和目录。 /IS :: 包含相同文件。 /IT :: 包含已调整的文件。 /MAX:n :: 最大的文件大小 - 排除大于 n 字节的文件。 /MIN:n :: 最小的文件大小 - 排除小于 n 字节的文件。 /MAXAGE:n :: 最长的文件存在时间 - 排除早于 n 天/日期的文件。 /MINAGE:n :: 最短的文件存在时间 - 排除晚于 n 天/日期的文件。 /MAXLAD:n :: 最大的最后访问日期 - 排除自 n 以来未使用的文件。 /MINLAD:n :: 最小的最后访问日期 - 排除自 n 以来使用的文件。 (If n < 1900 then n = n days, else n = YYYYMMDD date)。 /XJ :: 排除接合点。(默认情况下通常包括)。 /FFT :: 假设 FAT 文件时间(2 秒粒度)。 /DST :: 弥补 1 小时的 DST 时间差。 /XJD :: 排除目录的接合点。 /XJF :: 排除文件的接合点。 :: :: 重试选项: :: /R:n :: 失败副本的重试次数: 默认为 1 百万。 /W:n :: 两次重试间的等待时间: 默认为 30 秒。 /REG :: 将注册表中的 /R:n 和 /W:n 保存为默认设置。 /TBD :: 等待定义共享名称(重试错误 67)。 :: :: 日志记录选项: :: /L :: 仅列出 - 不复制、添加时间戳或删除任何文件。 /X :: 报告所有多余的文件，而不只是选中的文件。 /V :: 生成详细输出，同时显示跳过的文件。 /TS :: 在输出中包含源文件的时间戳。 /FP :: 在输出中包含文件的完整路径名称。 /BYTES :: 以字节打印大小。 /NS :: 无大小 - 不记录文件大小。 /NC :: 无类别 - 不记录文件类别。 /NFL :: 无文件列表 - 不记录文件名。 /NDL :: 无目录列表 - 不记录目录名称。 /NP :: 无进度 - 不显示已复制的百分比。 /ETA :: 显示复制文件的预期到达时间。 /LOG:文件 :: 将状态输出到日志文件(覆盖现有日志)。 /LOG+:文件 :: 将状态输出到日志文件(附加到现有日志中)。 /UNILOG:文件 :: 以 UNICODE 方式将状态输出到日志文件(覆盖现有日志)。 /UNILOG+:文件 :: 以 UNICODE 方式将状态输出到日志文件(附加到现有日志中)。 /TEE :: 输出到控制台窗口和日志文件。 /NJH :: 没有作业标头。 /NJS :: 没有作业摘要。 /UNICODE :: 以 UNICODE 方式输出状态。 :: :: 作业选项 : :: /JOB:作业名称 :: 从命名的作业文件中提取参数。 /SAVE:作业名称 :: 将参数保存到命名的作业文件 /QUIT :: 处理命令行后退出(以查看参数)。 /NOSD :: 未指定源目录。 /NODD :: 未指定目标目录。 /IF :: 包含以下文件。 :: :: 备注: :: 在卷的根目录上使用 /PURGE 或 /MIR 将 导致 robocopy 也对“系统卷信息”目录内的 文件应用所请求的操作。如果这不是 预期目的，则可以使用 /XD 开关指示 robocopy 跳过该目录。 ``` Reference: 1. [XCOPY wiki](https://en.wikipedia.org/wiki/XCOPY)]]></content>
      <categories>
        <category>windows cmd</category>
      </categories>
      <tags>
        <tag>cmd</tag>
        <tag>copy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jenkins自动部署hexo到github]]></title>
    <url>%2F2016%2F03%2F08%2Fjenkins-auto-deploy-hexo%2F</url>
    <content type="text"><![CDATA[title: Jenkins自动部署hexo到github categories: - CI - Jenkins tags: - CI - Jenkins comments: true layout: post date: 2016-03-08 21:27:52 modified: 2016-04-28 21:27:52 --- 南方二重唱-细说往事 * * * 软件开发中有一种称为"持续集成(Continuous Integration)"的方法，其宗旨是团队开发成员可以经常集成软件，进行测试，从而达到小步快进的效果。而持续集成每次都需要构建（包括编译，发布，自动化测试等），如果手动构建会增加很多工作量，于是乎自动化构建应运而生。 Jenkins是常用的一种自动化构建工具。我们以部署hexo来说明Jenkins的基本使用方法。 1. install [Jenkins](www.jenkins-ci.com) 2. use command `java -jar jenkins.war` to run jenkins. `java -Dhudson.util.ProcessTree.disable=true -jar jenkins.war`可以禁用杀死线程功能，可以在启动hexo server并保持开启。 3. open web browser, use `localhost:8080` to open dashboard. 4. creat a item named 'deploy hexo'. {% asset_img jenkins_create_item.png %} 5. configure the item. 参数化构建，用不同的参数来实现不同目的的构建。 {% asset_img jenkins_configure_item1.png %} {% asset_img jenkins_configure_item2.png %} 6. write script {% include_code lang:python jenkins_deploy_hexo jenkins_hexo/jenkins_deploy_hexo.py %} 7. build {% asset_img jenkins_build_item.png %} Reference: 1. [Jenkins](http://jenkins-ci.org/)]]></content>
      <categories>
        <category>CI</category>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>CI</tag>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[防护等级IP代码]]></title>
    <url>%2F2016%2F03%2F02%2FIP-code-degree-of-protection-by-enclosure%2F</url>
    <content type="text"><![CDATA[title: 防护等级IP代码 categories: - standard tags: - IP code - IEC comments: true layout: post date: 2016-03-02 20:30:42 modified: 2016-03-02 20:30:42 --- {% asset_img IngressProtection.jpg %} # 防护等级(degree of Ingress Protection) 针对电器设备(electrical equipment)的防护等级(degrees of protection provided by the enclosures)，通常记为IPXX，如IP23。 有三种防护： 1. 保护人不接触到器件内部有害零件(protection of persons against access to hazardous parts inside the enclosure) 2. 防尘(protection of the equipment inside the enclosure against ingress of solid foreign objects) 3. 防水(protection of the equipment inside the enclosure against harmful effects due to the ingress of water) # 记法 {% asset_img arrangement_of_IP_code.png arrangement of IP code %} 举例： IP45 - 防尘等级4，防水等级5 IPX5 - 防水等级5 IP4X - 防尘等级4 # IP代码含义 {% asset_img meanings_of_IP_code.png %} # 说明 这里只说明常见的防水防尘含义，不讨论对人的保护等级含义。 ## 第1个数字 | IP | 防护范围 | 说明 | |-------|:-----------------------------------------:|:------:| | IP0X | 无防护 | 对外界的人或物无特殊的防护 | | IP1X | 防止直径大于等于50mm的固体外物侵入 | 防止人体（如手掌）因意外而接触到电器内部的零件，防止较大尺寸（直径大于50mm）的外物侵入 | | IP2X | 防止直径大于等于等于12.5mm的固体外物侵入| 防止人的手指接触到电器内部的零件，防止中等尺寸（直径大于12.5mm）的外物侵入 | | IP3X | 防止直径大于等于2.5mm的固体外物侵入 | 防止直径或厚度大于2.5mm的工具、电线及类似的小型外物侵入而接触到电器内部的零件 | | IP4X | 防止直径大于等于1.0mm的固体外物侵入 | 防止直径或厚度大于1.0mm的工具、电线及类似的小型外物侵入而接触到电器内部的零件 | | IP5X | 防止外物及灰尘 | 虽不能完全防止灰尘侵入，但灰尘的侵入量不会影响电器的正常运作 | | IP6X | 防止外物及灰尘 | 完全防止外物及灰尘侵入 | ## 第2个数字 | IP | 防护范围 | 说明 | |-------|:-----------------------------------------------:|:------:| | IPX0 | 无防护 | 对水或湿气无特殊的防护 | | IPX1 | 防止垂直下落的水滴浸入 | 垂直落下的水滴（如凝结水）不会对电器造成损坏 | | IPX2 | 倾斜15度时，仍可防止垂直下落的水滴浸入 | 当电器由垂直倾斜至15度时，滴水不会对电器造成损坏 | | IPX3 | 防止喷洒(spraying)的水浸入 | 防雨或防止与垂直的夹角小于60度的方向所喷洒的水侵入电器而造成损坏 | | IPX4 | 防止飞溅(splashing)的水浸入 | 防止各个方向飞溅而来的水侵入电器而造成损坏 | | IPX5 | 防止喷射的水(water jets)浸入 | 防止来自各个方向由喷嘴射出的水侵入电器而造成损坏 | | IPX6 | 防止大浪(powerful water jets)浸入 | 防止因大浪的侵袭而造成的损坏 | | IPX7 | 防止短时间浸水(temporary immersion)时水的浸入 | 电器浸在水中一定时间或水压在一定的标准以下，可确保不因浸水而造成损坏 | | IPX8 | 防止长时间浸水(continuous immersion)时水的浸入| 电器长时间沉没在指定的水压下，可确保不因浸水而造成损坏 | | IPX9 | 防止高压高温浸水时水的浸入 | 电器高压高温水浸入下，可确保不因浸水而造成损坏 | ## 附属字母1 {% asset_img addition_letter_1.png %} ## 附属字母2 {% asset_img addition_letter_1.png %} Reference： 1. IEC60529:2013 2. [IP code in wikipedia](https://en.wikipedia.org/wiki/IP_Code)]]></content>
      <categories>
        <category>standard</category>
      </categories>
      <tags>
        <tag>IP code</tag>
        <tag>IEC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单元测试中的代码覆盖率(Code Coverage in Unit Test)]]></title>
    <url>%2F2016%2F03%2F01%2Fcode-coverage-in-unit-test%2F</url>
    <content type="text"><![CDATA[title: 单元测试中的代码覆盖率(Code Coverage in Unit Test) categories: - code coverage - unit test tags: - test comments: true layout: post date: 2016-03-01 20:33:50 modified: 2016-03-01 20:33:50 --- 徐佳莹-不痛 {% asset_img Tessy_Coverage_viewer.jpg %} # What is code coverage # 代码覆盖率(code coverage,test coverage)是单元测试(unit test)中的一种度量方法，用来评估测试用例(test case)能够覆盖多少的代码，能够从一定程度上反应代码的质量。可以用公式来表示： Code Coverage=(Number of items excuted)/(Total Number of Items)*100% # how many types of code coverage # ## Function Coverage ## 用来指示是否所有的函数都被调用过。 ## Statement Coverage(SC,C0) ## 语句覆盖率(statement coverage，SC)，也称为行覆盖率(line coverage)，反映了语句（汇编级指令或C语言的语句）的执行率。通常记为：C0。 ```C Code excerpt to illustrate the weakness of statement coverage int a = 0; if (decision) { a = 1; } a = 1 / a; ``` test case:decision = 1,则所有语句均会执行一次，覆盖率为100%，但是如果decision是'0',那么执行这段代码出现`除0`错误。 所以，即使是100%的state coverage，也有可能会有严重的bug存在。 100%的SC仅仅意味着：所有语句在测试中至少被执行了一次，仅此而已。 SC可以用来指示dead code，这些code根本不能被执行； SC可以说明需要增加test case。 ## Branch Coverage / Decision Coverage (DC,C1) ## 定义：是否每个控制结构（如if，case语句）的所有branch都被执行过。 同样上一节的代码，decision为'1'的DC只有50%，因为if隐含的else没有被执行过；如果需要达到100%的DC，至少再增加decision为 '0'的测试用例。 DC包含SC，如果100%的DC则肯定是100%的SC。 但如果是50%的DC并不能说明是50%的SC。因为DC是计算decision的分支，如if语句只可能是0%，50%或100%三种覆盖率，无其他可能；而SC是计算语句执行的百分比。 有时候100%的Branch Coverage不可能达到。 ## Condition Coverage(CC) # 定义：是否每个布尔`子表达式`都被估值过true和false。 ```C A decision can be made up of conditions if ((A||B)&&(C||!D)) ``` `(A||B)&&(C||!D)`是一个decision，但是由A、B、C和D四个condition(atomic decision)组成。 ### Simple CC ```Pascal A code snippet in Pascal and the four possible test cases (complete evaluation) IF A AND B THEN ... ELSE ... ``` | | A | B | A and B | | |-----|:---:|:---:|:--------:|:---:| | 1 | F | F | F | | | 2 | F | T | F | x | | 3 | T | F | F | x | | 4 | T | T | T | | 由于Pascal逻辑运算没有短路，而是complete evaluation，所以只需要执行test case2和3就能达到Simple CC 100%的覆盖率(A和B都执行过true和false)；但此时DC才达到50%。 再举一例 ```C A code snippet in C and the three possible test cases (incomplete evaluation) if (A && B) { ... } else { ... } ``` | | A | B | A and B | | |-----|:---:|:---:|:--------:|:---:| | 1 | F | - | F | x | | 2 | T | F | F | x | | 3 | T | T | T | x | C语言有短路运算逻辑表达式的，所以需要3个测试用例才能使A和B都执行过true和false，此时CC和DC都是100%. ### Modified Condition / Decision Coverage(MC/DC,MCDC) MC/DC=DC+CC+每个condition能独立影响decision的输出结果。 ```C if ((a || b) && c) ``` | | a | b | c | ((a or b) and c) | |-----|:---:|:---:|:----:|:---------------:| | 1 | F | F | F | F | | 2 | F | F | T | F | | 3 | F | T | F | F | | 4 | F | T | T | T | | 5 | T | F | F | F | | 6 | T | F | T | T | | 7 | T | T | F | F | | 8 | T | T | T | T | Test case 1和8就能够使得DC+CC达到100%。 但是1中的'c'，8中国的'b'不能影响desicion的输出结果不能满足MC/DC的标准。 以下test case能够满足MC/DC的要求： | | a | b | c | ((a or b) and c) | |-----|:---:|:---:|:----:|:---------------:| | 2 | `F` | `F` | T | F | | 3 | F | T | `F` | F | | 4 | F | `T` | `T` | T | | 6 | `T` | F | T | T | 2与6由a独立影响；2与4由b独立影响；3与4由c独立影响。 ### Multiple Condition Coverage(MCC) ### MCC要求一个desicion里的所有condition的组合都要被测试到，也就是说test case由conditon的真值表确定。 如上一节的例子，需要1到8所有的case来达到100%的MCC。 ## Path Coverage(C4) ## 路径覆盖率测量所有可能的执行路径中多少路径被执行了。 ```C if (a) x else y; if (b) z; ``` 需要4(=22)个test case来达到100%的path coverage。 | | a | b | | |-----|:---:|:---:|:----:| | 1 | F | F | x | | 2 | F | T | x | | 3 | T | F | x | | 4 | T | T | x | path coverage所需的test case随着branch的增多而成指数级增加，特别是有循环的话，基本达到100%的覆盖率是不现实的。 # 用处 # * 一些标准（如：ISO26262 part6）和客户的要求 * 帮助发现一些未测试的代码块 * 有助于重构 # 局限性 # 100%的代码覆盖率并不意味着没有bug; 代码覆盖率只针对测试的代码，而不是功能规范(functioality specification); 不能为了提高测试覆盖率而忽略主要目的是测试代码的行为(代码行为与设计是不是一致)不能因为修改代码的同时需要修改或增加测试用例来满足覆盖率要求，而放弃了对代码的优化。 Reference: 1. [Is 100% Code Coverage Enough?](http://www.stickyminds.com/sites/default/files/article/file/2013/XUS252268366file1_0.pdf) 2. [code coverage, what is for after all?](http://blogs.msdn.com/b/billliu/archive/2012/05/06/code-coverage-what-is-for-after-all.aspx) 3. [hats my Coverage? (C0 C1 C2 C3 + Path)](http://grosser.it/2008/04/04/whats-my-coverage-c0-c1-c2-c3-path-coverage/) 4. [Code Coverage Does Matter](https://coding.abel.nu/2015/12/code-coverage-does-matter) 5. [Code Coverage](https://en.wikipedia.org/wiki/Code_coverage) 6. [Code Coverage Analysis](http://www.bullseye.com/coverage.html) 7. [TestCoverage](http://martinfowler.com/bliki/TestCoverage.html)]]></content>
      <categories>
        <category>code coverage</category>
        <category>unit test</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法对应的CSS实现]]></title>
    <url>%2F2016%2F01%2F27%2FMarkdown-inline-css-compare%2F</url>
    <content type="text"><![CDATA[title: Markdown语法对应的CSS实现 categories: - Markdown - CSS tags: - CSS - Markdown comments: true layout: post date: 2016-01-27 23:00:05 modified: 2016-01-27 23:00:05 --- 林二汶-只怕不够时间看你白头 这篇文章是[Markdown语法对应的HTML标签实现](http://wuchenxu.github.io/2015/12/30/Markdown-html-compare/)的延续，一些格式排版除了用HTML标签实现外，也可以使用CSS实现。 # CSS的三种写法 ## 内联式 当特殊的样式需要应用到个别元素时，就可以使用内联样式。使用内联样式的方法是在相关的标签中使用样式属性。样式属性可以包含任何 CSS 属性。以下实例显示出如何改变段落的颜色和左外边距。 ```html inline css This is a paragraph ``` ## 内部式 当单个文件需要特别样式时，就可以使用内部样式表。可以在 head 部分通过 `` 标签定义内部样式表。 ```html internal css body {color: red} p {margin-left: 20px} ``` ## 外部式 当样式需要被应用到很多页面的时候，外部样式表将是理想的选择。使用外部样式表，你就可以通过更改一个文件来改变整个站点的外观。 ```html external css ``` # 内联式CSS实现markdown语法 ## 斜体 Italic ```html css 这是斜体3 这是斜体4 ``` 这是斜体3 这是斜体4 ```markdown markdown *这是斜体1* _这是斜体2_ ``` *这是斜体1* _这是斜体2_ ## 粗体 Bold ```html css 这是粗体 ``` 这是粗体 ```markdown markdown **这是粗体1** __这是粗体2__ ``` **这是粗体1** __这是粗体2__ ## 删除线 Strikethrough ```html css 我带删除线 ``` 我带删除线 ```markdown GFM ~~This is strikethrough,only for GFM.~~ ``` ~~This is strikethrough,only for GFM.~~ ## 下划线 Underline ```html css 我带下划线 ``` 我带下划线 ## 上划线 Overline ```html css 我带上划线 ``` 我带上划线 ## 字体 Font ```html css Hello,微软雅黑体 Hello,宋体 Hello,楷体 Hello,黑体 Hello,腾讯字体格式。 Hello,淘宝字体格式。 Hello,小米字体格式。 ``` Hello,微软雅黑体 Hello,宋体 Hello,楷体 Hello,黑体 Hello,腾讯字体格式。 Hello,淘宝字体格式。 Hello,小米字体格式。 ## 文字阴影 CSS3才支持的特性 ```html css 文字阴影 ``` 文字阴影 Reference: 1. [w3scholl HTML CSS](http://www.w3school.com.cn/html/html_css.asp) 2. [常用CSS缩写语法总结](http://www.w3cn.org/article/tips/2005/103.html) 3. [CSS,font-family,好看常用的中文字体](http://www.zreading.cn/ican/2014/10/css-font-family/) 4. [中文字体属性值转换Unicode](http://tool.lu/fontfamily/)]]></content>
      <categories>
        <category>Markdown</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编码字符集]]></title>
    <url>%2F2016%2F01%2F21%2Fcharacter-encodings-introduce%2F</url>
    <content type="text"><![CDATA[title: 编码字符集 categories: - charset - encoding tags: - charset - encoding - unicode - GB2312 comments: true layout: post date: 2016-01-21 14:59:51 modified: 2016-07-10 14:59:51 --- 常石磊-老爸 {% asset_img character_encoding_yu.png %} # 编码 对字符和图形进行编码是为了计算机可以对图形字符信息的处理、交换、存储、传输、显现、输入和输出。 # 编码种类 ## ASCII码 ASCII(American Standard Code for Information Interchange)码在1950年由美国制定，用00~7F表示英文字符。ASCII是事实上的世界标准，后来的字符集基本都兼容ASCII。 {% asset_img ASCII.png ASCII码%} ## ISO-8859-1 ISO-8859-1(Latin alphabet part 1)编码是单字节编码，向下兼容ASCII，其编码范围是0x00-0xFF，0x00-0x7F之间完全和ASCII一致，0x80-0x9F之间是控制字符，0xA0-0xFF之间是文字符号。 此字符集支持部分于欧洲使用的语言。 法语及芬兰语本来也使用ISO/IEC 8859-1来表示。但因它没有法语使用的 œ、Œ、Ÿ 三个字母及芬兰语使用的 Š、š、Ž、ž ，故于1998年被ISO/IEC 8859-15所取代。（ISO 8859-15同时加入了欧元符号）。 ## GB2312 为了在计算机表示汉字，对ASCII进行了扩展，由于ASCII一个字节的最高位都是0，为了兼容ASCII码，规定：一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字，前面的一个字节（高字节）从0xA1用到 0xFE，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出(FE-A1+1)*(FE-A1+1)=8836个字符了。在这些编码里，我们还把数学符号、罗马希腊的字母、日文的假名们都编进去了，连在 ASCII码里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的“全角”字符，而原来在127号以下的那些就叫“半角”字符了。 这种汉字方案叫做 “GB2312“。GB2312全称为《信息交换用汉字编码字符集》，由中国国家标准总局1980年发布，1981年5月1日开始实施的一套国家标准，标准号是GB2312—1980。GB2312 是对 ASCII 的中文扩展。 GB2312-1980一共收录了7445个字符，包括6763个汉字和682个其它符号，覆盖了99.75%的常用简体汉子。GB2312编码范围：A1A1－FEFE，其中汉字编码范围：B0A1-F7FE。汉字区的内码范围高字节从B0-F7，低字节从A1-FE，占用的码位是72*94=6768。其中有5个空位是D7FA-D7FE。 GB2312虽然已经由兼容它的GBK和GB18020取代，但是还是被广泛使用。 > 凡是GB开头的国标都是强制标准，GB/T 是推荐标准，不强制使用。 ## BIG5 BIG5是在港澳台地区广泛使用的繁体汉字字符集，俗称“大五码”，其由5家台湾公司共同开发，所有叫BIG5。 1983年10月，台湾国家科学委员会、教育部国语推行委员会、中央标准局、行政院共同制定了《通用汉字标准交换码》，后经修订于1992年5月公布，更名为《中文标准交换码》，BIG5是台湾资讯工业策进会根据以上标准制定的编码方案。2003年，Big5被收录到台湾官方标准的附录当中，取得了较正式的地位。这个最新版本被称为Big5-2003。 BIG5是双字符编码，两个字节表示一个汉字。高位字节使用81-FE，低位字节使用40-7E，A1-FE。 BIG-5 码收录13468个符号和汉字，符号408个，汉字13060个，分为常用字和次常用字两部分，各部分中的汉字按照笔画/部首排列。其中：常用字5401个，次常用字7659。 ## GBK GB2312-1980仅收汉字6763个，这大大少于现有汉字，随着时间推移及汉字文化的不断延伸推广，有些原来很少用的字，现在变成了常用字，例如：朱镕基的“镕”字，未收入GB2312-80，现在大陆的报业出刊只得使用（金+容）、（金容）、（左金右容）等来表示，形式不一而同，这使得表示、存储、输入、处理都非常不方便，对于搜索引擎等软件的构造来说也不是好消息，而且这种表示没有统一标准。 为了解决这些问题，以及配合UNICODE的实施，全国信息技术化技术委员会于1995年12月1日《汉字内码扩展规范》。GB即“国标”，K是“扩展”的汉语拼音第一个字母。 GBK向下与GB2312 完全兼容，向上支持ISO 10646国际标准，在前者向后者过渡过程中起到的承上启下的作用。GBK 亦采用双字节表示，总体编码范围为8140-FEFE之间，首字节在81-FE之间，尾字节在40-FE(不要求大于127)之间，剔除XX7F一条线。 GBK共收入21886个汉字和图形符号，包括： * GB2312中的全部汉字、非汉字符号。 * BIG5中的全部汉字。 * 与ISO 10646相应的国家标准GB13000中的其它CJK汉字，以上合计20902个汉字。 * 其它汉字、部首、符号，共计984个。 微软公司自Windows 95 简体中文版开始支持GBK。 GBK编码区分三部分： * 汉字区 包括 GBK/2：OXBOA1-F7FE, 收录GB2312汉字6763个，按原序排列； GBK/3：OX8140-AOFE，收录CJK汉字6080个； GBK/4：OXAA40-FEAO，收录CJK汉字和增补的汉字8160个。 * 图形符号区 包括 GBK/1：OXA1A1-A9FE，除GB2312的符号外，还增补了其它符号 GBK/5：OXA840-A9AO，扩除非汉字区。 * 用户自定义区 即GBK区域中的空白区，用户可以自己定义字符。 > CJK:中日韩统一表意文字（CJK Unified Ideographs），目的是要把分别来自中文、日文、韩文、越文中，本质、意义相同、形状一样或稍异的表意文字（主要为汉字，但也有仿汉字如日本国字、韩国独有汉字、越南的喃字）于ISO 10646及Unicode标准内赋予相同编码。CJK 是中文（Chinese）、日文（Japanese）、韩文（Korean）三国文字的缩写。 ## GB18030 GB18030 是最新的汉字编码字符集国家标准, 向下兼容 GBK 和 GB2312 标准，增加了对少数民族文字（如藏、蒙古、傣、彝、朝鲜、维吾尔文等）的支持。 GB18030 编码是一二四字节变长编码。一字节部分从 0x0~0x7F 与 ASCII 编码兼容。 二字节部分, 首字节从 0x81~0xFE, 尾字节从 0x40~0x7E 以及 0x80~0xFE, 与 GBK标准`基本兼容`。 四字节部分, 第一字节从 0x81~0xFE, 第二字节从 0x30~0x39, 第三和第四字节的范围和前两个字节分别相同。 四字节部分覆盖了从 0x0080 开始, 除去二字节部分已经覆盖的所有 Unicode 3.1 码位。也就是说, GB18030 编码在码位空间上做到了与 Unicode 标准一一对应,这一点与 UTF-8 编码类似。 GB18030有两个版本：GB18030-2000和GB18030-2005。GB18030-2000是GBK的取代版本，它的主要特点是在GBK基础上增加了CJK统一汉字扩充A的汉字。GB18030-2005的主要特点是在GB18030-2000基础上增加了CJK统一汉字扩充B的汉字。 Windows XP开始原生支持GB18030. 从ASCII、GB2312、 GBK到GB18030，这些编码方法是向下兼容的，即同一个字符在这些方案中总是有相同的编码，后面的标准支持更多的字符。在这些编码中，英文和中文可以统一地处理。区分中文编码的方法是高字节的最高位不为0。 ## windows-1251 windows-1251是一种8位字符编码，设计包括使用西里尔脚本语言如俄语、保加利亚语、塞尔维亚斯拉夫语和其他语言。它是最广泛用于编码的保加利亚，塞尔维亚语和马其顿语。 ## Shift JIS Shift JIS(Shift Japanese Industrial Standards, SJIS)是一个日本电脑系统常用的编码表。它能容纳全角及半角拉丁字母、平假名、片假名、符号及日语汉字。 它被命名为Shift_JIS的原因，是它在放置全角字符时，要避开原本在0xA1-0xDF放置的半角假名字符。使用单字节或者双字节表示字符。 ## Unicode Unicode 是基于国际标准化组织（International Organization for Standardization，简称ISO）所制定的 ISO/IEC 10646 ，即通用字符集（Universal Character Set，简称 UCS）的标准来发展，在1991年首次以书本的形式（The Unicode Standard）对外发布。最新版本的Unicode包含了超过120000个字符(超过了2个字节能表示的范围)，覆盖了129中现代及古代语言。 Unicode给每个字符提供了一个唯一的数字,表示为U+xxxxxx，成为code point。 如`宇`的code point是U+5B87。 {% asset_img CJK_Unicode.png %} Unicode只是一种抽象的表示形式，就像漂浮在空中一样，最终在使用的时候要有一种表现形式，如我们表示成5B87，那么我们可不可以表示成875B呢？技术上，当然是可以的，这时一个叫做 BOM(Byte Order Mark)的东西诞生了，我们记录在文件的开头，来标记是否需要交换字节顺序。 ### UTF-16 UTF-16 (16-bit Unicode Transformation Format) 可以编码所以的Unicode，是一种变长编码形式，每个code point被编码成一个或者两个16位的双字节数。 UTF-16中的所有ASCII码，都是多了一个00字节。 UTF-16 是从16位定长的编码UCS-2（定长的2字节UCS字符集）发展未来，由于一个2字节定长的编码不够表示所有的字符，UCS-2已经被废弃。 U+0000~U+D7FF以及U+E000~U+FFFF编码是16位的code point； U+D800~U+DFFF保留，不使用； U+10000~U+10FFFF采用算法转换成两个16位编码： 先减去0x010000得到一个20位的数，然后分成高10位和低10位两个数，高10位加0xD800，低10位加0xDC00. {% asset_img utf-16BE_windows.png UTF-16BE %} Windows API，Java，JavaScript使用UTF-16. ### UTF-8 UTF-8可以编码所有的unicode，由Ken Thompson（Unix、C的发明者之一）于1992年创建,采用变长编码形式，可以单字节向下兼容ASCII码，可以避免字节序，所以不必使用BOM。 UTF-8是主流的万维网编码方式，2016年1月统计大约有[86%](http://w3techs.com/technologies/history_overview/character_encoding/ms/y)的网页使用UTF-8。 转换表如下： |Bits of code point|First code point|Last code point|Bytes in sequence| Byte 1 | Byte 2 | Byte 3 | Byte 4 | Byte 5 | Byte 6 | |:----------------:|:--------------:|:-------------:|:---------------:|:---------:|:---------:|:---------:|:---------:|:----------:|:---------:| | 7 | U+0000 | U+007F | 1 | `0xxxxxxx`| | | | | | | 11 | U+0080 | U+07FF | 2 | `110xxxxx`| `10xxxxxx`| | | | | | 16 | U+0800 | U+FFFF | 3 | `1110xxxx`| `10xxxxxx`|`10xxxxxx` | | | | | 21 | U+10000 | U+1FFFFF | 4 | `11110xxx`| `10xxxxxx`|`10xxxxxx` |`10xxxxxx` | | | | 26 | U+200000 | U+3FFFFFF | 5 | `111110xx`| `10xxxxxx`|`10xxxxxx` |`10xxxxxx` | `10xxxxxx` | | | 31 | U+4000000 | U+7FFFFFFF | 6 | `1111110x`| `10xxxxxx`|`10xxxxxx` |`10xxxxxx` | `10xxxxxx` | `10xxxxxx`| UTF-8的优点是与ASCII码完全兼容，没有字节序问题，但是表示汉字需要3个字节。 {% asset_img utf-8_with_BOM_windows.png UTF-8 w/ BOM %} ### UTF-32 UTF-32采用定长编码形式，unicode的每个code point对应1个32bit的数。简单粗暴，占空间大。 Python使用UTF-32. ### BOM(Byte Order Mark) UTF-8以字节为编码单元，没有字节序的问题。UTF-16以两个字节为编码单元，在解释一个UTF-16文本前，首先要弄清楚每个编码单元的字 节序。例如“奎”的Unicode编码是594E，“乙”的Unicode编码是4E59。如果我们收到UTF-16字节流“594E”，那么这是“奎” 还是“乙”？ Unicode规范中推荐的标记字节顺序的方法是BOM。BOM是一个有点小把戏的做法： 在Unicode中有一个叫做“ZERO WIDTH NO-BREAK SPACE”的字符，它的编码是U+FEFF。 而FFFE在Unicode中是不存在的字符，所以不应该出现在实际传输中。Unicode规范建议我们在传输字节流前，先传输字符”ZERO WIDTH NO-BREAK SPACE”。 这样如果接收者收到FEFF，就表明这个字节流是Big-Endian的；如果收到FFFE，就表明这个字节流是Little-Endian的。因此字符”ZERO WIDTH NO-BREAK SPACE”又被称作BOM。 UTF-8不需要BOM来表明字节顺序，但可以用BOM来表明编码方式。字符”ZERO WIDTH NO-BREAK SPACE”的UTF-8编码是EF BB BF。所以如果接收者收到以EF BB BF开头的字节流，就知道这是UTF-8编码了。 Windows就是使用BOM来标记文本文件的编码方式的。 UTF编码 ║ Byte Order Mark UTF-8 ║ EF BB BF UTF-16LE ║ FF FE UTF-16BE ║ FE FF UTF-32LE ║ FF FE 00 00 UTF-32BE ║ 00 00 FE FF # MBCS MBCS（Multi-Byte Chactacter System（Set)）多字节字符系统或者字符集，对一个字符的表示实际上无法确定他需要占用几个字节的，只 能从编码本身来区分和解释。因此计算机在存储的时候，就是采用多字节存储的形式。也就是你需要几个字节我给你放 几个字节，比如A我给你放一个字节，比如"中“，我就给你放两个字节，这样的字符表示形式就是MBCS。 在基于GBK的windows中，不会超过2个字节，所以windows这种表示形式有叫做DBCS（Double-Byte Chactacter System），其实算是MBCS的一个特例。 # tranform between unicode and character using Python Python字符的内部编码是原生支持unicode的，python2内部使用utf-8来存储字符串。 ``` encode decode unicode----->-----str------->-------unicode ``` ```python character -> unicode sys.getfilesystemencoding() #mbcs #windows charset type('宇') #str type(u'宇') #unicode str('宇') #'\xe5\xae\x87' str(u'宇') #UnicodeEncodeError: 'ascii' codec can't encode character u'\u5b87' in position 0: ordinal not in range(128) hex(ord(u'宇')) #'0x5b87' '宇'.decode('unicode-escape') #u'\xe5\xae\x87' #Python internal use utf-8 u'宇'.encode('unicode-escape') #'\\u5b87' u'宇'.encode('utf-8') #'\xe5\xae\x87' u'\u5b87'.encode('utf-8') #'\xe5\xae\x87' u'宇'.encode('utf-16') #'\xff\xfe\x87[' #0xfffe is BOM '[' is 0x5b，little endian u'宇'.encode('utf-16-le') #'\x87[' u'宇'.encode('utf-16-be') #'[\x87' u'宇'.encode('gb2312') #'\xd3\xee' u'宇'.encode('gbk') #'\xd3\xee' u'宇'.encode('big5') #'\xa6t' #'t'=0x74 u'宇'.encode('mbcs') #'\xd3\xee' #windows use gb2312 compatible charset ``` ```python unicode -> character print unichr(0x5b87) #宇 print u'\u5b87' #宇 print b'\xE5\xAE\x87'.decode('utf-8') #宇 print bytearray([0x87, 0x5b]).decode('utf-16-le') #宇 print bytearray([0x5b, 0x87]).decode('utf-16-be') #宇 print bytearray([0xd3, 0xee]).decode('gb2312') #宇 ``` # 总结 中文网页基本上使用GBK或者UTF-8. 英文网页基本使用UTF-8. 中文windows 10 默认支持GBK。 一些OS和编程语言的API使用UTF-16或者UTF-32. windows下winhex或者notepad++可以转换文件存储的编码格式。 Reference: 1. [ASCII](https://en.wikipedia.org/wiki/ASCII) 2. [ASCII、Unicode、GBK和UTF-8字符编码的区别联系](http://dengo.org/archives/901) 3. [汉字字符集编码查询](http://www.qqxiuzi.cn/bianma/zifuji.php) 4. [GB2312](https://en.wikipedia.org/wiki/GB_2312) 5. [BIG-5](https://en.wikipedia.org/wiki/Big5) 6. [中文字符编码简介 GB2312/GBK/GB18030/BIG5](http://blog.csdn.net/liujinchengjx/article/details/1527909) 7. [GB18030](https://en.wikipedia.org/wiki/GB_18030) 8. [Windows-1251](https://en.wikipedia.org/wiki/Windows-1251) 9. [Unicode](http://www.unicode.org/) 10. [The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)](http://www.joelonsoftware.com/articles/Unicode.html) 11. [UTF-8](https://en.wikipedia.org/wiki/UTF-8) 12. [UTF与BOM之间的关系](http://blog.csdn.net/alpslzy/article/details/8605459) 13. [Python Unicode Integration](http://legacy.python.org/dev/peps/pep-0100/) 14. [Standard Encodings in Python](https://docs.python.org/2/library/codecs.html#standard-encodings)]]></content>
      <categories>
        <category>charset</category>
        <category>encoding</category>
      </categories>
      <tags>
        <tag>encoding</tag>
        <tag>unicode</tag>
        <tag>charset</tag>
        <tag>GB2312</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python获取网页编码]]></title>
    <url>%2F2016%2F01%2F14%2Fcharset-of-website%2F</url>
    <content type="text"><![CDATA[title: Python获取网页编码 categories: - python - encoding tags: - unicode - encoding - python - charset - html comments: true layout: post date: 2016-01-14 22:20:18 modified: 2016-01-23 22:20:18 --- 徐佳莹-失落沙洲 {% asset_img chrome_view_web_source.png %} # 不同网页选择不同编码形式 我们将字符的集合成为字符集(char set)，为了让计算机能存储、传输并显示字符，需要给字符集以编码。 由于历史的原因字符集的编码形式有多种。 如：ASCII码只能表示一些英文字符(7bit)；GBK/GB2312用两个字节表示中文；UTF-16用2个或者4个字节表示一个字符；UTF-8用变长形式表示unicode,兼容ASCII，英文只需要1个字节表示，而中文则需用三个字节表示。 不同的网站可能会使用不同的编码字符集，如UTF-8虽然完美兼容ASCII，而且俨然是网页编码的主流选择，但是每个中文字符字节数是GBK/GB2312的1.5倍，网站传输过程中的流量也就是1.5倍，所以一些中文网站还是选用GBK/GB2312字符集。 # 怎么获取网页字符集 ## web server response header 对网页而言，第一种方法是web server在HTML page之前返回一个类似于`Content-Type: text/html; charset=utf-8`的http header，这个header作为response header返回而不是网页的一部分。 但是如果网站由很多网页组成，而且不同的网页由使用不同的语言的用户贡献上传，那么web server不知道每个文件的真实编码集。 ## Content-Type of HTML 第二种方法是在HTML文件中直接写入Content-Type来指定charset。 这里有个`鸡生蛋蛋生鸡`的问题，你怎么能在不知道HTML文件编码方式的情况下来读取文件呢？ 幸运的是，基本上几乎所有的字符集从32到127的字符都是一样的，也就是兼容ASCII码。所以我们可以用ASCII来写HTML页面的tag来指定charset： ```html html header ``` 我们必须将这段tag放在HTML最开始的地方，因为只要浏览器读取到这个tag，会停止分析网页并用指定的编码集重新解析整个网页。 ## web brower guessing 如果浏览器没有找到`Content-Type`怎么办？ 浏览器会基于不同语言常用字符集的高词频编码来猜测字符集。 当然猜测就会有猜错的几率，如果猜错了，我们可以手动改变浏览器的编码（如Chrome，在`更多工具`->`编码`里可以修改编码）。 # Python获取网页编码 用三种不同的方法获取网页编码。 {% include_code lang:python get_website_charset get_website_charset/get_website_charset.py %} 运行结果： ``` system charset: mbcs URL: http://www.163.com.cn response header: UTF-8 html header: UTF-8 chardet analysis: UTF-8-SIG ef:bb:bf:0a:3c:21:44:4f:43:54:59:50:45:20:68:74:6d:6c:3e:0a ??? < ! D O C T Y P E h t m l > URL: http://www.sohu.com response header: None html header: GBK chardet analysis: GB2312 3c:21:44:4f:43:54:59:50:45:20:68:74:6d:6c:20:50:55:42:4c:49 < ! D O C T Y P E h t m l P U B L I ``` 可以看到结果有些站点的response是空值。 大部分网站采用的UTF-8编码，一些网站如qq、sohu、163、jd用的是GBK/GB2312，而日本乐天网站用的是EUC-JP编码。 # 网页字符集统计 通过[Historical yearly trends in the usage of character encodings for websites](http://w3techs.com/technologies/history_overview/character_encoding/ms/y)这个网页可以看到UTF-8是网页编码无可争议的绝对主导地位。 在2016年1月23号，我们看到排在前列的编码字符集是：UTF-8(86.2%) ISO-8859-1(6.8%) Windows-1251(1.9%) Shift JIS(1.1%) Windows-1252(1.0%) GB2312(0.9%)... {% asset_img Historical_yearly_trends_in_the_usage_of_character_encodings_for_websites.png website encoding trend%} Reference: 1. [The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)](http://www.joelonsoftware.com/articles/Unicode.html) 2. [使用 python urllib2 抓取网页时出现乱码的解决方案](http://www.zhxl.me/1409.html) 3. [用Python抓网页的注意事项](http://blog.csdn.net/wisha1989/article/details/19010539) 4. [python 模块 chardet下载方法及介绍](http://blog.csdn.net/aqwd2008/article/details/7506007) 5. [国外网站大全](http://www.qkankan.com/)]]></content>
      <categories>
        <category>python</category>
        <category>encoding</category>
      </categories>
      <tags>
        <tag>encoding</tag>
        <tag>unicode</tag>
        <tag>python</tag>
        <tag>charset</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汽车电池]]></title>
    <url>%2F2016%2F01%2F07%2FAutomative-lead-acid-battery-charging-voltage%2F</url>
    <content type="text"><![CDATA[title: 汽车电池 categories: - Automotive - Battery tags: - Automotive - Battery comments: true layout: post date: 2016-01-07 19:52:35 modified: 2017-08-30 19:52:35 --- 曹芳-遇见我 {% asset_img automative_battery.jpg %} 本文涉及的电池指可重复充、放电的铅酸蓄电池(Lead Acid Battery)。 # 词源 The word “battery” comes from the Old French word baterie, meaning “action of beating" relating to a group of cannons in battle. In the endeavor to find an energy storage device, scientists in the 1700s adopted the term battery to represent multiple electrochemical cells. Battery 这个词来自法语`Batteries`,最初的意思是`action of beating`，表示战斗中的加农炮。1700年代，科学家借用来表示可以存储能量的电化学装置。 # 汽车供电 ## 发电机 当用电设备所需电流IV小于发电机电流IG时，发电机输出电流就会有一部分作为充电电流IB给蓄电池充电。整车电气系统的电压随之上升，趋向于发电机调节器设定的电压值。 `发电机的额定电流`是发电机转速为6000 r/min时发电机能长期提供的电流。 对电压敏感的对小功率用电设备应靠近蓄电池端布置；对电压不敏感的较大功率用设备应靠近近发电机端布置。 ## 整车电流要求 起动车辆时，蓄电池的负载电流很高，可达300~500A。此时的压降会对某些用电设备造成负面影响，因此应尽可能减小车辆起动时整车电气系统的压降。而车辆行驶时，蓄电池的负载电流较小整车电气系统的电压能够维持在一个较高水平。 10~50mA 发动机/发电机停机状态下，整车电气系统的用电设备，如时钟、防盗报警装置或无线控制中央闭锁装置等 20~70A 发动机怠速工况或车辆低速行驶 300A 发动机启动过程要求持续0.3~3s 1000A 发动机启动过程峰值电流 # 起动蓄电池 ## 功能 起动蓄电池是整车电气系统中的电能存储装置。其主要功能是： 1. 随时为起动机提供电能。 2. 某些工况下，如怠速工况或发动机停机工况，发电机提供的电能不能满足整车电气系统的用电需求时，应该能补充不足的部分。 3. 抑制整车电气系统中的电压峰值效应，以保护对电压峰值效应敏感的电子部件和用电设备，如白炽灯、半导体器件等。 ## 简介 环境温度低时，发动机启动对蓄电池电流大小和持续时间的需求会明显提高，数值约为正常情况下的2倍。 12V蓄电池由6个单体电池串联而成；正极板的活性物质是多孔质的二氧化铅(PbO2，深棕色)，负极板上是多孔海绵状的纯铅(Pb,灰绿色金属)；外壳是聚丙烯。 BMS能够借助蓄电池参数(SOC/SOH/SOF等)优化充电电压，并在蓄电池性能退化时采取减少整车电气系统的负载(关闭用电设备) 和/或 增加加发电功率（如提供发动机怠速转速）的措施。 ## 安全 蓄电池系统必须设有气体排出装置，保证有害物质不会进入车内空间，而是被导入诸如车身的一根横梁中。此外，每个单电池或每个模块均装有过压阀，且排气口应被导出驾驶室。 ## 冷却 蓄电池的冷却有多种形式。其中一种形式是通过空调设备进行冷却；另一种是采用车厢内的空气对蓄电池进行冷却；还可以采用冷却液对蓄电池进行冷却。 ## 低温 当温度过低时，蓄电池系统的功率能力同样受到限制，此时需要对电池进行额外的加热。 一个充满电、电解液浓度为1.28kg/L的蓄电池，其电解液的冷凝点为-68~-60°C；放完电，电解液浓度为1.04kg/L的蓄电池，其电解液的冷凝点为-11~-3°C；环境温度很低时，电解液可能会凝固。 蓄电池的电解液为冷凝状态时，只能提供很小的电流，不能用于起动。 当蓄电池的电解液冷凝时，不可对其充电，因为充电时凝固电解液溶解而膨胀过快，有可能导致蓄电池壳发生破裂。因此，充电前必须解冻电解液。 ## 参数 1. 额定电压 2*6V=12V 2. 开路电压(OCV)和静止电压 只有等静止电压稳定之后，其值才可以用来估算蓄电池的荷电状态(SOC),而这个稳定过程可能需要若干天。 3. 内阻 在持续放电、低温(电解液浓度将增加)的情况下，蓄电池内阻将增大。 4. 端电压 低温或荷电状态差时，待负载的蓄电池的端电压将下降。 5. 气化电压 气化电压指某一个电压值，当蓄电池的充电电压超过该值时，蓄电池内将有气化现象发生。 对完全免维护蓄电池来说，0°C以下时，最高充电电压为16V，而30°C以上时为13.5V。 低温将影响电池的可充电性，因此低温时必须提高充电电压。高温和高电压将加剧蓄电池的水损耗和腐蚀（特别是腐蚀），因此高温时要选用较低的充电电压。 6. 容量 可放电容量与放电电流IE有关。在规定的放电终止电压下，放电电流越大，可放电容量越小。 1. 可用容量K 可用容量K是蓄电池在一定条件下可放出的电量，用电流大小与时间的乘积来计量，单位为安时(A*h)。 蓄电池的容量主要由选用的活性物质和电解液决定的。 2. 额定容量K20 规定启动蓄电池以20h连续放电至端电压降到10.5V时输出的电量为额定容量K20。 按照EN 50342，这些电量以一个固定电流值I20,在环境温蒂25°C(+-2°C)下放电20h，放电之放电终止电压10.5. I20=K20/20 举例，一个新的44Ah电池以2.2A的电流放电，至少放电20h，才能到10.5V。 7. 低温测试电流Icc 低温测试电流表示蓄电池在低温下的放电能力。按照EN 50342标准，环境温度为-18°C时，蓄电池以Icc放电10s后，最低端电压须不小于7.5V（1.25V/cell)。 8. SOH(State Of Health)健康状态 按照IEEE1188标准(针对VRLA)，当电池使用一段时间后，电池充满电时的容量低于电池额定容量的80%后，电池就应该被更换。根据这个标准，可以为SOH进行如下定义：在某一条件下电池可放出容量与新电池额定容量的比值 SOH=Qnow/Qnew*100% Qnow表示在当前的条件下，电池可以释放出的最大容量，Qnew表示新电池的额定容量. 9. SOC(State Of Charge)荷电状态 SOC用来表征电池的剩余容量。 从电量角度： SOC=QC/QI=1-Q/QI 其中，QC为电池剩余电量 QI为电池以恒定电流I放电时所具有的容量 Q为电池已经释放的电量。 从能量角度 SOC=WRemainder/WInitial=1-WDischarge/WInitial 其中，WRemainder为电池剩余电能，WDischarge为已经释放的电能，WInitial为电池的初始电能。 SOC估算方法： | SOC估算方法 | 优点 | 缺点 | |:-------------:|:------------------------:|:--------------------:| | 放电实验法 | 准确可靠 | 时间长，电池需脱机 | | 开路电压法 | 计算简单 | 需要长时间静置 | | 安时计量法 | 测量简单 | 需要有起始点 | | 线性模型法 | 模型简单 | 不够准确 | | 内阻法 | 电池放电后期，精度好 | 需要准确的电池模型 | | 卡尔曼滤波法 | 非线性模型 | 复杂 | | 神经网络法 | 精度高 | 需要大量的训练数据 | | 电解液浓度法 | 精度高 | 复杂 | ## 充电 {% asset_img charge_states_of_lead_acid_battery.jpg %} The correct setting of the charge voltage limit is critical and ranges from 2.30V to 2.45V per cell. Setting the voltage threshold is a compromise, and battery experts refer to this as “dancing on the head of a needle.” On one hand, the battery wants to be fully charged to get maximum capacity and avoid sulfation on the negative plate; on the other hand, an over-saturated condition causes grid corrosion on the positive plate and induces gassing. The temperature changes the voltage and this makes “dancing on the head of a needle” even more difficult. To get a complete charge and prevent overcharging, warmer temperature requires a slightly lower voltage threshold and colder temperature prefers a higher setting. Chargers exposed to temperature fluctuations should include temperature sensors to adjust the charge voltage for optimum charge efficiency. The charge temperature coefficient of a lead acid cell is -3mV/°C. Establishing 25°C (77°F) as the midpoint, the charge voltage should be reduced by 3mV per cell for every degree above 25°C and increased by 3mV per cell for every degree below 25°C. If this is not possible, it is better to choose a lower voltage for safety reasons. {% asset_img runbatt.jpg %} To charge the battery, the alternator voltage output has to exceed a minimum charging voltage. This minimum charging voltage is 13.8 volts dc across the battery terminals, or at the output of the alternator. A single lead-acid cell starts to charge at anything over 2.25 volts. Since a 12 volt battery has six cells, any 12 volt lead-acid battery needs at least 13.8 volts to start to charge. This voltage will be enough to fully charge or maintain the battery on a trickle charge, but charging time will be very long at 13.8 volts. To fully charge in reasonable times, alternator output must be 14.2 V to 14.5 V as measured right across the battery posts. Above 14.5 volts charging voltage, batteries have a greatly increased tendency to release excessive acidic vapors, hydrogen gas, and to corrode things around the battery. The battery terminal charging voltage must be less than 14.7 volts to prevent excessive gassing. Charging voltages over 14.7 volts can prematurely dry the battery by boiling out electrolyte, and increase risk of a battery hydrogen gas explosion. # 名词缩写 Generator 发电机 Alternator 交流发电机 Starter 起动机/马达 BMS(Battery Management System)电池管理系统 VRLA(Valve Regulated Lead Acid) 阀控式密封铅酸蓄电池 SOC(State Of Charge)电池荷电状态 SOH(State Of Heath)电池寿命状态 SOF(State Of Function)电池功能状态 OCV(Open Circuit Voltage)开路电压 electrode 电极 electrolyte 电解液 ion 离子 Lead Acid 铅酸 nickel 镍 lithium-ion(Li-ion) 锂离子 battery pack 电池组 battery cell 单体电池 Reference: 1. 《BOSCH汽车电气与电子》/(德)Reif,K.主编；孙泽昌译.-2版。北京理工大学出版社，2014.8 (ISBN 978-7-9005-0) 2. [Charging Lead Acid](http://batteryuniversity.com/learn/article/charging_the_lead_acid_battery) 3. [Test Your Charging and Electrical System](http://www.w8ji.com/battery_and_charging_system.htm) 4. [Batteries in a Portable World: A Handbook on Rechargeable Batteries for Non-engineers](http://www.amazon.com/Batteries-Portable-World-Rechargeable-Non-Engineers/dp/0968211836) 5. [为什么电动汽车电池不能精确显示剩余电量？](https://www.zhihu.com/question/24778938) 6. [IEEE-1188:2005](http://www.doc88.com/p-0876893178293.html) 7. [电池SOC估算策略研究](http://wenku.baidu.com/view/706aa9a44afe04a1b071de6a.html) 8. [动力电池的SOC估算](http://wenku.baidu.com/view/ce1f2de09b6648d7c0c74656.html)]]></content>
      <categories>
        <category>Automotive</category>
        <category>Battery</category>
      </categories>
      <tags>
        <tag>Automotive</tag>
        <tag>Battery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法对应的HTML标签实现]]></title>
    <url>%2F2015%2F12%2F30%2FMarkdown-html-compare%2F</url>
    <content type="text"><![CDATA[title: Markdown语法对应的HTML标签实现 categories: - Markdown - HTML tags: - Markdown - HTML comments: true layout: post date: 2015-12-30 14:09:11 modified: 2016-02-22 21:09:11 --- 邓紫棋-后会无期 最近学习HTML，这篇文章记录，用[Markdown](http://wuchenxu.github.io/2015/11/19/markdown-usage/)和HTML语法，来实现同一种标记。一方面来巩固HTML的语法，一方面来通过对比感受一下Markdown的简洁。 HTML(Hyper Text Markup Language)超文本标记语言，是万维网的基础，静态网页都是用HTML语言写就；Markdown也是一种标记语言，Markdown兼容HTML，但挑选了一些常用的语法比HTML更简单，Markdown只是一种书写语言，最终呈现在网页上的还是转换成HTML格式的。 # 标题 Headline 一共支持六级标题 ```html html 一级标题 二级标题 三级标题 ``` 一级标题 二级标题 三级标题 ```markdown markdown # 一级标题 ## 二级标题 ### 三级标题 ``` # 一级标题 ## 二级标题 ### 三级标题 # 文字格式 ## 斜体 Italic ```html html 这是斜体1 这是斜体2 ``` 这是斜体1 这是斜体2 ```markdown markdown *这是斜体1* _这是斜体2_ ``` *这是斜体1* _这是斜体2_ ## 粗体 Bold ```html html 这是粗体1 这是粗体2 ``` 这是粗体1 这是粗体2 ```markdown markdown **这是粗体1** __这是粗体2__ ``` **这是粗体1** __这是粗体2__ ## 引用 Quote ```html html 李商隐说:庄生晓梦迷蝴蝶。望帝春心托杜鹃。 ``` 李商隐说:庄生晓梦迷蝴蝶。望帝春心托杜鹃。 ```html html 李商隐说:庄生晓梦迷蝴蝶。望帝春心托杜鹃。 ``` 李商隐说:庄生晓梦迷蝴蝶。望帝春心托杜鹃。 ```markdown markdown > 李商隐说: >> 庄生晓梦迷蝴蝶。望帝春心托杜鹃。 ``` > 李商隐说: >> 庄生晓梦迷蝴蝶。望帝春心托杜鹃。 ## 删除线 Strikethrough ```html html This is strikethrough 1. This is strikethrough 2. ``` This is strikethrough 1. This is strikethrough 2. ```markdown GFM ~~This is strikethrough,only for GFM.~~ ``` ~~This is strikethrough,only for GFM.~~ ## 下划线 Underline ```html html 我带下划线1. 我带下划线2. ``` 我带下划线1. 我带下划线2. ## 上下标 ```html html 下标：H2O 上标：E=mc2 ``` 下标：H2O 上标：E=mc2 ## 字体 ```html html hello,个性化的格式。 ``` hello,个性化的格式。 ## 代码 Code ### 单行代码 ```html html var i=10; ``` var i=10; ```markdown markdown `var i=10;` ``` `var i=10;` ### 多行代码 ```html html if (isOK) { return true; } ``` if (isOK) { return true; } > \`\`\`c if (isOK) { return true; } \`\`\` ``` if (isOK) { return true; } ``` # 水平横线 ```html html ``` ```markdown markdown --- 我是分割线 *** ``` --- 我是分割线 *** # 列表 List ## 无序列表 Unordered List ```html ul-li标签 Coffee Tea Milk ``` CoffeeTeaMilk ```markdown markdown * Coffee * Tea * Milk ``` * Coffee * Tea * Milk ## 有序列表 Ordered List ```html ol-li标签 Coffee Tea Milk ``` CoffeeTeaMilk ```markdown markdown 2. Coffee 3. Tea 4. Milk ``` 2. Coffee 3. Tea 4. Milk # 链接 Link ## 文字 ```html html chenxu's blog ``` chenxu's blog ```markdown markdown [chenxu's blog](wuchenxu.github.io) ``` [chenxu's blog](wuchenxu.github.io) ## 图片 ```html html ``` html支持图片高度、宽度等属性的设置，markdown暂不支持此类属性的设置。 ```markdown markdown ![github](https://github.com/images/modules/contact/heartocat.png) ``` ![github](https://github.com/images/modules/contact/heartocat.png) ## 图片嵌入链接 ```html html ``` ```markdown markdown [![github](https://github.com/images/modules/contact/heartocat.png)](http://wuchenxu.github.io) ``` [![github](https://github.com/images/modules/contact/heartocat.png)](http://wuchenxu.github.io) # 表格 Table ```html html 成绩统计 班级 学生数 平均成绩 一班 30 89 二班 35 85 ``` 成绩统计 班级学生数平均成绩 一班3089 二班3585 html表格支持boder宽度，对齐，单元格填充，单元格间距，背景图片，单元格跨行跨列等属性设置； 原生markdown并不支持表格，在[GFM](https://guides.github.com/features/mastering-markdown/)支持一种简单的表格语法。 [神器-表格生成工具](http://www.tablesgenerator.com/) ```markdown GFM | 班级 | 学生数 | 平均成绩 | |--------|:----------------:|----------:| | 一班 | 30 | 89 | | 二班 | 35 | 85 | ``` | 班级 | 学生数 | 平均成绩 | |--------|:----------------:|----------:| | 一班 | 30 | 89 | | 二班 | 35 | 85 | Reference: 1. [html](http://www.w3school.com.cn/) 2. [imooc](http://www.imooc.com/learn/9)]]></content>
      <categories>
        <category>Markdown</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人博客搭建hexo+github(7):显示每篇文章的更新时间]]></title>
    <url>%2F2015%2F12%2F13%2FStatic-Blog-hexo-github-7-display-updated-date%2F</url>
    <content type="text"><![CDATA[title: '个人博客搭建hexo+github(7):显示每篇文章的更新时间' categories: - hexo tags: [hexo, github, blog] comments: true layout: post date: 2015-12-13 20:18:54 modified: 2015-12-28 20:18:54 --- 纪晓君-爱延续 如果要显示每篇文章的更新时间，需要修改主题的js代码，通过以下步骤，可以通过主题配置文件选择显示或者不显示更新时间。 # 主题代码 对于Next主题，在`hexo/themes/hexo-theme-next/layout/_macro/post.swig`文件里，` `标签后增加 ```swig hexo/themes/hexo-theme-next/layout/_macro/post.swig {%if post.updated and post.updated > post.date%} &nbsp; | &nbsp; {{ __('post.updated') }} {{ date(post.updated, config.date_format) }} {% endif %} ``` `post-updated`用来访问对应的语言配置文件里的值，`theme.`来访问主题配置文件的变量，`post.`来访问每篇文章的前置设置([Front Matter](https://hexo.io/docs/front-matter.html))里的变量。 代码里需要保证updated的时间是date之后才会显示 # 语言配置文件 增加post下updated的配置 ```yml hexo/themes/hexo-theme-next/languages/zh-Hans.yml post: updated: 更新于 ``` # 主题配置文件 增加一行 ```yml hexo/themes/hexo-theme-next/_config.yml display_updated: true ``` # 文章的前置设置 在文章的开头增加 ``` updated: 2015-12-13 20:18:54 ``` 然后重新`hexo g`一下就可以看到效果了。 Reference: 1. [Landscape-F](http://howiefh.github.io/2014/04/20/hexo-optimize-and-my-theme-landscape-f/) 2. [Front Matter](https://hexo.io/docs/front-matter.html)]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人博客搭建hexo+github(6):标签插件]]></title>
    <url>%2F2015%2F12%2F08%2FStatic-Blog-hexo-github-6-tag-plugins%2F</url>
    <content type="text"><![CDATA[title: 个人博客搭建hexo+github(6):标签插件 categories: - hexo tags: [hexo, github, blog] comments: true layout: post date: 2015-12-08 21:56:39 modified: 2015-12-13 21:56:39 --- 标签插件(tag plugins)是hexo用于在文章中快速插入特定内容的插件。 hexo的很多插件类似octopress，有些插件的使用方法官方文档没有octopress的文档详细。 有些tag，markdown的语法就能实现类似的效果就使用更通用的markdown，按照我的使用先后来记录，慢慢补齐。 我使用的hexo版本是3.1.1 # Include Code 插入代码，这个是可以把整个文件作为代码插入，这样做的好处是作为可运行的代码后续如果修正了bug，重新`hexo g`一下文章中的代码就会自动更新；不需要每次从文件中拷贝粘贴代码到文章中。 ## 配置code存放路径 在hexo的配置文件`hexo/_config.yml`中看到`code_dir: downloads/code`,说明所有的code文件都放到`source/downloads/code`文件夹下。 ## 语法 ``` {% include_code [title] [lang:language] path/to/file %} ``` `[title]`:可选，标题名，默认是文件名 `[lang:language]`:可选设置语言后，根据不同的语言设置语法高亮 ## 举例 代码文件存放在`source/downloads/code/hello_world.c`. ``` {% include_code lang:c hello world in c lang hello_world.c %} ``` {% include_code lang:c hello world in c lang hello_world.c %} # frame To embed an iframe: ``` {% iframe url [width] [height] %} ``` 当然也可以直接插入HTML格式的标签。 ```html ``` Reference: 1. [tag plugins in hexo doc](https://hexo.io/docs/tag-plugins.html) 1. [octopress include code](http://octopress.org/docs/plugins/include-code/)]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CRC8计算]]></title>
    <url>%2F2015%2F12%2F07%2FCRC8-calculate%2F</url>
    <content type="text"><![CDATA[title: CRC8计算 categories: - checksum - CRC tags: - CRC comments: true layout: post date: 2015-12-07 23:13:08 modified: 2015-12-11 23:13:08 --- # CRC简介 CRC(Cyclic Redundancy Check),循环冗余校验码，是一种错误检测码，可以检错，但不能纠错。 CRC算法对数据进行多项式计算，并将得到的校验码(固定位数)附在数据的后面，接收设备也执行类似的算法，以保证数据传输的正确性和完整性。 不同的多项式对错误的检测率(以汉明距离(Hamming Distance)衡量)有差别，所以多项式都是经过测试精心挑选的。 多项式决定了校验码的位数，根据校验码位数不同，一般有CRC-4,CRC-8,CRC-16,CRC-32，CRC-64，CRC-128等。 # CRC算法 以CRC-8来举例： CRC-8，有8bit的校验码，取多项式(Polynomial)为:x^8+x^4+x^3+x^2+1。一般多项式最高位x^8项的系数总是1，所以隐去，标记为1Dh(1 1101b)。 将数据与多项式相除，得到的余数再与多项式相除，如此反复，所以叫循环冗余，最终得到一个8位的余数就是循环冗余校验码。 二进制的除与异或的结果一样。 1Dh也是SAE-J1850推荐的多项式；2Fh是AUTOSAR CRC-8推荐的另一个多项式。 数据:F2 01 83 binary: 11110010 00000001 10000011 00000000]]></content>
      <categories>
        <category>checksum</category>
        <category>CRC</category>
      </categories>
      <tags>
        <tag>CRC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CAN总线字节序]]></title>
    <url>%2F2015%2F12%2F03%2FCAN-byte-order%2F</url>
    <content type="text"><![CDATA[title: CAN总线字节序 categories: - encoding - CAN tags: [encoding, byte order, bit order, software, Motorola, Intel, MSB, LSB] comments: true layout: post date: 2015-12-03 20:14:13 modified: 2016-08-09 20:14:13 --- # CAN总线格式 {% asset_img CAN-Frame_mit_Pegeln_mit_Stuffbits.svg.png %} > IDENTIFIER The IDENTIFIER's length is 11 bits. These bits are transmitted in the order from ID-10 to ID-0. The least significant bit is ID-0. > DATA FIELD The DATA FIELD consists of the data to be transferred within a DATA FRAME. It can contain from 0 to 8 bytes, which each contain 8 bits which are transferred MSB first. 从CAN总线的规范可以看出，总线的位序(bit order)msb first,大端模式，也称为递减位序（Decreasing bit order）。 | msb | ... | ... | ... | ... | ... | ... | lsb | |:------:|:------:|:-------:|:------:|:------:|:------:|:------:|:----------:| 但是总线没有规定DATA FIELD的字节序，这是上层协议的范畴。 # Motorola格式与Intel格式 在进行CAN总线通信设计时，对CAN总线信号有两种编码格式：Motorola与Intel格式。 两者并无优劣之分，只是设计者的习惯选择。 一般情况下，主机厂在定义CAN总线信号时，会明确定义字节的发送顺序，LSB(byte)先发,还是MSB先发。 ## Motolora格式(big endian) | MSB | ... | ... | LSB | |:----------:|:----------:|:----------:|:----------:| ## Intel格式(little endian) | LSB | ... | ... | MSB | |:----------:|:----------:|:----------:|:----------:| ## 位计数的方法 ### 锯齿(Sawtooth)法 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 | 15| 14| 13| 12| 11| 10| 9 | 8 | |:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:| 发送一个8字节的数据到总线上，bit7（msb of Byte0）最先发送，接着是bit6，bit56（lsb of Byte7）最后发送。 ### 顺序(Sequential)法 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10| 11| 12| 13| 14|15 | |:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:| 发送一个8字节的数据到总线上，bit0（msb of Byte0）最先发送，接着是bit2，bit63（lsb of Byte7）最后发送。 CANoe中一般用锯齿法。 而对于跨字节的数据，CANoe表示格式（这两种格式只针对字节序，位序总是msb first的）： * Intel格式（LSB first）的lsb从低字节地址的低位地址开始，向左排布，msb在高字节地址的高位地址 * Motorola格式（MSB first）的lsb从高字节地址的低位地址开始，向左排布，msb在低字节地址的高位地址。 实际总线传输按照msb first，从Byte0的bit7开始，bit6, ..., 到Byte1的bit15，bit14, ... , 到Byte7的bit63, ... , bit62, ..., bit56. {% asset_img Intel_Motorola_format_in_CANoe.png %} start bit总是指lsb的位置，然后向左排布，需要跨字节时：Intel格式从Byte0向Byte7的方向排布，Motorola格式从Byte7向Byte0的方向排布。 # 缩写: msb:most significant bit lsb:most significant bit MSB:Most Significant Byte LSB:Least Significant Byte Reference: 1. [CAN Bus wiki](https://en.wikipedia.org/wiki/CAN_bus) 2. CANoe help]]></content>
      <categories>
        <category>encoding</category>
        <category>CAN</category>
      </categories>
      <tags>
        <tag>encoding</tag>
        <tag>software</tag>
        <tag>byte order</tag>
        <tag>bit order</tag>
        <tag>Motorola</tag>
        <tag>Intel</tag>
        <tag>MSB</tag>
        <tag>LSB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字节序与大小端]]></title>
    <url>%2F2015%2F11%2F29%2Fbyte-bit-endian%2F</url>
    <content type="text"><![CDATA[title: 字节序与大小端 categories: - encoding tags: [encoding, byte order, bit order, software, Motorola, Intel, MSB, LSB] comments: true layout: post date: 2015-11-29 21:08:43 modified: 2016-11-22 21:08:43 --- {% asset_img endian_of_picture.jpg %} # 概述 我们书写的规则一般是从左往右，如写一个数字`一千二百三十四`，写成`1234`.这是日常生活中约定俗称的表示方法，其背后的逻辑是最高有效位在最左边，1表示`1千`是最高有效位，其在最左；如果我们约定最低有效位在最左，那么同样表示`一千二百三十四`，我们需要写成`4321`了。 在计算机领域，特别是在存储和通信领域，一般以字节为单位存储或者传输数据，那么对于多字节数据的`字节序`(Byte Order)表示就有两种方法： > 大端(big endian): 最高有效字节(MSB:Most Significant Byte)存储在最低地址(LBA: Lowest Byte Address)。 > 小端(little endian): 最高有效字节存储在最高地址(HBA:Highest Byte Address)。 同样对于一个字节的8个位的`位序(Bit Order)`也有两种表示方法： > 大端(big endian): 最高有效位(msb:Most Significant Bit)存储在最低地址(LBA: Lowest Byte Address)。 > 小端(little endian): 最高有效位存储在最高地址(HBA:Highest Byte Address)。 > 对于给定一个计算机系统`位序`一般与`字节序`相同。 如果我们认为日常书写数字是从低地址开始写的，那么可以说，我们的书写规则是遵从大端规则的。 # 表示方法 {% asset_img endian_in_computer.gif %} 我们用大端和小端两种形式来表示同一个数`0x0A0B0C0D`. 大端系统： | byte addr | 0 | 1 | 2 | 3 | |:----------:|:----------:|:----------:|:----------:|:----------:| | bit offset | 01234567 | 01234567 | 01234567 | 01234567 | | binary | 00001010 | 00001011 | 00001100 | 00001101 | | hex | 0A | 0B | 0C | 0D | 小端系统： | byte addr | 3 | 2 | 1 | 0 | |:----------:|:----------:|:----------:|:----------:|:----------:| | bit offset | 76543210 | 76543210 | 76543210 | 76543210 | | binary | 00001010 | 00001011 | 00001100 | 00001101 | | hex | 0A | 0B | 0C | 0D | 以上两种表示方法，我们都可以一目了然看出0x0A0B0C0D。 如果我们保持byte address和bit offset不变，小端系统也可以表示成： | byte addr | 0 | 1 | 2 | 3 | |:----------:|:----------:|:----------:|:----------:|:----------:| | bit offset | 01234567 | 01234567 | 01234567 | 01234567 | | binary | 10110000 | 00110000 | 11010000 | 01010000 | 这样不去计算，不能一眼看出表示的数是0x0A0B0C0D. # CPU的大小端 CPU的大小端一般指寄存器，总线，cache及内存等的字节序和位序。 小端CPU包括Intel(x86等)和DEC，小端格式也称为`Intel格式`。 大端CPU包括Motorola，Sun Spark以及IBM(PowerPC)，大端格式也称为`Motorola格式`。 MIPS和ARM可以配置成任意一种。 CPU的大小端影响到CPU的指令集，不同的字节序CPU需要不一样的GNU工具链编译器。如，mipse-linux-gcc是支持大端mips架构的编译器，mipsl-linux-gcc是支持小端架构的编译器。 CPU的大小端会影响到软件访问多字节数据，虽然大多数时候对CPU大小端对软件是透明的。 如下代码，在不同字节序的CPU上运行会得到不同的结果。 ```c union { uint32_t my_int; uint8_t my_bytes[4]; } endian_tester; endian_tester et; et.my_int = 0x0a0b0c0d; if(et.my_bytes[0] == 0x0a) { printf( "I'm on a big-endian system\n" ); } else { printf( "I'm on a little-endian system\n" ); } ``` # 总线的大小端 这里的总线不包括CPU内部的地址总线和数据总线等，专指外部总线，指器件之间的通讯总线。 对于并行总线(如PCI)，如果是小端，则在32位的地址/数据总线AD[31:0],MSB连接到AD31，LSB连接到AD0。 对于串行总线，只存在协议上的大小端，不存在总线的大小端。 # Device的大小端 > Kevin's Theory #1: When a multi-byte data unit travels across the boundary of two reverse endian systems, the conversion is made such that memory contiguousness to the unit is preserved. > Kevin's Theory #2: In a C structure that contains bit fields, if field A is defined in front of field B, then field A always occupies a lower bit address than field B. 以NIC为例，vlan[0:24]有一个0xabcdef的值通过32位的存储边界(memory boundary),大端系统中： | byte addr | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | |:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:| | bit offset | 01234567 | 01234567 | 01234567 | 01234567 | 01234567 | 01234567 | 01234567 | 01234567 | | binary | 10101010 | 10 010111 | 10101011 | 11001101 | 11101111 | 00000000 | 00000000 | 00000000 | | hex | aa | 97 | ab | cd | ef | 00 | 00 | 00 | tag[0:9]=bit[0:9]=0x2aa,rx[0:5]=bit[10:15]=0x17,vlan[0:15]=bit[16:23]=0xabcdef. 如果按照字长一致原则转换到小端系统中，字长位32bit： | byte addr | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 | |:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:| | bit offset | 76543210 | 76543210 | 76543210 | 76543210 | 76543210 | 76543210 | 76543210 | 76543210 | | binary | 11101111 | 00000000 | 00000000 | 00000000 | 10101010 | 10 010111 | 10101011 | 11001101 | | hex | ef | 00 | 00 | 00 | aa | 97 | ab | cd | 字长转换造成存储地址不连续问题。 按照字节一致原则转换到小端系统中： | byte addr | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 | |:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:| | bit offset | 76543210 | 76543210 | 76543210 | 76543210 | 76543210 | 76543210 | 76543210 | 76543210 | | binary | 00000000 | 00000000 | 00000000 | 11101111 | 11001101 | 10101011 | 10010111 | 10 101010 | | hex | 00 | 00 | 00 | ef | cd | ab | 97 | aa | 为得到与大端系统中一致的数据位，还需要软件再做一个字节交换(byte swap)： | byte addr | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 | |:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:| | bit offset | 76543210 | 76543210 | 76543210 | 76543210 | 76543210 | 76543210 | 76543210 | 76543210 | | binary | 00000000 | 00000000 | 00000000 | 10 101010 | 10010111 | 10101011 | 11001101 | 11101111 | | hex | 00 | 00 | 00 | aa | 97 | ab | cd | ef | 根据Kevin's Theory #2，我们可以定义C结构体来访问小端模式的NIC的标识符： ```c struct nic_tag_reg { uint64_t vlan:24 __attribute__((packed)); uint64_t rx :6 __attribute__((packed)); uint64_t tag :10 __attribute__((packed)); }; ``` 大端模式下： ```c struct nic_tag_reg { uint64_t tag :10 __attribute__((packed)); uint64_t rx :6 __attribute__((packed)); uint64_t vlan:24 __attribute__((packed)); }; ``` # 协议的大小端 对于硬线上发送接收的位顺序，通常有规范来定义，不一定与上层的协议字节序一致，硬件会做相应的转换工作。 我们通常所说的网络字节序值网络传输协议的字节序，如IP协议数据按照大端字节序发送接收。 网络(network)字节序与本机(host)字节序不一致时，需要进行转换。如 htons/ntohs/ntohl/htonl等函数。 # 词源 > 据Jargon File记载，endian这个词来源于Jonathan Swift在1726年写的讽刺小说 "Gulliver's Travels"（《格利佛游记》）。该小说在描述Gulliver畅游小人国时碰到了如下的一个场景。在小人国里的小人因为非常小（身高6英寸）所以总是碰到一些意想不到的问题。有一次因为对水煮蛋该从大的一端（Big-End）剥开还是小的一端（Little-End）剥开的争论而引发了一场战争，并形成了两支截然对立的队伍：支持从大的一端剥开的人Swift就称作Big-Endians，而支持从小的一端剥开的人就称作Little-Endians......（后缀ian表明的就是支持某种观点的人）。 > 1980年，Danny Cohen在其著名的论文"On Holy Wars and a Plea for Peace"中为了平息一场关于在消息中字节该以什么样的顺序进行传送的争论而引用了该词。该文中，Cohen非常形象贴切地把支持从一个消息序列的最高位开始传送的那伙人叫做Big-Endians，支持从最低位开始传送的相对应地叫做Little-Endians。此后Endian这个词便随着这篇论文而被广为采用。 Reference: 1. [Byte and Bit Order Dissection](http://www.linuxjournal.com/node/6788/print) 2. [Endian_baiduBaike](http://baike.baidu.com/view/633653.htm) 3. [byte oreder……](http://www.ruanyifeng.com/blog/2016/11/byte-order.html)]]></content>
      <categories>
        <category>encoding</category>
      </categories>
      <tags>
        <tag>encoding</tag>
        <tag>software</tag>
        <tag>byte order</tag>
        <tag>bit order</tag>
        <tag>Motorola</tag>
        <tag>Intel</tag>
        <tag>MSB</tag>
        <tag>LSB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人博客搭建hexo+github(5):Hexo写作实用技巧]]></title>
    <url>%2F2015%2F11%2F23%2FStatic-Blog-hexo-github-5-hexo-usage-trick%2F</url>
    <content type="text"><![CDATA[title: 个人博客搭建hexo+github(5):Hexo写作实用技巧 date: 2015-11-23 22:06:58 modified: 2016-06-13 categories: - hexo tags: [hexo, github, blog, music, video] --- # 文章名字 Hexo的文章放在`hexo/source/_post`文件夹，命令为`post_name.md`，post_name用英文的话，那么在生成html文件名就是英文名， 如果是中文，生成的html名字是unicode形式，浏览器地址栏完全不可读。 *** # 插入图片 Markdown语法 ``` ![Alt text](/path/to/image.png) ``` 这里的图片路径怎么理解： 如果是本地地址，上传到github如何显示？ 如果是网络地址（专业名字叫[图床](http://baike.baidu.com/view/620100.htm))，不上网时本地也无法显示？ 在hexo2中标签插件用法参见[asset_folder](http://timnew.me/blog/2014/08/19/use-hexo-asset-folder-to-manage-resource-used-by-post/)； 在hexo3中，配置文件中设置 ``` post_asset_folder: true ``` 当生效后，在你创建文章的时候，Hexo会创建一个同名目录，你可以将该文章关联的资源全部放到该目录下。这样就可以更加方便的使用它们了。 ``` {% asset_path slug %} {% asset_img slug [title] %} {% asset_link slug [title] %} ``` Usage: Suppose you have the following folder structure: ``` source\ _posts\ 2014-08-15-a-simple-self-introduction.md 2014-08-15-a-simple-self-introduction\ my_portrait.jpg my_resume.pdf ``` In the markdown file 2014-08-15-a-simple-self-introduction.md, you can reference files as ``` {% asset_img my_portrait.jpg %} {% asset_link my_resume.pdf My Resume %} ``` It generates ``` My Resume ``` *** # 显示摘要 在md文件的前置声明中，不要设置description，否则description的内容就是文章摘要。 在文章中插入 ``` ``` more之前的内容会作为摘要显示，more之后的内容，需要点击`阅读全文>>`查看。 # 插入音乐 以下的例子都是从主流音乐网站直接生成链接，不需要自己制作外链，所以有些音乐因为版权问题是不支持生成外链的。 ## 网易云音乐 搜索歌曲，找到`生成外链播放器`,复制生成的代码粘贴到md文件即可。 {% asset_img music_163.png %} `auto`设置成0，否则会自动播放。 ``` ``` ## 虾米音乐 找到歌曲，找到`转帖到其他网站`，复制生成的代码粘贴到md文件即可。 {% asset_img xiami_music.png %} ``` ``` # 插入视频 在视频网站，找到分享，复制通用代码即可。 `allowfullscreen`设置是否允许全屏。 ``` ``` 试了一下爱奇艺，不支持取消自动播放。 Reference: 1. [asset用法](https://github.com/timnew/hexo-tag-asset-res) 2. [插入music video](http://zipperary.com/2013/06/27/media-on-hexo/)]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>blog</tag>
        <tag>music</tag>
        <tag>video</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[标记语言Markdown使用说明]]></title>
    <url>%2F2015%2F11%2F19%2Fmarkdown-usage%2F</url>
    <content type="text"><![CDATA[title: 标记语言Markdown使用说明 date: 2015-11-19 23:23:00 modified: 2017-04-26 21:20:05 categories: - Markdown tags: [Markdown] --- {% asset_img markdown_logo.jpg %} # Markdown是什么 >Markdown是一种网络书写语言，兼容HTML但比HTML简单， >没有很多标签或者格式指令，可以直接以纯文本形式书写或者发布。 >Markdown精挑细选了一些语法，其宗旨是易读易写。 可以体验一下在线的Markdown编辑器，如[mahua在线Markdown](http://mahua.jser.me/)。 # 基础语法 基础语法指官方版本Markdown支持的语法，GFM(Github Flavored Markdown)是github对Markdown语法的一些扩展。 ## 1. 标题 开头的最后一个`#`与标题之间必须有空格。 {% asset_img header.png %} ## 文字格式 符号与文字之间不能有空格。 引用'>'后的空格不能少, 引用行之后要空一行，否则之后的行都算是引用了。 ``` *This text will be italic* _This will also be italic_ **This text will be bold** __This will also be bold__ _You **can** combine them_ > This is quote >> This is quote's quote ~~This is strikethrough,only for GFM.~~ ``` 效果： *This text will be italic* _This will also be italic_ **This text will be bold** __This will also be bold__ _You **can** combine them_ > This is quote >> This is quote's quote ~~This is strikethrough,only for GFM.~~ ## 列表 List ### 1. 无序列表 Unordered List `*` `+` `-`之后的空格不能少。 对嵌套列表，符号之后和之前的空格都不能少。 ``` * One + Two - Two Point One * Two Point Two - Three ``` 效果: * One + Two - Two Point One * Two Point Two - Three ### 有序列表 Ordered List `.`后的空格不能少。 ``` 1. One 2. Two 1. Two Point One 2. Two Point Two 9. Three ``` 1. One 2. Two * Two Point One * Two Point Two 3. Three ## 链接 Link ### 文字链接 `" "`里的内容可省略。 ``` http://wuchenxu.github.io -automatic! [blog](http://wuchenxu.github.io "chenxu's blog") ``` http://wuchenxu.github.io -automatic! [blog](http://wuchenxu.github.io "chenxu's blog") ### 图片链接 设置大小对齐，需要使用HTML, `" "`可以省略。 ``` ![Image of Yaktocat](https://octodex.github.com/images/yaktocat.png "Yaktocat") ``` ![Image of Yaktocat](https://octodex.github.com/images/yaktocat.png "Yaktocat") ### 图片嵌入超链接 ``` [![](http://github.global.ssl.fastly.net/images/modules/logos_page/GitHub-Mark.png)](http://www.github.com "link to github") ``` [![](http://github.global.ssl.fastly.net/images/modules/logos_page/GitHub-Mark.png)](http://www.github.com "link to github") ### 索引链接 `^1` `^2`可以是任意字符。 ``` [blog][^1] ![GitHub Octocat][^2] [^1]: http://wuchenxu.github.io [^2]: http://github.global.ssl.fastly.net/images/modules/logos_page/Octocat.png ``` [blog][^1] ![GitHub Octocat][^2] [^1]: http://wuchenxu.github.io [^2]: http://github.global.ssl.fastly.net/images/modules/logos_page/Octocat.png ### 脚标 `^ref`可以是任意字符。 ```markdown Ref[^ref] [^ref]: your-link ``` Ref[^ref] [^ref]: your-link ## 代码 Code > \`code\` `code` > \`\`\` if (isOK) { return true; } \`\`\` ``` if (isOK) { return true; } ``` ### 页内链接Anchor #### markdown目录 ``` 1.标题 # format output 2.引用标题 [上一节](#format-output) ``` #### html标签 ``` 1. 先定义一个锚(id) Hello World 2. 然后使用markdown的语法 [XXXX](#jump) ``` ## 分割线 三个或者更过的`-`或者`*`,必须单独成行，可以有空格 ``` - - - hello * * * ``` - - - hello * * * # GFM语法 GFM(Github Flavored Markdown)是github对Markdown语法的一些扩展,官方版本的Markdown不支持以下语法。 ## 表格 Table 官方版本的Markdown语法是不支持表格的，由于兼容HTML，可以使用``标签来表示table。但是，有一些Markdown的语法扩展支持简单的表格(Simple Table)。 如[Markdown Here](http://markdown-here.com/),Github支持简单表格,推荐使用[table generator](http://www.tablesgenerator.com/markdown_tables)来生成表格。 GFM的语法很简单，不支持行或者列的合并，不支持一个单元格的多行文字。 第一行是标题，第二行是固定的`-`，冒号`:`是来表示对齐方式。 `表格前或后必须有空行`. ``` | Tables | Are | Cool | |----------|:-------------:|------:| | col 1 is | left-aligned | $1600 | | col 2 is | centered | $12 | | col 3 is | right-aligned | $1 | ``` 效果： | Tables | Are | Cool | |----------|:-------------:|------:| | col 1 is | left-aligned | $1600 | | col 2 is | centered | $12 | | col 3 is | right-aligned | $1 | ## 语法高亮 Syntax Highlighting > \`\`\`javascript function fancyAlert(arg) { if(arg) { $.facebox({div:'#foo'}) } } \`\`\` ```javascript function fancyAlert(arg) { if(arg) { $.facebox({div:'#foo'}) } } ``` ## 任务列表 Task List ``` - [x] This is a complete item - [x] task 1 - [x] task 2 - [ ] This is an incomplete item ``` - [x] This is a complete item - [x] task 1 - [x] task 2 - [ ] This is an incomplete item ## 表情 Emoji 体验一下[2015牛津年度英语单词](http://www.emoji-cheat-sheet.com/) 笑cry ``` :joy: ``` :joy: # 进阶 [科技写作用Markdown+R](http://www.jianshu.com/p/PpDNMG) 可以生成各种公式图片图表。 Reference: 1. [翻译markdown 语法说明](http://www.appinn.com/markdown/) 1. [table generator](http://www.tablesgenerator.com/markdown_tables) 1. [official markdown](http://daringfireball.net/projects/markdown/syntax) 1. [mahua在线Markdown](http://mahua.jser.me/) 1. [Github Flavored Markdown](https://guides.github.com/features/mastering-markdown/) 1. [Emoji Cheat Sheet](http://www.emoji-cheat-sheet.com/) 1. [anchors](https://roachhd.gitbooks.io/master-markdown/content/syntax/anchors.html)]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BCD码]]></title>
    <url>%2F2015%2F11%2F18%2FBCD-CODE%2F</url>
    <content type="text"><![CDATA[title: BCD码 date: 2015-11-18 17:48:13 categories: encoding tags: [encoding, software, computing, electronic] --- {% asset_img 500px-Binary_clock.svg.png %} ## 概述 标记方法: 十进制数: `'1234'd`中 个位数字4，十位数字3，百位数字2，千位数字1，都是十进制数的一位，称为十进制位。 BCD(Binary Coded Decimal)码，是指用二进制数对十进制数进行的编码，每个十进制位由一个固定bit的二进制数表示。 > 非压缩BCD(unpacked BCD): 指一个字节(8 bits)表示一个十进制位。 > 压缩BCD(pBCD(packed BCD)): 指半字节(nibble, 4 bits)表示一个十进制位。 当然也有一些特殊模式来表示符号位或者错误、溢出等其他信息。 ## 基础 Basics 最常见的BCD码称为8421码，用4个bit来表示一个十进制位，这种BCD也称为"natural BCD(NBCD)". 还有其他编码方式，如"4221" 或者 "7421". 这些表示方法的命名方法使用了每个位的权重(weighting)。 |*Decimal Digit*|*BCD 8421*|*BCD 4221*|*BCD 8 4 -2 -1*|*ASCII 8421*| |:-------------:|:--------:|:--------:|:-------------:|:----------:| | 0 | 0 0 0 0 | 0 0 0 0 | 0 0 0 0 | 00110000 | | 1 | 0 0 0 1 | 0 0 0 1 | 0 1 1 1 | 00110001 | | 2 | 0 0 1 0 | 0 0 1 0 | 0 1 1 0 | 00110010 | | 3 | 0 0 1 1 | 0 0 1 1 | 0 1 0 1 | 00110011 | | 4 | 0 1 0 0 | 1 0 0 0 | 0 1 0 0 | 00110100 | | 5 | 0 1 0 1 | 1 0 0 1 | 1 0 1 1 | 00110101 | | 6 | 0 1 1 0 | 1 1 0 0 | 1 0 1 0 | 00110110 | | 7 | 0 1 1 1 | 1 1 0 1 | 1 0 0 1 | 00110111 | | 8 | 1 0 0 0 | 1 1 1 0 | 1 0 0 0 | 00111000 | | 9 | 1 0 0 1 | 1 1 1 1 | 1 1 1 1 | 00111001 | 非压缩BCD使用8个bit来表示1个十进制位： ``` Decimal: 6 2 8 Binary : 00000110 00000010 00001000 ``` 在非压缩BCD中高4位全是0，可以记为`00008412码`; 压缩BCD利用了8421码只使用4为就可以表示0-9，所以只用4位表示一个十进制位，压缩了数据, 提高了压缩效率。 ``` Decimal: 6 2 8 Binary : 0000 0110 0010 1000 ``` 由于计算机中以字节为最小访问单位，压缩BCD中半字节需要补全为一个字节。如上例中628，其实是0628. ## 有符号数 Signed Integer ### 非压缩BCD表示方法 `S0008421BCD`的最高bit位是符号位，为0认为是正数，为1则为负数。 ``` Decimal: -13 Binary : 10000001 00000011 ``` ### 压缩BCD表示方法 对于有符号数，需要用一个半字节来表示符号。 | *Sign Digit* | *BCD 8421* | *Sign* | *Note* | |:------------:|:----------:|:------:|:------:| | A | 1 0 1 0 | + | | | B | 1 0 1 1 | - | | | C | 1 1 0 0 | + | EBCDIC | | D | 1 1 0 1 | - | EBCDIC | | E | 1 1 1 0 | + | | | F | 1 1 1 1 | - | | EBCDIC字符集使用C为+，D为-,使用大端模式，最低半字节表示符号。 ``` number: -1234 Decimal: 1 2 3 4 - Binary : 0001 0010 0011 0100 1101 ``` ## 浮点数 Float 浮点数可以使用约定俗成的方法来表示，如约定小数点后只有2位。 123C表示+1.23；100D表示+1.00 ## 应用 在一些时钟芯片的寄存器采用BCD码形式输出。0x12,0x34,0x56可以表示12:34:56. 如M41T0 real time clock的日期和时间格式都是以压缩BCD码表示。 {% asset_img M41T_rt_bcd_reg.png %} Reference: 1. [BCD wiki](https://en.wikipedia.org/wiki/Binary-coded_decimal)]]></content>
      <categories>
        <category>encoding</category>
      </categories>
      <tags>
        <tag>encoding</tag>
        <tag>software</tag>
        <tag>computing</tag>
        <tag>electronic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[天猫魔盒安装视频APP]]></title>
    <url>%2F2015%2F11%2F11%2FTmall-Box-Install-other-video-app%2F</url>
    <content type="text"><![CDATA[title: 天猫魔盒安装视频APP date: 2015-11-11 23:25:00 categories: APP tags: [Tool, APP, Video] --- 1. 视频APP的TV版不能使用 总局封掉了盒子们的视频APP，所以盒子们默认不能安装youku、爱奇艺等视频app。这难不倒向往外面的世界的人们。 2. 安装电视猫 从度娘上得知一款叫做 `电视猫`的APP，官网上说支持各种盒子们，亲测天猫魔盒可用。 [![](http://www.moretv.com.cn/sources/img/logo.png)](http://www.moretv.com.cn) 具体安装过程见 [电视猫官网][moretv] 大体过程：下载apk -> 拷贝到U盘 -> 盒子U盘安装apk 测试的天猫魔盒: 设备型号:TMB100A 系统版本:2.1.0-R-20141214.1729 3. 安装其他APP 电视猫的应用里有其他的APP，可以直接安装。 亲测可以安装破解版youku、腾讯视频以及爱奇艺，且可用。 还可以下载`全家盒市场`等应用市场，从应用市场里可以安装更多的TV版APP。 [moretv]: http://www.moretv.com.cn "电视猫官网"]]></content>
      <categories>
        <category>APP</category>
      </categories>
      <tags>
        <tag>Tool</tag>
        <tag>APP</tag>
        <tag>Video</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人博客搭建hexo+github(4):进阶配置]]></title>
    <url>%2F2015%2F11%2F09%2FStatic-Blog-hexo-github-4-advanced%2F</url>
    <content type="text"><![CDATA[title: '个人博客搭建hexo+github(4):进阶配置' date: 2015-11-09 19:32:36 modified: 2015-11-29 20:53:00 categories: - hexo tags: [hexo, github, blog] --- {% asset_img improve.jpg %} # 文章生成模板 命令 ``` hexo new [layout] "postName" #新建文章 ``` 按照layout格式，根据`postName`生成文章到`hexo/source/_posts/postNmae.md`. layout为可选参数，默认为post，其他可选项在`hexo/scaffolds`目录下查看，md文件就是layout的名字。 可以自行添加新的layout或者更改现有的layout。 修改post.md: ``` title: {{ title }} date: {{ date }} updated: {{ date }} categories: - C1 - C2 tags: [T1, T2] comments: true layout: {{ layout }} --- ``` 注意`: `后面有空格。 # 添加RSS 1. github src https://github.com/hexojs/hexo-generator-feed ```bash $ npm install hexo-generator-feed –-save ``` 2. 修改 hexo配置文件_config.yml, add ``` feed: type: atom path: atom.xml limit: 20 ``` # 添加sitemap > Sitemap 的提交主要的目的，是要避免搜索引擎的爬虫没有完整的收录整个网页> 的内容，所以提交 Sitemap 是能够补足搜索引擎的不足，进而加速网页的收录 > 速度，达到搜寻引擎友好的目的。 ```bash $ npm install hexo-generator-sitemap --save $ npm install hexo-generator-baidu-sitemap --save #this is for baidu ``` add below to _config.yml in the root dir of Hexo ``` sitemap: path: sitemap.xml baidusitemap: path: baidusitemap.xml ``` # 添加robots.txt 把[robots.txt](https://en.wikipedia.org/wiki/Robots_exclusion_standard)放在`source`文件夹下。 ``` # hexo robots.txt User-agent: * Allow: / Allow: /archives/ Disallow: /vendors/ Disallow: /js/ Disallow: /css/ Disallow: /fonts/ Disallow: /vendors/ Disallow: /fancybox/ Sitemap: http://WuChenxu.github.io/sitemap.xml Sitemap: http://WuChenxu.github.io/baidusitemap.xml ``` # 统计 使用[百度统计](tongji.baidu.com),注册账号后，截取`hm.js?`后的字符串为Baidu Analytics ID. 在next主题配置文件中，修改baidu_analytics的值。 {% asset_img music_163.png %} ``` # Baidu Analytics ID # 为百度统计提供脚本中 hm.js? 后字符串，非百度统计帐号 baidu_analytics:xxxx ``` # 计数 使用[不蒜子](http://ibruce.info/2015/04/04/busuanzi/). 1. 安装脚本 在`themes/你的主题/layout/_partial/footer.ejs`添加 ``` ``` 2. 安装标签 在footer.ejs中增加访问量标签。 pv方式，单个用户连续点击n篇文章算n次访问量： ``` 本站总访问量次 ``` uv方式，单个用户连续点击n篇文章算1次访问量： ``` 本站访客数人次 ``` 注意:``标签默认会换行，可以把``放在上一个``标签里，这样可以让计数显示不换行显示。 # 404页面 [腾讯公益404](http://www.qq.com/404/)生成代码嵌入404.html，放在 ``` hexo\source │ 404.html │ └─_posts ``` ```html 404 ``` html文件必须以utf-8格式保存，否则中文会出现乱码。 Reference: 1. [简明 Github Pages与 jekyll 教程](http://cnfeat.com/blog/2014/05/10/how-to-build-a-blog/) 2. [Hexo搭建Github-Pages博客](http://www.jianshu.com/p/35e197cb1273) 3. [NexT主题与Hexo更搭哦](http://www.arao.me/2015/hexo-next-theme-optimize-seo/)]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人博客搭建hexo+github(3):主题配置]]></title>
    <url>%2F2015%2F11%2F09%2FStatic-Blog-hexo-github-3-config-theme%2F</url>
    <content type="text"><![CDATA[title: '个人博客搭建hexo+github(3):主题配置' date: 2015-11-09 19:11:56 modified: 2018-12-23 16:50:00 categories: - hexo tags: [hexo, github, blog] #description: hexo theme configure --- {% asset_img theme_next_preview.jpg %} # overview > Hexo 有两份主要的配置文件（_config.yml），一份位于hexo根目录下，另一 > 份位于主题目录下。为了描述方便，在以下说明中，将前者称为 > 全局配置文件，后者称为 主题配置文件。 # hexo全局配置文件_config.yml 与主题有关的 全局配置文件配置 ``` theme: hexo-theme-next #启用主题 language: zh-CN #查看themes/hexo-theme-next/languages下支持的语言 ``` # 主题配置文件配置 {% include_code lang:yml theme-next-config config/theme-next/_config.yml %} Reference: 1. [next 官方说明](https://theme-next.org/docs/getting-started/) 2. [NexT主题与Hexo更搭哦](http://www.arao.me/2015/hexo-next-theme-optimize-base/)]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人博客搭建hexo+github(2):配置hexo]]></title>
    <url>%2F2015%2F11%2F05%2FStatic-Blog-hexo-github-2-config-hexo%2F</url>
    <content type="text"><![CDATA[title: 个人博客搭建hexo+github(2):配置hexo date: 2015-11-05 21:23:54 modified: 2018-12-23 21:23:54 categories: - hexo tags: [hexo, github, blog] #description: hexo configuration file --- {% asset_img hexo_logo.png %} # 目录介绍 {% codeblock hexo directory tree %} hexo ├── .deploy_git #hexo deploy命令部署到Github Pages上的内容 ├── node_modules #hexo支持的node命令 ├── public #hexo generate命令生成的静态网页内容 ├── scaffolds #layout模板目录，其中的md文件可以添加或者修改 ├── source #文章源码存放目录，包括markdown和html | ├── _drafts #草稿文章 | └── _posts #发布文章 ├── themes #主题文件目录 | └── next | └── _config.yml #next主题配置文件 ├── _config.yml #全局配置文件 └── package.json #应用程序数据，版本等信息 {% endcodeblock %} # 配置hexo(3.8.0) 编辑hexo目录下的_config.yml文件 > Note:修改配置前，做好备份；修改后执行以下命令，验证配置。 ```bash $ hexo clean #一定要先清除，否则可能在生成的网页中出现乱码等奇怪的现象 $ hexo g $ hexo s ``` {% include_code lang:yml hexo-config config/hexo/_config.yml %} # reference 1. [Hexo doc](https://hexo.io/docs/configuration.html) 2. [asset_folder管理图片等资源](http://timnew.me/blog/2014/08/19/use-hexo-asset-folder-to-manage-resource-used-by-post/) 3. [hexo基本用法](http://www.ituring.com.cn/article/199035) 4. [asset用法](https://github.com/timnew/hexo-tag-asset-res)]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人博客搭建hexo+github(1):初体验]]></title>
    <url>%2F2015%2F11%2F04%2FStatic-Blog-hexo-github-1-Start%2F</url>
    <content type="text"><![CDATA[title: 个人博客搭建hexo+github(1):初体验 date: 2015-11-4 23:38:00 modified: 2018-12-23 14:38:00 categories: - hexo tags: [hexo, github, blog] layout: post #description: hexo generated html can be uploaded to github --- {% asset_img hexo_github.png %} ## hexo简介 A fast, simple & powerful blog framework, powered by Node.js. **Features** - Blazing fast generating - Support for GitHub Flavored Markdown and most Octopress plugins - One-command deploy to GitHub Pages, Heroku, etc. - Powerful plugin system ## 本地环境 Win10 x64(in 2017) macOS(in 2018) ## 安装必须的软件 ### 安装[git](http://git-scm.com/)(v2.20.1) ### 安装[node.js](https://nodejs.org/)(v10.14.2) ### 安装hexo(3.8.0) 必须先安装node.js在在git-bash里执行 ```bash $ npm install -g hexo-cli ``` 更新hexo ``` npm update hexo-cli -g ``` ## 配置github * 到Repository下，找到以下内容 {% asset_img gihub_https_link.png %} * 先点击HTTPS，然后复制里面的地址。然后编辑_config.yml文件（在C:\Hexo下） {% asset_img hexo_configure_file.png %} * 修改文件里面的deploy。其中的repository就改成你刚刚复制的地址。保存这个文件。 {% asset_img hexo_deploy.png %} `注意每个冒号后面有一个空格` ## 配置hexo ### 新建 hexo文件夹 建立一个名字叫「Hexo」的文件夹，然后在此文件夹中右键打开Git Bash。 ```bash $ hexo init ``` Hexo随后会自动在目标文件夹建立网站所需要的所有文件。 现在我们已经搭建起本地的hexo博客了，执行以下命令(在C:\hexo)，然后到浏览器输入localhost:4000看看。 ```bash $ hexo g $ hexo s ``` ### 写文章 执行以下命令 ```bash $ hexo n #写文章 ``` 或者，直接在source/_posts文件夹下新建md文件 ### 部署 推送到服务器上，执行 ```bash $ hexo clean #生成 $ hexo g #生成 $ hexo d #部署，可与hexo g合并为hexo d -g ``` ## 配置主题 * 下载主题 ```bash download theme git clone https://github.com/iissnan/hexo-theme-next themes/hexo-theme-next ``` * 在hexo目录下的_config.yml中修改主题 ``` theme: hexo-theme-next ``` * 更新主题 ```bash update theme cd theme/hexo-theme-next git pull ``` ## Reference 1. [Hexo](http://hexo.io/) 2. [github Pages和Jekyll入门](http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html) 3. [我用过的静态站点生成器们](http://segmentfault.com/a/1190000002476681) 4. [简明 Github Pages与 jekyll 教程](http://cnfeat.com/blog/2014/05/10/how-to-build-a-blog/)]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>blog</tag>
      </tags>
  </entry>
</search>
