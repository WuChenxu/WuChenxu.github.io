<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>玉汝于成，功不唐捐</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.wuchenxu.com/"/>
  <updated>2021-10-02T15:12:08.928Z</updated>
  <id>https://www.wuchenxu.com/</id>
  
  <author>
    <name>WU Chenxu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算力指标</title>
    <link href="https://www.wuchenxu.com/2021/10/02/computing-power-metrices/"/>
    <id>https://www.wuchenxu.com/2021/10/02/computing-power-metrices/</id>
    <published>2021-10-02T15:03:12.000Z</published>
    <updated>2021-10-02T15:12:08.928Z</updated>
    
    <content type="html"><![CDATA[<p>FLOPs（Floating Point Operations）<br>FLOPS（Floating-point operations per second）<br>TOPS（Tera/Trillion Operations Per Second）<br>MACS（ Multiply-Accumulate Instructions per Second）<br>TOPS/W<br>ResNet-50 inference throughput（images/s）<br>ResNet-50 inference energy efficiency（images/s/W）<br>Throughput/TOPS<br>DMIPS（Dhrystone Million Instructions executed Per Second）</p><a id="more"></a><h2 id="FLOPs（Floating-Point-Operations）"><a href="#FLOPs（Floating-Point-Operations）" class="headerlink" title="FLOPs（Floating Point Operations）"></a>FLOPs（Floating Point Operations）</h2><p>注意s小写，是floating point operations的缩写（s表复数），意指浮点运算数，理解为计算量, 可以用来衡量算法/模型的复杂度。一般的，算法/模型复杂度OPs，可以理解成OPs/frame，再乘上帧率就可以得到大概需要的算力，算力一般用FLOPS（对浮点运算）/TOPS（对整数运算）。</p><img src="/2021/10/02/computing-power-metrices/FLOPs.png" class=""><h2 id="FLOPS（Floating-point-operations-per-second）"><a href="#FLOPS（Floating-point-operations-per-second）" class="headerlink" title="FLOPS（Floating-point operations per second）"></a>FLOPS（Floating-point operations per second）</h2><p>每秒浮点运算次数, 是每秒所执行的浮点运算次数的简称，被用来评估电脑效能。1 MFLOPS表示每秒100万个数字运算（“浮点”的加法或乘法）。1 GFLOPS表示每秒10亿次的浮点运算，即1000 MFLOPS。1 TFLOPS表示每秒1万亿次浮点运算，或1000 GFLOPS，即100万MFLOPS或每秒10^12^次操作。通常还需指定运算精度，可选FP32，FP16，BF16，TF32等，如FP32: 10TFLOPS，或者10 TFLOPS（FP32）。</p><h2 id="TOPS（Tera-Trillion-Operations-Per-Second）"><a href="#TOPS（Tera-Trillion-Operations-Per-Second）" class="headerlink" title="TOPS（Tera/Trillion Operations Per Second）"></a>TOPS（Tera/Trillion Operations Per Second）</h2><p>1 TOPS代表处理器每秒钟可进行一万亿次（10^12^）整数乘法或者加法操作，衡量计算性能。一般针对整数运算用OPS，浮点数用FLOPS，整数运算还需要指定运算精度，一般有INT4，INT8，INT16，INT32。如Nvdia <strong>AGX Orin</strong> 标称254 TOPS（INT8）或者INT8: 254TOPS。</p><p>NVDLA（Deep Learning Accelerator）与GPU的区别：</p><ol><li>DLA是NVIDIA推出的用于专做视觉的部件，如Xavier上有两个DLA。</li><li>DLA的定位是专做常用计算(Conv+激活函数+Pooling+Normalization+Reshape)，然后复杂的计算交给Volta GPU做。</li><li>DLA功耗很低，性能更好。</li></ol><blockquote><p> DLA has up to 5 TOPS INT8 or 2.5 TFLOPS FP16 performance with a power consumption of only 0.5-1.5W. The DLAs support accelerating CNN layers such as convolution, deconvolution, activation functions, min/max/mean pooling, local response normalization, and fully-connected layers.</p></blockquote><p>​        一般标称FLOPS/TOPS是一个峰值性能（peak value），条件比较理想，是针对特定时钟频率，特定功耗，特定kernel大小，的的性能，        可以作为参考，但是实际应用中不太可能达到峰值。最高TOPS还跟吞吐，带宽，并行处理，输入数据加载速度，功耗等相关。</p><p>​        下面是一个Nvidia A100的datasheet，可以看到TFLOPS针对的是FP64/FP32/TF32，TOPS针对的是INT8/INT4。</p><img src="/2021/10/02/computing-power-metrices/NV_A100_KPI.png" class=""><h2 id="MACS（-Multiply-Accumulate-Instructions-per-Second）"><a href="#MACS（-Multiply-Accumulate-Instructions-per-Second）" class="headerlink" title="MACS（ Multiply-Accumulate Instructions per Second）"></a>MACS（ Multiply-Accumulate Instructions per Second）</h2><p>MAC是乘法累加器，MAC与上面的OPS的关系：<strong>1MAC=2OPS</strong>，因为一个MAC包含乘法和加法两种运算。Nvdia 的叫法：HMMA (Half-Precision Matrix Multiply and Accumulate) and IMMA (Integer Matrix Multiply and Accumulate) 。</p><img src="/2021/10/02/computing-power-metrices/oneMACor2OPS.png" class=""><h2 id="TOPS-W"><a href="#TOPS-W" class="headerlink" title="TOPS/W"></a>TOPS/W</h2><p>每瓦万亿次操作，衡量性能效率。</p><h2 id="ResNet-50-inference-throughput（images-s）"><a href="#ResNet-50-inference-throughput（images-s）" class="headerlink" title="ResNet-50 inference throughput（images/s）"></a>ResNet-50 inference throughput（images/s）</h2><p>横坐标是不同的batch size，纵坐标是images/s。</p><img src="/2021/10/02/computing-power-metrices/ResNet-50InferenceThroughput.png" class=""><h2 id="ResNet-50-inference-energy-efficiency（images-s-W）"><a href="#ResNet-50-inference-energy-efficiency（images-s-W）" class="headerlink" title="ResNet-50 inference energy efficiency（images/s/W）"></a>ResNet-50 inference energy efficiency（images/s/W）</h2><p>横坐标是不同的batch size，纵坐标是images/s/watt。</p><p>上面两个指标也可以把ResNet-50换成AlexNet，GoogLeNet，VGG19等，只是ResNet-50是比较常用的。</p><h2 id="Throughput-TOPS"><a href="#Throughput-TOPS" class="headerlink" title="Throughput/TOPS"></a>Throughput/TOPS</h2><p>每万亿次操作吞吐，是衡量效率（efficiency）的一个指标。</p><h2 id="DMIPS（Dhrystone-Million-Instructions-executed-Per-Second）"><a href="#DMIPS（Dhrystone-Million-Instructions-executed-Per-Second）" class="headerlink" title="DMIPS（Dhrystone Million Instructions executed Per Second）"></a>DMIPS（Dhrystone Million Instructions executed Per Second）</h2><p>Dhrystone是测量处理器运算能力的最常见基准（benchmark）程序之一，常用于处理器的整型运算性能的测量。Dhrystone是一种整数和字符串运算测试程序。一般用来衡量CPU算力。</p><p>由于CPU算力与主频相关，而主频是可以配置的，一般标称用：DMIPS/MHz</p><p>如：A72:4.7DMIPS/MHz =&gt;. <a href="mailto:A72@1.6GHz">A72@1.6GHz</a> = 4.7*1600 = 7520 DMIPS = 6.52 KDMIPS</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.kdnuggets.com/2020/05/tops-just-hype-dark-ai-silicon-disguise.html" target="_blank" rel="noopener">Are Tera Operations Per Second (TOPS) Just hype? Or Dark AI Silicon in Disguise?</a></li><li><a href="https://venturebeat.com/2020/09/30/as-ai-chips-improve-is-tops-the-best-way-to-measure-their-power/" target="_blank" rel="noopener">As AI chips improve, is TOPS the best way to measure their power?</a></li><li><a href="https://semiengineering.com/lies-damn-lies-and-tops-watt/" target="_blank" rel="noopener">Lies, Damn Lies, And TOPS/Watt</a></li><li><a href="https://analyticsindiamag.com/is-teslas-dojo-as-amazing-as-claimed/" target="_blank" rel="noopener">Is Tesla’s Dojo As Amazing As Claimed?</a></li><li><a href="https://semiengineering.com/tops-memory-throughput-and-inference-efficiency/" target="_blank" rel="noopener">TOPS, Memory, Throughput And Inference Efficiency</a></li><li><a href="https://semiengineering.com/ai-inference-memory-system-tradeoffs/" target="_blank" rel="noopener">AI Inference Memory System Tradeoffs</a></li><li><a href="https://medium.com/analytics-vidhya/not-all-tops-are-created-equal-e1911ffb4a82" target="_blank" rel="noopener">Not all TOPs are created equal</a></li><li><a href="https://www.rle.mit.edu/eems/wp-content/uploads/2020/09/2020_sscs_dnn.pdf" target="_blank" rel="noopener">How to Evaluate Deep Neural Network Processors</a></li><li><a href="https://en.wikipedia.org/wiki/Nvidia_Drive" target="_blank" rel="noopener">Nvidia Drive</a></li><li><a href="https://www.nvidia.com/content/dam/en-zz/Solutions/Data-Center/a100/pdf/nvidia-a100-datasheet.pdf" target="_blank" rel="noopener">NVIDIA A100 TENSOR CORE GPU</a></li><li><a href="https://blog.csdn.net/zh8706/article/details/112909866" target="_blank" rel="noopener">AI芯片算力比较</a></li><li><a href="https://zhuanlan.zhihu.com/p/71984335" target="_blank" rel="noopener">NVIDIA Xavier 整理</a></li><li><a href="http://info.nvidia.com/rs/156-OFN-742/images/Jetson_AGX_Xavier_New_Era_Autonomous_Machines.pdf" target="_blank" rel="noopener">JETSON AGX XAVIER AND THE NEW ERA OF AUTONOMOUS MACHINES</a></li><li><a href="https://en.wikipedia.org/wiki/List_of_ARM_microarchitectures" target="_blank" rel="noopener">List of ARM microarchitectures</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;FLOPs（Floating Point Operations）&lt;br&gt;FLOPS（Floating-point operations per second）&lt;br&gt;TOPS（Tera/Trillion Operations Per Second）&lt;br&gt;MACS（ Multiply-Accumulate Instructions per Second）&lt;br&gt;TOPS/W&lt;br&gt;ResNet-50 inference throughput（images/s）&lt;br&gt;ResNet-50 inference energy efficiency（images/s/W）&lt;br&gt;Throughput/TOPS&lt;br&gt;DMIPS（Dhrystone Million Instructions executed Per Second）&lt;/p&gt;
    
    </summary>
    
    
      <category term="computer" scheme="https://www.wuchenxu.com/categories/computer/"/>
    
    
      <category term="TOPS" scheme="https://www.wuchenxu.com/tags/TOPS/"/>
    
  </entry>
  
  <entry>
    <title>思维导图学习法</title>
    <link href="https://www.wuchenxu.com/2021/07/24/reading-notes-7-%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E5%AD%A6%E4%B9%A0%E6%B3%95/"/>
    <id>https://www.wuchenxu.com/2021/07/24/reading-notes-7-%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E5%AD%A6%E4%B9%A0%E6%B3%95/</id>
    <published>2021-07-24T15:06:13.000Z</published>
    <updated>2021-07-25T08:20:07.140Z</updated>
    
    <content type="html"><![CDATA[<p>20130w2 思维导图学习法</p><a id="more"></a><h1 id="20130w2-思维导图学习法"><a href="#20130w2-思维导图学习法" class="headerlink" title="20130w2 思维导图学习法"></a>20130w2 思维导图学习法</h1><h2 id="什么是思维导图"><a href="#什么是思维导图" class="headerlink" title="什么是思维导图"></a>什么是思维导图</h2><p>1968年，东尼•博赞（Tony Buzan）发明了思维导图。思维导图，又叫心智导图，英文mind mapping，是表达发散性思维的、简单有效的、实用性很强的图形思维工具 。</p><h2 id="为什么思维导图是个好工具"><a href="#为什么思维导图是个好工具" class="headerlink" title="为什么思维导图是个好工具"></a>为什么思维导图是个好工具</h2><h3 id="学习是什么？"><a href="#学习是什么？" class="headerlink" title="学习是什么？"></a>学习是什么？</h3><p>学习的目的是为了学习知识，而不是记忆知识。学习是通过有限的例子找出规律，从而将规律（信息）压缩成知识，这样可以突破有限的例子推广到从未见过的情况。</p><h3 id="怎样学习？"><a href="#怎样学习？" class="headerlink" title="怎样学习？"></a>怎样学习？</h3><p>首先我们要明确知识的输入输出，然后不断通过例子来重塑大脑的链接，在这个过程中我们需要拆分知识来降低知识组合的维度。</p><h3 id="为什么思维导图有用？"><a href="#为什么思维导图有用？" class="headerlink" title="为什么思维导图有用？"></a>为什么思维导图有用？</h3><p>思维导图把关键词组合成树状或者网状的形式。</p><ol><li>关键词是对知识的压缩，通过关键词，去追问是它（关键词）是什么，它（关键词）的目的是什么，输入怎样映射到输出。</li><li>思维导图不是为了记住，而是通过思维导图来不断复习加深印象，重塑/加深大脑的链接，不断的复习中可能找到更好的关键词或者组织形式来描述知识。</li><li>对关键词（知识）的拆分。一般从输入到输出是有多个子知识的组合，如果不进行拆分，那么就需要指数量级的例子来学习到未拆分的知识；拆分之后，要学习的例子就变成线性量级，且一些子知识是已知的。重用已有知识，是快速掌握知识，构建知识网络的诀窍。（因为学习观里的观点可以映射到机器学习领域，由此想到深度学习网络越深表达力越丰富，也可以理解为一种拆分方式）</li><li>思维导图的关键词所表示的知识应该越独立越好，这样才能减少学习需要的例子数量。</li><li>思维导图应该时常验证更新，“学而时习之”。</li></ol><p>下面是根据学习观视频画的关于“思维导图学习法”的思维导图。</p><pre class="mermaid" style="text-align: center;">            graph LR            swdt[思维导图]swdt --- sycl[使用材料]swdt --- symd[使用目的]swdt --- sycj[使用场景]swdt --- syyz[使用原则]swdt --- sybz[使用步骤]swdt --- syjq[使用技巧]sycl --- sr[输入: 庞杂信息]sycl--- sc[输出: 知识网络]symd --- cfzs[拆分知识];cfzs --- zxsw[正向思维];cfzs --- nxsw[逆向思维]symd --- ejzs[二阶知识];ejzs --- tjxh[条件循环];ejzs --- blzh[并列组合]sycj --- dtxx[学习:深度学习好的本质]; dtxx --- xxmd[目的]---将大知识拆分成小知识组合; dtxx---dtxxyd[优点]; dtxxyd --- ysxxjs[压缩信息,节省笔记空间];dtxxyd---zscy[已掌握的知识可被复用,更少的例子来学习,快速构建知识网络]sycj --- dtyy[应用:分而治之具体操作]---目的---将任务需要的未知知识拆分已掌握的知识; dtyy---优点---可用更少的知识来解决问题,快速找到解决方案syyz --- zsdl[知识独立]syyz --- yzgx[验证更新]sybz --- sjlz[搜集例子]; sjlz ---tnfb[头脑风暴]; sjlz --- czzl[上网调查]sybz --- zwtw[自我提问];zwtw --- twyjzs[一阶知识]; zwtw --- twejzs[二阶知识]; twyjzs --- zwtwfl[分类]; twyjzs --- zwtwhg[回归]; twejzs --- zhgx[组合关系]; twejzs --- zxbz[执行步骤] --- xhsx[先后顺序]; zwtwfl ---zwtwhat[它是什么]; zwtwfl ---zwtwhy[为什么是]; zwtwhg ---zwtwmd[它的目的]; zwtwhg ---zwtwhow[如何达成]; zhgx --- tysm[它有什么]syjq --- gjsy[工具使用]---外框---视角,注意力;gjsy --- 联系 --- 跨层知识关系;gjsy --- 笔记 --- 知识描述;gjsy --- 概要 --- 显示描述syjq --- zsmm[知识命名]---定语名词; zsmm --- 动宾词语syjq --- sywq[使用误区]---记录所有信息; sywq --- 知识见不独立; sywq --- 记忆他人导图; sywq --- 从不验证更新; sywq --- 画无规律信息          </pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/083b129153af" target="_blank" rel="noopener">三大高效学习方法之二：思维导图学习法</a></p><p>学习观05：思维导图原理：人生与高手之差</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;20130w2 思维导图学习法&lt;/p&gt;
    
    </summary>
    
    
      <category term="reading-notes" scheme="https://www.wuchenxu.com/categories/reading-notes/"/>
    
      <category term="learning" scheme="https://www.wuchenxu.com/categories/reading-notes/learning/"/>
    
    
      <category term="reading-notes" scheme="https://www.wuchenxu.com/tags/reading-notes/"/>
    
      <category term="learning" scheme="https://www.wuchenxu.com/tags/learning/"/>
    
  </entry>
  
  <entry>
    <title>认知盲维</title>
    <link href="https://www.wuchenxu.com/2021/07/06/%E8%AE%A4%E7%9F%A5%E7%9B%B2%E7%BB%B4/"/>
    <id>https://www.wuchenxu.com/2021/07/06/%E8%AE%A4%E7%9F%A5%E7%9B%B2%E7%BB%B4/</id>
    <published>2021-07-06T13:24:33.000Z</published>
    <updated>2021-07-06T13:26:49.748Z</updated>
    
    <content type="html"><![CDATA[<p>21028W2_概念卡 认知盲维</p><a id="more"></a><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>由于我们对某个维度缺乏意识，以至于在认知我们所处的这个世界时，会出现致命的认知误区，甚至我们都不知道自己的缺失何在。跟盲点的区别在于，盲点侧重某些点的缺失，盲维更强调某些维度，线面的缺失。</strong></p><h2 id="出处"><a href="#出处" class="headerlink" title="出处"></a>出处</h2><p>《费曼学习法》（尹红心 李伟）中提到：</p><p>“盲维”是我们没有看到的角落，也是我们未想到的地方。比如你走进一个陌生的房间，每次进去只能待1分钟。第1次进去时，你描绘房间30%的特征，里面是落地窗，厨房很整洁，有两张床，一张餐桌。但你没注意到是否有空调和洗衣机，以及沙发、餐桌和床的材质。第2次进去时，你注意到了电器和沙发，能说出它们的品牌、颜色等特征，但你没留意房间内有几个插座，卫生间的热水器和淋浴头是否好用，厨房的煤气管道是否安全可靠。直到第3次进去，你才掌握了这些信息。实际上，你的观察一定还存在很多盲点，只不过你暂时没有注意到。只有在里面住上几天，你才能完全地了解这个房间。</p><p>学习便类似于探索一个陌生的房间。盲维越大，你对知识的了解就越浅，在输出知识时你的表达力就越欠缺，听着也难以从你这里第一时间理解你所讲的内容。消除盲维的过程，正式我们对知识采取怀疑和深度探索的环节—怀疑那些令自己感到困惑的知识，探索哪些仍未搞清楚的知识，而且要主动地回顾和总结，反思和修正。</p><h2 id="启发"><a href="#启发" class="headerlink" title="启发"></a>启发</h2><ol><li>怎么减少盲维？要减少盲维的产生，要不停地探索，增加看问题的角度。看书学习是一种方式，看书里古往今来的牛人的观察世界的方式。输出知识一种探索的方式，跟厉害的人碰撞之后反弹回来才有所收获。</li><li>乔哈里视窗在人际沟通领域提供了一个工具，扩大开放区，减少盲目区，减少未知区。</li></ol><table><thead><tr><th></th><th>我知</th><th>我不知</th></tr></thead><tbody><tr><td>别人知</td><td>开放区（Open）</td><td>盲目区（Blind）</td></tr><tr><td>别人不知</td><td>隐秘区（Hidden）</td><td>未知区（Unknown）</td></tr></tbody></table><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>《费曼学习法》（尹红心 李伟）</li><li><a href="https://www.163.com/dy/article/DJ0C57FR0516IOBE.html" target="_blank" rel="noopener">吴伯凡：为什么说“盲维”是认知升级的重要概念</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;21028W2_概念卡 认知盲维&lt;/p&gt;
    
    </summary>
    
    
      <category term="leranning" scheme="https://www.wuchenxu.com/categories/leranning/"/>
    
    
      <category term="learnning" scheme="https://www.wuchenxu.com/tags/learnning/"/>
    
      <category term="concept" scheme="https://www.wuchenxu.com/tags/concept/"/>
    
  </entry>
  
  <entry>
    <title>费曼学习法：人的深度学习</title>
    <link href="https://www.wuchenxu.com/2021/07/06/reading-notes-6-%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95/"/>
    <id>https://www.wuchenxu.com/2021/07/06/reading-notes-6-%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95/</id>
    <published>2021-07-06T13:03:29.000Z</published>
    <updated>2021-07-06T13:07:21.085Z</updated>
    
    <content type="html"><![CDATA[<p>21028w1_读书卡: 费曼学习法：人的深度学习</p><a id="more"></a><h2 id="费曼学习法"><a href="#费曼学习法" class="headerlink" title="费曼学习法"></a>费曼学习法</h2><h3 id="要解决的问题"><a href="#要解决的问题" class="headerlink" title="要解决的问题"></a>要解决的问题</h3><p>付出了学习的过程（每天看各种书，听各种讲座，视频，买课，刷知乎），存储了知识，提升了知识量，但是没有提升学习力，提升思维方式，并不能真正理解应用这些知识。在信息化，碎片化，且日益焦虑的今天，问题更加严重。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>费曼学习法：学习知识时，站在传授者的立场，假设自己要向别人讲解这门知识。</p><p>这是既是思维方式和学习的最终目的，又是实操的方法。其他的所有细枝末节都是从上面这一句话引申出来的。</p><p>学习的最终目的是：</p><ul><li>提高学习的能力。</li><li>能够运用学到知识，解释，理解，预测问题，融入自己的知识体系。</li></ul><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p>按照本书的结构</p><pre class="mermaid" style="text-align: center;">            graph LR            A[费曼学习法]-->A0[学习的本质] A0--学习力是核心竞争力--> A00[学习力 > 理解知识 > 记住知识]A00--> A000[学习的目的不是为了收集知识, 改变将来的命运. 而是专注将知识与当下场景紧密结合]A00-->A001[远见 洞见 智慧]A00-->A002[思维方式+理解运用 而不是知识量的存储]A00-->A004[读懂未来]A-->A1[确立要学习的目标] --产生专注力--> A11[主动学习:以输出为载体的有选择输入]A1 -->A12[开放性思维/批判性思维/逻辑性思维/表达力]A1 -->A13[聚焦目标, 兴趣]A1 -->A14[规划: SMART]A-->A2[理解要学习的知识]-->A21[系统化地存优去劣]A21 --> A211[系统: 归纳-筛选-归纳]A21 --> A212[水平: 归类对比]A21 --> A213[发散: 思维导图]A21 --> A214[收敛: 知识结构]A-->A3[输出] --输出是最强大的学习力--> A31[以教代学]A31-->A311[简单的解释让菜鸟听懂]A31-->A312[例子: 让小孩讲一遍白天上课的内容/制作教学视频/富兰克林重写报纸文章]A31-->A313[输出倒逼输入]A31-->A314[场景和思维模拟/分组讨论反馈]A-->A4[回顾和反思] --> A41[深度分析-转化知识]A41 --> A411[怀疑和探索-减少盲维-好奇心]A41 --> A412[寻找反证-尽信书不如无书]A41 --> A413[加大内容留存率]A-->A5[简化和吸收] --通过简化吸收形成自己的知识体系--> A51[内化知识]A51 --> A511[系统性深挖-需要/重要/核心]A51 --> A512[形成知识体系-简化-只学最核心的-原创观点]          </pre><h2 id="摘要-启发"><a href="#摘要-启发" class="headerlink" title="摘要/启发"></a>摘要/启发</h2><ol><li><p>知识的本质是人生的进步与成长，是我们与环境的融合并产生新认知的过程。从根本上说，知识是我们对世界的理解，并以此获取的改造世界的能力。—费曼。 </p></li><li><p>从神经科学的角度，理解输出的作用：输出越多，大脑对陌生事物的联想越丰富，从而将新的概念插入到旧体系中。这让我想起了“赫布理论”（Donald Hebb）：fire together wire togethe. （一起被激发的神经元会被捆扎在一起）从这个角度理解，输出可以更好地改变我们大脑的连接方式，形成长时记忆和联想。</p></li><li><p>场景和思维模拟</p><ol><li>不需要真实的听众，在脑海中设想你在向一群人介绍一门知识，想象一下你自己会怎么介绍，顺畅吗？卡壳吗？听众会有什么反应，会欣然接收，会质疑？</li><li>这是一种思维训练，可以检验输出的效果</li><li>这是一种记忆的方式，让记忆有一个落脚地，落脚点是脑海中设计的这个场景。（这里有一个双重编码理论：文字信息会被处理为“意码”，抽象理解；非文字信息的处理以“形码”为主，图像理解。）</li></ol></li><li><p>“输出”倒逼“输入”：1. 从“输出”的角度，能够更好的明确学习的目标，避免盲目。 2. 如果输出过程中卡壳，从“输出”来确定需要哪些“输入”，系统地寻找学习资料的来源 </p></li><li><p>三次复述：</p><p>第一次复述，把自己当作倾听者。</p><p>第二次复述，是进入一个真实的传授知识的场景，向别人甚至多个人阐述你对某项知识的看法。</p><p>第三次复述，最终的目的就是为了检验我们对知识的创造能力，形成我们自己在这方面的影响力。</p></li><li><p>关于“好奇心”“兴趣”“热情”</p><p>在学习中，经验决定下限，好奇心决定上限。</p><p>兴趣是我们最好的老师。开展复述时一定要贴近自己的兴趣，围绕自己的爱好。你必须基于自己的兴趣去开发学习的能力，创造有影响力的知识。</p><p>“热情”是造成学生的学习结果最大差异的因素。</p><p>好奇心，兴趣和热情应该是相辅相成，相得益彰的：有好奇心，培养成了兴趣，进而有了热情；热情使得学习更加投入，产出更多，兴趣更加稳固，更大的好奇心去探索。</p></li><li><p>名字背后的意义</p><p>在1997年出版的《别闹了，费曼先生》（Surely You’re Joking，Mr. Feynman!）一书中，费曼提到了自己的父亲告诉他的一个道理：“当你看到一只鸟时，即便你知道它的名字，对它也仍然一无所知。因为你只是知道了人类赋予它的名字，仅此而已。至于它在夏天横跨整个国家并飞行上万英里时是怎样辨别方向的，没有人知道是怎么回事。”他的意思是，很多真正的知识往往藏在表象的背后，需要你做出解释。如果你能向人们解释明白一只鸟如何掌握飞行的方向，才说明你真正了解了这只鸟，否则不过是人云亦云。</p></li><li><p>主动的学习远比被动的学习重要；系统的学习远比碎片式的学习重要；向内的学习远比向外的学习重要；专业的学习远比跨界的学习重要。</p></li><li><p>all in all: 利用各种机会开始输出吧：写作，写卡，给别人讲解，给其他人培训，与他人讨论。。。 在输出的过程中，检验学到的知识是否变成了自己的一部分。不要指望知识速成，欲速则不达。good things take time。</p></li></ol><p>出处：尹红心 李伟 《费曼学习法》 2021年03月 江苏凤凰出版社</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;21028w1_读书卡: 费曼学习法：人的深度学习&lt;/p&gt;
    
    </summary>
    
    
      <category term="reading-notes" scheme="https://www.wuchenxu.com/categories/reading-notes/"/>
    
      <category term="learnning" scheme="https://www.wuchenxu.com/categories/reading-notes/learnning/"/>
    
    
      <category term="reading-notes" scheme="https://www.wuchenxu.com/tags/reading-notes/"/>
    
      <category term="learnning" scheme="https://www.wuchenxu.com/tags/learnning/"/>
    
  </entry>
  
  <entry>
    <title>深度学习模型拟合的关键问题</title>
    <link href="https://www.wuchenxu.com/2021/07/03/deep-learnning-key-tasks/"/>
    <id>https://www.wuchenxu.com/2021/07/03/deep-learnning-key-tasks/</id>
    <published>2021-07-03T12:58:20.000Z</published>
    <updated>2021-07-06T13:23:39.231Z</updated>
    
    <content type="html"><![CDATA[<p>21027w3_摘要卡 深度学习模型拟合的关键问题</p><a id="more"></a><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>在深度学习中，我们“训练”模型，不断更新它们，使它们在看到越来越多的数据时变得越来越好。</p><p>通常情况下，变得更好意味着最小化一个 <em>损失函数</em>（loss function），即一个衡量“我们的模型有多糟糕”这个问题的分数。</p><p>最终，我们真正关心的是生成一个能够在我们从未见过的数据上表现良好的模型。但我们只能将模型与我们实际能看到的数据相拟合。</p><p>因此，我们可以将拟合模型的任务分解为两个关键问题：</p><p>（1）<em>优化</em>（optimization）：用模型拟合观测数据的过程；</p><p>（2）<em>泛化</em>（generalization）：数学原理和实践者的智慧，能够指导我们生成出有效性超出用于训练的数据集本身的模型。</p><h2 id="启发"><a href="#启发" class="headerlink" title="启发"></a>启发</h2><p>区别于传统的基于规则（演绎法）的解决问题方式，深度学习将问题转化为一个归纳问题（优化），不是通过规则直接计算全局最优解，而是通过数据驱动的方式去逼近一个局部最优解。</p><p>这个事能成立，我想这里隐含了几个假设：</p><ol><li>为了覆盖更多的情况，数据要能覆盖要足够多的情况</li><li>观测数据的属性/分布要与真实世界的类似（比如不同设备采集出来的数据属性可能不一致）</li><li>实践者的智慧是不是意味着：泛化问题是一个实验试错的过程，没法完全解释为什么能work，所谓“炼丹”是也。</li></ol><p>最终的结局，我想要根据实际要解决的问题：</p><ol><li><p>问题不是很复杂：有足够的数据，通过拟合已经可以很好地解决问题，比如基于图像的分类/物体检测等。</p></li><li><p>问题很复杂：没有足够的数据，或者无法采集足够的数据，永远在优化的路上，比如L4/5自动驾驶。</p></li></ol><p>有没有可能：深挖拟合/归纳（bottom-up）发现的规律，从而可以通过演绎法（top-down）来指导解决问题，或者是演绎跟归纳法的结合。</p><p>出处：李沐 <a href="https://zh-v2.d2l.ai/chapter_preliminaries/calculus.html" target="_blank" rel="noopener">《动手学深度学习》2.4.微分</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;21027w3_摘要卡 深度学习模型拟合的关键问题&lt;/p&gt;
    
    </summary>
    
    
      <category term="deep learnning" scheme="https://www.wuchenxu.com/categories/deep-learnning/"/>
    
    
      <category term="deep learnning" scheme="https://www.wuchenxu.com/tags/deep-learnning/"/>
    
  </entry>
  
  <entry>
    <title>诗歌 翻译 卿为朝朝暮暮</title>
    <link href="https://www.wuchenxu.com/2021/07/02/a-chinese-english-poem/"/>
    <id>https://www.wuchenxu.com/2021/07/02/a-chinese-english-poem/</id>
    <published>2021-07-02T12:55:13.000Z</published>
    <updated>2021-07-06T12:56:24.149Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="诗歌"><a href="#诗歌" class="headerlink" title="诗歌"></a>诗歌</h2><p><strong>I love three things in this world.</strong></p><p><strong>Sun, Mood and you.</strong></p><p><strong>Sun for morning, Moon for night,</strong></p><p><strong>and you forever.</strong></p><p><strong>浮世三千，吾爱有三。</strong></p><p><strong>日，月与卿。</strong></p><p><strong>日为朝，月为暮，</strong></p><p><strong>卿为朝朝暮暮。</strong></p><p>出处：最早见于赵立坚的推特，后查阅资料，找不到中英文的原作者（《暮光之城》《飞鸟集》说法都不对），很可能是先有中文后有英文。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h2 id=&quot;诗歌&quot;&gt;&lt;a href=&quot;#诗歌&quot; class=&quot;headerlink&quot; title=&quot;诗歌&quot;&gt;&lt;/a&gt;诗歌&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;I love three things in this world.&lt;/strong&gt;
      
    
    </summary>
    
    
      <category term="poem" scheme="https://www.wuchenxu.com/categories/poem/"/>
    
    
      <category term="peom" scheme="https://www.wuchenxu.com/tags/peom/"/>
    
  </entry>
  
  <entry>
    <title>如何快速阅读和整理文献</title>
    <link href="https://www.wuchenxu.com/2021/06/29/how-to-read-and-summarize-literature/"/>
    <id>https://www.wuchenxu.com/2021/06/29/how-to-read-and-summarize-literature/</id>
    <published>2021-06-29T12:39:32.000Z</published>
    <updated>2021-07-06T12:56:50.193Z</updated>
    
    <content type="html"><![CDATA[<p>转自李沐的B站视频</p><a id="more"></a><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><ul><li>学生时代： 对最重要的研究方向了如指掌，精读，复现。</li><li>工作之后：对5-10个感兴趣的研究方向，了解最新的进展，思考团队的研究方向。</li></ul><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>概括：一个领域里的论文及思考笔记放在一个markdown文件里</p><p>原因：markdown简单，便捷，软件支持性不错，支持latex（公式），插图， 容易搜索</p><p>Tool: iPad, 1writer, typora, dropbox(多设备同步)</p><p>tips：自动检测被修改markdown文件，自动根据URL更新下载论文，并更新信息（<a href="https://github.com/WilmerWang/autoLiterature" target="_blank" rel="noopener">autoLiterature</a>）</p><p>表现形式：</p><ol><li>列表形式</li></ol><ul><li>领域x<ul><li>论文X标题，作者，发表的地方，年份，引用次数，链接<ul><li>笔记：重要的图，公式</li></ul></li></ul></li></ul><img src="/2021/06/29/how-to-read-and-summarize-literature/21027w1_%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E9%98%85%E8%AF%BB%E5%92%8C%E6%95%B4%E7%90%86%E6%96%87%E7%8C%AE_paper_list.png" class=""><ol><li><p>图形式</p><p>使用 mermaid 来生成关系图</p></li></ol><pre class="mermaid" style="text-align: center;">            graph TB            LeNet --deepper/bigger --> AlexNet --1x1 conv-->NiN --inception:split-transform-merge--> GoogLeNet --batch Normalization--> BN-Inception --updated inception, label smooth--> InceptionV3 --residual connection --> InceptionV4  AlexNet -- 3x3 conv --> VGG -- 1x1 conv bottleneck --> SqueezeNetVGG -- residual --> ResNet -- + concat -->DenseNetResNet -- group conv --> ResNeXt -- shuffle channels among groups --> ShuffleNetInceptionV3 -- inception to depthwise seperate seperate conv --> XceptionResNet -- squeeze-exicte --> SENetclick LeNet "https://www.researchgate.net/publication/2985446_Gradient-Based_Learning_Applied_to_Document_Recognition"click AlexNet "http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf"          </pre><p>出处：<a href="https://www.bilibili.com/video/BV1nA41157y4?from=search&seid=11438292823914068006" target="_blank" rel="noopener">李沐：我是如何快速阅读和整理文献</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自李沐的B站视频&lt;/p&gt;
    
    </summary>
    
    
      <category term="literature" scheme="https://www.wuchenxu.com/categories/literature/"/>
    
      <category term="learnning" scheme="https://www.wuchenxu.com/categories/literature/learnning/"/>
    
    
      <category term="learnning" scheme="https://www.wuchenxu.com/tags/learnning/"/>
    
      <category term="literature" scheme="https://www.wuchenxu.com/tags/literature/"/>
    
  </entry>
  
  <entry>
    <title>Call C Library From Python</title>
    <link href="https://www.wuchenxu.com/2021/03/28/Call-C-Library-From-Python/"/>
    <id>https://www.wuchenxu.com/2021/03/28/Call-C-Library-From-Python/</id>
    <published>2021-03-28T08:19:10.000Z</published>
    <updated>2021-03-29T03:40:58.489Z</updated>
    
    <content type="html"><![CDATA[<p>混合编程之 Python调用C</p><a id="more"></a><h1 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h1><p>混合编程可以充分发挥不同编程语言的优势：<br>C语言速度优势<br>python编写简单，很多现成的轮子</p><h1 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h1><h2 id="ctypes"><a href="#ctypes" class="headerlink" title="ctypes"></a>ctypes</h2><h3 id="把C编译成动态库"><a href="#把C编译成动态库" class="headerlink" title="把C编译成动态库"></a>把C编译成动态库</h3><h4 id="from-file"><a href="#from-file" class="headerlink" title="from file"></a>from file</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc c_func.c -shared -o c_func_dy.so</span><br></pre></td></tr></table></figure><h4 id="from-static-library"><a href="#from-static-library" class="headerlink" title="from static library"></a>from static library</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先将静态库解出obj文件</span></span><br><span class="line"><span class="variable">$ar</span> -x mylib.a</span><br><span class="line"> <span class="comment"># 再用gcc 将obj文件，编译成动态库</span></span><br><span class="line"><span class="variable">$gcc</span> -shared -fPIC *.o -o mylib.so</span><br></pre></td></tr></table></figure><h3 id="在python文件中导入头文件"><a href="#在python文件中导入头文件" class="headerlink" title="在python文件中导入头文件"></a>在python文件中导入头文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure><h3 id="在python中引入c动态库-并用变量接收动态库的引用"><a href="#在python中引入c动态库-并用变量接收动态库的引用" class="headerlink" title="在python中引入c动态库,并用变量接收动态库的引用"></a>在python中引入c动态库,并用变量接收动态库的引用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lib_ref = cdll.LodaLibrary(<span class="string">"./c_dll.so"</span>)</span><br></pre></td></tr></table></figure><h3 id="调用动态库方法"><a href="#调用动态库方法" class="headerlink" title="调用动态库方法"></a>调用动态库方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dynamic_lib_reference.function_in_lib(arguments)</span><br></pre></td></tr></table></figure><p>eg.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lib_ref.my_add(num)</span><br></pre></td></tr></table></figure><h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><p><a href="https://github.com/WuChenxu/Python/blob/master/03_load_lib/call_c_func.py" target="_blank" rel="noopener">python call C example code</a></p><p>reference:</p><ol><li><a href="https://realpython.com/python-bindings-overview/#python-bindings-overview" target="_blank" rel="noopener">Python Bindings: Calling C or C++ From Python</a></li><li><a href="https://blog.csdn.net/xiangguiwang/article/details/81939237" target="_blank" rel="noopener">-fpic 与-fPIC的区别</a></li><li><a href="http://blog.sina.com.cn/s/blog_7243284f01012qqh.html" target="_blank" rel="noopener">Linux下Gcc生成和使用静态库和动态库详解</a></li><li><a href="https://blog.csdn.net/qq_38923792/article/details/95210227" target="_blank" rel="noopener">python3调用C语言代码</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;混合编程之 Python调用C&lt;/p&gt;
    
    </summary>
    
    
      <category term="C" scheme="https://www.wuchenxu.com/categories/C/"/>
    
      <category term="Python" scheme="https://www.wuchenxu.com/categories/C/Python/"/>
    
    
      <category term="Python" scheme="https://www.wuchenxu.com/tags/Python/"/>
    
      <category term="C" scheme="https://www.wuchenxu.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>The Clean Coder by Robert C. Martin</title>
    <link href="https://www.wuchenxu.com/2019/10/07/reading-notes-5-The-Clean-Coder/"/>
    <id>https://www.wuchenxu.com/2019/10/07/reading-notes-5-The-Clean-Coder/</id>
    <published>2019-10-07T13:44:27.000Z</published>
    <updated>2019-10-07T13:53:01.559Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/10/07/reading-notes-5-The-Clean-Coder/clean_coder_cover.jpg" class=""><a id="more"></a><img src="/2019/10/07/reading-notes-5-The-Clean-Coder/Clean_Coder.png" class="">]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2019/10/07/reading-notes-5-The-Clean-Coder/clean_coder_cover.jpg&quot; class=&quot;&quot;&gt;
    
    </summary>
    
    
      <category term="reading-notes" scheme="https://www.wuchenxu.com/categories/reading-notes/"/>
    
    
      <category term="reading-notes" scheme="https://www.wuchenxu.com/tags/reading-notes/"/>
    
      <category term="coder" scheme="https://www.wuchenxu.com/tags/coder/"/>
    
  </entry>
  
  <entry>
    <title>Head Frist 设计模式 by Freeman E.</title>
    <link href="https://www.wuchenxu.com/2019/05/02/reading-notes-4-Head-First-Design-Pattern/"/>
    <id>https://www.wuchenxu.com/2019/05/02/reading-notes-4-Head-First-Design-Pattern/</id>
    <published>2019-05-02T09:28:05.000Z</published>
    <updated>2020-05-30T14:30:25.254Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/02/reading-notes-4-Head-First-Design-Pattern/HFDP.jpg" class=""><a id="more"></a><h1 id="Head-First-Design-Patterns"><a href="#Head-First-Design-Patterns" class="headerlink" title="Head First Design Patterns"></a>Head First Design Patterns</h1><h2 id="Head-Frist学习原则"><a href="#Head-Frist学习原则" class="headerlink" title="Head Frist学习原则"></a>Head Frist学习原则</h2><ol><li>慢一点，你理解的越多，需要记的就越少。</li><li>勤做练习，自己记笔记。</li><li>There are no dumb Questions。</li><li>上床睡觉之前不要再看别的书了，或者至少不再看其他有难度的东西。</li><li>要喝水，而且要多喝水。</li><li>大声说出来。</li><li>听听你大脑怎么说。</li><li>要有点感觉！</li><li>设计一些东西！</li></ol><h2 id="为什么需要设计模式"><a href="#为什么需要设计模式" class="headerlink" title="为什么需要设计模式"></a>为什么需要设计模式</h2><ol><li>知道OO基础，并不足以让你设计出良好的OO系统。</li><li>良好的OO设计必须具备可复用、可扩展、可维护三个特性。</li><li>模式可以让我们建造出具有良好OO设计质量的系统。</li><li>模式被认为是经过验证的OO设计经验。</li><li>模式不是代码，而是针对设计问题的通用解决方案。你可以把它们应用到特定的应用中。</li><li>模式不是被发明，而是被发现。</li><li>大多数的模式和原则着眼于软件变化的主题。</li><li>大多数的模式都允许系统局部变化独立于其他部分。</li><li>我们常把系统中变化的部分抽出来封装。</li><li>模式让开发人员之间有共享的语言，能够最大化沟通的价值。</li></ol><h1 id="OO基础"><a href="#OO基础" class="headerlink" title="OO基础"></a>OO基础</h1><ol><li>抽象（Abstract）</li><li>封装（Encapsulate）</li><li>多态（Polymorphic）</li><li>继承（Inheritance）</li></ol><h1 id="OO设计原则"><a href="#OO设计原则" class="headerlink" title="OO设计原则"></a>OO设计原则</h1><h2 id="高内聚，低耦合"><a href="#高内聚，低耦合" class="headerlink" title="高内聚，低耦合"></a>高内聚，低耦合</h2><blockquote><p>High cohesion, low coupling.<br>这是最基本的设计原则，其他原则可以认为是该原则的外延。</p></blockquote><h2 id="单一职责原则（Single-Responsibility-Priciple）"><a href="#单一职责原则（Single-Responsibility-Priciple）" class="headerlink" title="单一职责原则（Single Responsibility Priciple）"></a>单一职责原则（<strong>S</strong>ingle <strong>R</strong>esponsibility <strong>P</strong>riciple）</h2><blockquote><p>一个类应该只有一个职责。一个类应该只有一个引起变化的原因。</p></blockquote><h2 id="开闭原则（Open-Closed-Priciple）"><a href="#开闭原则（Open-Closed-Priciple）" class="headerlink" title="开闭原则（Open/Closed Priciple）"></a>开闭原则（<strong>O</strong>pen/<strong>C</strong>losed <strong>P</strong>riciple）</h2><blockquote><p>类应该对扩展开放，对修改关闭。Open to extension and closed to modifcaiton.</p></blockquote><p>遵循开放-关闭原则通常会引入新的抽象层次，增加代码的复杂度。我们要把注意力几种在设计中最有可能改变的地方来应用开闭原则。</p><h2 id="里氏代换原则（Liskov-Substitution-Priciple）"><a href="#里氏代换原则（Liskov-Substitution-Priciple）" class="headerlink" title="里氏代换原则（Liskov Substitution Priciple）"></a>里氏代换原则（<strong>L</strong>iskov <strong>S</strong>ubstitution <strong>P</strong>riciple）</h2><blockquote><p>一个可以接受基类对象的地方必然可以接受一个子类对象。</p></blockquote><h2 id="接口隔离原则（Interface-Segregation-Priciple）"><a href="#接口隔离原则（Interface-Segregation-Priciple）" class="headerlink" title="接口隔离原则（Interface Segregation Priciple）"></a>接口隔离原则（<strong>I</strong>nterface <strong>S</strong>egregation <strong>P</strong>riciple）</h2><blockquote><p>使用多个专门接口来取代一个统一的接口。</p></blockquote><h2 id="依赖倒置原则（Dependence-Inversion-Principle）"><a href="#依赖倒置原则（Dependence-Inversion-Principle）" class="headerlink" title="依赖倒置原则（Dependence Inversion Principle）"></a>依赖倒置原则（<strong>D</strong>ependence <strong>I</strong>nversion <strong>P</strong>rinciple）</h2><blockquote><p>要依赖抽象，不要依赖具体类。</p></blockquote><h2 id="针对接口编程，不针对实现编程（Program-to-interface，-not-an-implementation）"><a href="#针对接口编程，不针对实现编程（Program-to-interface，-not-an-implementation）" class="headerlink" title="针对接口编程，不针对实现编程（Program to interface， not an implementation）"></a>针对接口编程，不针对实现编程（Program to interface， not an implementation）</h2><h2 id="封装变化（Encapsulate-what-varies）"><a href="#封装变化（Encapsulate-what-varies）" class="headerlink" title="封装变化（Encapsulate what varies）"></a>封装变化（Encapsulate what varies）</h2><h2 id="合成复用原则（Composite-Reuse-Principle）"><a href="#合成复用原则（Composite-Reuse-Principle）" class="headerlink" title="合成复用原则（Composite Reuse Principle）"></a>合成复用原则（<strong>C</strong>omposite <strong>R</strong>euse <strong>P</strong>rinciple）</h2><blockquote><p>多用组合，少用继承（Composition Favor over inheritance）</p></blockquote><h2 id="为交互对象之间的松耦合设计而努力（loose-coupling）"><a href="#为交互对象之间的松耦合设计而努力（loose-coupling）" class="headerlink" title="为交互对象之间的松耦合设计而努力（loose coupling）"></a>为交互对象之间的松耦合设计而努力（loose coupling）</h2><h2 id="最少知识原则（Least-Knowledge-Principle）"><a href="#最少知识原则（Least-Knowledge-Principle）" class="headerlink" title="最少知识原则（Least Knowledge Principle）"></a>最少知识原则（<strong>L</strong>east <strong>K</strong>nowledge <strong>P</strong>rinciple）</h2><p>又称为<code>迪米特法则（Law of Demeter）</code></p><blockquote><p>只和你的密友谈话。</p></blockquote><h2 id="好莱坞原则（Hollywood-Principle）"><a href="#好莱坞原则（Hollywood-Principle）" class="headerlink" title="好莱坞原则（Hollywood Principle）"></a>好莱坞原则（Hollywood Principle）</h2><blockquote><p>别调用我们，我们会调用你。（Dont’t call us, we will call you.）</p></blockquote><p>将决策权放在高层模块中，以便决定如何以及何时调用低层模块。</p><h1 id="与架构模式、框架、模块的对比"><a href="#与架构模式、框架、模块的对比" class="headerlink" title="与架构模式、框架、模块的对比"></a>与架构模式、框架、模块的对比</h1><p>参考<a href="https://wuchenxu.com/2017/05/05/reading-notes-2-practice-guide-for-frontline-architects/" target="_blank" rel="noopener">一线架构师实践指南</a><br>设计模式，相比架构模式应用面更狭窄，针对于特定场景；相比与框架活着模块，更抽象。框架、模块本身也会用到设计模式。</p><img src="/2019/05/02/reading-notes-4-Head-First-Design-Pattern/design-patten_framework_architecture_module.jpeg" class=""><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote><p><strong><code>策略模式（Strategy Pattern）</code></strong>定义算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。</p></blockquote><ul><li><p><a href="#OO设计原则">设计原则</a>：多用组合，少用继承; 封装变化；针对接口编程，不针对实现编程。</p></li><li><p><code>IS-A</code>：继承 ； <code>HAS-A/Implements</code>：组合</p></li><li><p>继承可以在垂直层次上共享代码，但是在水平层次上无能为力；而通过组合可以在水平层面上共享代码。</p></li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><a href="https://github.com/WuChenxu/Ruby/tree/master/HeadFirstDesignPattern/StrategyPattern" target="_blank" rel="noopener">strategy pattern in ruby</a></p><h3 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h3><img src="/2019/05/02/reading-notes-4-Head-First-Design-Pattern/strategy_pattern.svg" class="" title="strategy pattern UML"><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><blockquote><p><strong><code>观察者模式（Observer Pattern）</code></strong>在对象之间定义一对多依赖，当一个对象的状态改变时，它的所有依赖者都会收到通知并自动更新。</p></blockquote><ul><li><p><a href="#OO设计原则">设计原则</a> ：松耦合；好莱坞原则。</p></li><li><p><code>观察者</code>和<code>可观察者</code>（主题）之间用松耦合方式结合（loose coupling），<code>可观察者</code>不知道<code>观察者</code>的细节，只知道<code>观察者</code>实现了<code>观察者</code>接口。</p></li><li><p>使用观察者模式，可以从观察者处推（push）或者拉（pull）数据。</p></li><li><p>有多个观察者时，不可以依赖特定的通知次序。</p></li></ul><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p><a href="https://github.com/WuChenxu/Ruby/tree/master/HeadFirstDesignPattern/ObserverPattern" target="_blank" rel="noopener">observer pattern in ruby</a></p><h3 id="UML-1"><a href="#UML-1" class="headerlink" title="UML"></a>UML</h3><img src="/2019/05/02/reading-notes-4-Head-First-Design-Pattern/observer_pattern.svg" class="" title="observer pattern UML"><h3 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a>常见场景</h3><p>GUI框架里的按键等组件，注册不同的观察者到组件的不同类型事件上（如按键按下）。</p><h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><blockquote><p><strong><code>装饰者模式（Decorator/Wrapper Pattern）</code></strong>动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。</p></blockquote><ul><li><a href="#OO设计原则">设计原则</a> ：类应对扩展开放，对修改关闭。</li><li>装饰者和被装饰者对象有相同的超类，这里利用继承来达到“类型匹配”，而不是用继承来获得“行为”。</li><li>可以用一个或多个装饰着包装一个对象。</li><li>装饰者可以在所委托被装饰者的行为之前与/或之后，加上自己的行为。</li><li>装饰者一般对组件的客户是透明的，除非客户程序依赖于组件的具体类型。</li><li>装饰者会导致设计中出现许多小对象，如果过度使用，会让程序变得很复杂。</li><li>装饰者将一个对象包装起来以增加新的行为和责任；<a href="#适配器模式">适配器</a>将一个对象包装起来以改变其接口；<a href="#外观模式">外观</a>将一群对象“包装”起来以简化接口。</li><li>Decorator <code>IS</code> a component, AND <code>HAS</code> a component.</li></ul><ul><li>相关模式：<a href="#适配器模式">适配器</a>,<a href="#外观模式">外观模式</a></li></ul><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p><a href="https://github.com/WuChenxu/Ruby/tree/master/HeadFirstDesignPattern/DecoratorPattern" target="_blank" rel="noopener">decorator pattern in ruby</a></p><img src="/2019/05/02/reading-notes-4-Head-First-Design-Pattern/decorator_pattern_example.jpg" class="" title="decorator pattern example"><h3 id="UML-2"><a href="#UML-2" class="headerlink" title="UML"></a>UML</h3><img src="/2019/05/02/reading-notes-4-Head-First-Design-Pattern/decorator_pattern.svg" class="" title="decorator pattern UML"><img src="/2019/05/02/reading-notes-4-Head-First-Design-Pattern/decorator_coffee.jpg" class="" title="call sequence"><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><blockquote><p><strong><code>工厂方法模式（Factory Method Pattern）</code></strong>定义了创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。</p></blockquote><ul><li><a href="#OO设计原则">设计原则</a> ：要依赖抽象，不要依赖具体类；好莱坞原则。</li><li>所有的工厂都是用来封装对象的创建的。</li><li>工厂方法使用继承：把对象的创建委托给子类，子类实现工厂方法来创建对象；抽象工厂使用对象组合：对象的创建被实现在工厂接口所暴露出来的方法中。</li><li>所有的工厂模式都通过减少应用程序和具体类之间的依赖促进松耦合。</li><li>工厂方法允许类将实例化延迟到子类。</li><li>抽象工厂创建相关的对象家族，而不需要依赖它们的具体类。</li></ul><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><p><a href="https://github.com/WuChenxu/Ruby/tree/master/HeadFirstDesignPattern/FactoryMethodPattern" target="_blank" rel="noopener">factory method pattern in ruby</a></p><h3 id="UML-3"><a href="#UML-3" class="headerlink" title="UML"></a>UML</h3><img src="/2019/05/02/reading-notes-4-Head-First-Design-Pattern/factory_method_pattern.svg" class="" title="factory method pattern UML"><h3 id="常见场景-1"><a href="#常见场景-1" class="headerlink" title="常见场景"></a>常见场景</h3><p>Game里在不同的级别创建地图<br>插件plugin</p><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><blockquote><p><strong><code>抽象工厂模式（Abstract Factory Pattern）</code></strong>提供了一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。</p></blockquote><p>与工厂方法模式的主要区别是，抽象共产模式可以创建不同产品类型的组合（只有特定的组合是有意义的）。</p><h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><h3 id="UML-4"><a href="#UML-4" class="headerlink" title="UML"></a>UML</h3><h3 id="常见场景-2"><a href="#常见场景-2" class="headerlink" title="常见场景"></a>常见场景</h3><p>不同platform（windows，macOS，linux）上的UI<br>不同的主题（黑底白字，白底黑字）</p><h2 id="单件模式"><a href="#单件模式" class="headerlink" title="单件模式"></a>单件模式</h2><h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h3><blockquote><p><strong><code>单件模式（Singleton Pattern）</code></strong>确保一个类只有一个实例，并提供一个全局访问点。</p></blockquote><ul><li>在JAVA中实现单件模式需要私有的构造器、一个静态方法和一个静态变量。</li><li>确定在性能和资源上的限制，然后小心地选择适当的方案来实现单件，以解决多线程问题（我们必须认定所有的程序都是多线程的）。</li></ul><h3 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h3><p><a href="https://github.com/WuChenxu/Ruby/tree/master/HeadFirstDesignPattern/SingletonPattern" target="_blank" rel="noopener">singleton pattern in ruby</a></p><h3 id="UML-5"><a href="#UML-5" class="headerlink" title="UML"></a>UML</h3><img src="/2019/05/02/reading-notes-4-Head-First-Design-Pattern/singleton_pattern.svg" class="" title="singleton pattern UML"><h3 id="常见场景-3"><a href="#常见场景-3" class="headerlink" title="常见场景"></a>常见场景</h3><p>共享资源管理，如线程池（thread pool）、缓存池（cache）、注册表设置（registry setting）。</p><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><h3 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h3><blockquote><p><strong><code>命令模式（Command Pattern）</code></strong>将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。</p></blockquote><ul><li><a href="#OO设计原则">设计原则</a> ：松耦合。</li><li>在被解耦的两者之间是通过命令对象进行沟通的，命令对象封装了接受者和一个或一组动作。</li><li>调用者通过调用命令对象的execute()发出请求，这会使得接收者的动作被调用。</li><li>调用者可以接受命令当作参数，甚至在运行时动态地进行。</li><li>命令可以支持撤销，做法是实现一个undo()方法来回到execute()被执行前的状态。</li><li>宏命令是命令的一种简单的延伸，允许调用多个命令。宏方法也可以支持撤销。</li><li>实际操作时，很常见使用“聪明”命令对象，也就是直接实现了请求，而不是将工作委托给接收者。</li></ul><h3 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h3><h3 id="UML-6"><a href="#UML-6" class="headerlink" title="UML"></a>UML</h3><h3 id="常见场景-4"><a href="#常见场景-4" class="headerlink" title="常见场景"></a>常见场景</h3><p>队列请求（日程安排，线程池，工作队列等），日志请求，事务系统。</p><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><h3 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h3><blockquote><p><strong><code>适配器模式（Adapter Pattern）</code></strong>将一个类的接口，转换成客户期望的另一个接口。适配器让原来接口不兼容的类可以合作无间。</p></blockquote><ul><li><p>当使用一个现有的类而其接口并不符合你的需求时，就使用适配器。</p></li><li><p>适配器改变接口以符合客户的期望。</p></li><li><p>实现一个适配器可能需要一番功夫，也可能不费功夫，视目标接口的大小与复杂度而定。</p></li><li><p>适配器有两种形式：对象适配器和类适配器。类适配器需要用到多重继承。</p></li><li><p>适配器将一个对象包装起来以改变其接口；<a href="#装饰者模式">装饰者</a>将一个对象包装起来以增加新的行为和责任；<a href="#外观模式">外观</a>将一群对象“包装”起来以简化接口。</p></li><li><p>相关模式：<a href="#外观模式">外观模式</a>，<a href="#装饰者模式">装饰者模式</a></p></li></ul><h3 id="实现-7"><a href="#实现-7" class="headerlink" title="实现"></a>实现</h3><h3 id="UML-7"><a href="#UML-7" class="headerlink" title="UML"></a>UML</h3><h3 id="常见场景-5"><a href="#常见场景-5" class="headerlink" title="常见场景"></a>常见场景</h3><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><h3 id="定义-8"><a href="#定义-8" class="headerlink" title="定义"></a>定义</h3><blockquote><p><strong><code>外观模式（Facade Pattern）</code></strong>提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。</p></blockquote><ul><li><a href="#OO设计原则">设计原则</a> ：最少知识原则。</li><li>当需要简化并统一一个很大的接口或者一群复杂的接口时，使用外观。</li><li>外观将客户从一个复杂的子系统中解耦。</li><li>实现一个外观，需要将子系统组合进外观中，然后将工作委托给子系统执行。</li><li>外观将一群对象“包装”起来以简化接口；<a href="#适配器模式">适配器</a>将一个对象包装起来以改变其接口；<a href="#装饰者模式">装饰者</a>将一个对象包装起来以增加新的行为和责任；</li><li>相关模式：<a href="#适配器模式">适配器模式</a>，<a href="#装饰者模式">装饰者模式</a></li></ul><h3 id="实现-8"><a href="#实现-8" class="headerlink" title="实现"></a>实现</h3><h3 id="UML-8"><a href="#UML-8" class="headerlink" title="UML"></a>UML</h3><h3 id="常见场景-6"><a href="#常见场景-6" class="headerlink" title="常见场景"></a>常见场景</h3><h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><h3 id="定义-9"><a href="#定义-9" class="headerlink" title="定义"></a>定义</h3><blockquote><p><strong><code>模板方法模式（Template Method Pattern）</code></strong>在一个方法中定义了一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。</p></blockquote><ul><li><a href="#OO设计原则">设计原则</a> ：好莱坞原则。</li><li>模板方法是一种重要的代码复用技巧。</li><li>模板方法的抽象类可以定义具体方法、抽象方法和钩子。</li><li>钩子是一种方法，它在抽象类中不做事，活着只做默认的事情，子类可以选择要不要取覆盖它。</li><li><a href="#策略模式">策略模式</a>和模板方法模式都封装算法，一个用组合，一个用继承。</li><li><a href="#工厂方法模式">工厂方法</a>由子类决定实例化哪个类，是模板方法的一个特殊版本。</li><li>相关模式：<a href="#工厂方法模式">工厂方法</a>，<a href="#策略模式">策略模式</a></li></ul><h3 id="实现-9"><a href="#实现-9" class="headerlink" title="实现"></a>实现</h3><h3 id="UML-9"><a href="#UML-9" class="headerlink" title="UML"></a>UML</h3><h3 id="常见场景-7"><a href="#常见场景-7" class="headerlink" title="常见场景"></a>常见场景</h3><p>排序算法（CompareTo接口），Swing窗口，Applet</p><h2 id="外观模式-1"><a href="#外观模式-1" class="headerlink" title="外观模式"></a>外观模式</h2><h3 id="定义-10"><a href="#定义-10" class="headerlink" title="定义"></a>定义</h3><blockquote><p><strong><code>外观模式（Facade Pattern）</code></strong>提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。</p></blockquote><ul><li><a href="#OO设计原则">设计原则</a> ：最少知识原则。</li><li>当需要简化并统一一个很大的接口或者一群复杂的接口时，使用外观。</li><li>外观将客户从一个复杂的子系统中解耦。</li><li>实现一个外观，需要将子系统组合进外观中，然后将工作委托给子系统执行。</li><li>外观将一群对象“包装”起来以简化接口；<a href="#适配器模式">适配器</a>将一个对象包装起来以改变其接口；<a href="#装饰者模式">装饰者</a>将一个对象包装起来以增加新的行为和责任；</li><li>相关模式：<a href="#适配器模式">适配器模式</a>，<a href="#装饰者模式">装饰者模式</a></li></ul><h3 id="实现-10"><a href="#实现-10" class="headerlink" title="实现"></a>实现</h3><h3 id="UML-10"><a href="#UML-10" class="headerlink" title="UML"></a>UML</h3><h3 id="常见场景-8"><a href="#常见场景-8" class="headerlink" title="常见场景"></a>常见场景</h3><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><h3 id="定义-11"><a href="#定义-11" class="headerlink" title="定义"></a>定义</h3><blockquote><p><strong><code>迭代器模式（Iterator Pattern）</code></strong>提供一种方法顺序访问一个聚合（aggregate）对象的各个元素，而又不暴露其内部的表示。</p></blockquote><ul><li><a href="#OO设计原则">设计原则</a> ：封装变化；单一职责。</li><li>迭代器将遍历聚合的工具封装进一个对象中。</li><li>当使用迭代器的时候，我们依赖聚合提供遍历。</li><li>把游走的任务放在迭代器上，而不是聚合上。这样简化了聚合的接口和实现，也让责任各得其所。</li><li>迭代器提供了一个通用的接口，让我们遍历聚合的项，当我们编码使用聚合的项时，就可以使用多态机制。</li><li>对迭代器而言，数据结构可以是有次序的，或者没有次序的，甚至数据可以重复的。除非某个集合的文件有特别说明，否则不可以对迭代器取出元素的大小顺序作假设。</li></ul><h3 id="实现-11"><a href="#实现-11" class="headerlink" title="实现"></a>实现</h3><h3 id="UML-11"><a href="#UML-11" class="headerlink" title="UML"></a>UML</h3><h3 id="常见场景-9"><a href="#常见场景-9" class="headerlink" title="常见场景"></a>常见场景</h3><p>排序算法（CompareTo接口），Swing窗口，Applet<br>Reference:</p><ol><li><a href="https://appliedstochastics.com/articles/hfdp_ruby_01.html" target="_blank" rel="noopener">strategy pattern in ruby</a></li><li><a href="http://www.cnblogs.com/zhaoyan001/p/6365064.html" target="_blank" rel="noopener">单例模式的八种写法比较</a></li><li><a href="https://thoughtbot.com/blog/evaluating-alternative-decorator-implementations-in" target="_blank" rel="noopener">Evaluating Alternative Decorator Implementations In Ruby</a></li><li><a href="https://www.bullmind.com/" target="_blank" rel="noopener">bullMind</a></li><li><a href="https://www.youtube.com/playlist?list=PLrhzvIcii6GNjpARdnO4ueTUAVR9eMBpc" target="_blank" rel="noopener">Design Patterns in Object Oriented Programming</a></li><li><a href="https://plantuml.com/zh/class-diagram" target="_blank" rel="noopener">plantuml</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2019/05/02/reading-notes-4-Head-First-Design-Pattern/HFDP.jpg&quot; class=&quot;&quot;&gt;
    
    </summary>
    
    
      <category term="reading-notes" scheme="https://www.wuchenxu.com/categories/reading-notes/"/>
    
    
      <category term="technical" scheme="https://www.wuchenxu.com/tags/technical/"/>
    
      <category term="reading-notes" scheme="https://www.wuchenxu.com/tags/reading-notes/"/>
    
      <category term="ruby" scheme="https://www.wuchenxu.com/tags/ruby/"/>
    
  </entry>
  
  <entry>
    <title>Unix/Linux command(1):find 与 grep</title>
    <link href="https://www.wuchenxu.com/2018/12/31/Unix-Linux-cmd-1-find-grep/"/>
    <id>https://www.wuchenxu.com/2018/12/31/Unix-Linux-cmd-1-find-grep/</id>
    <published>2018-12-31T14:10:04.000Z</published>
    <updated>2019-01-01T14:46:51.995Z</updated>
    
    <content type="html"><![CDATA[<p>find - search for files in a directory hierarchy<br>grep, egrep, fgrep, zgrep, zegrep, zfgrep - print lines that match patterns</p><a id="more"></a><p>此文与<a href="https://wuchenxu.com/2016/03/30/windows-cmd-9-find-findstr/" target="_blank" rel="noopener">windows command(9):FIND FINDSTR</a>对照。</p><h1 id="查找字符串"><a href="#查找字符串" class="headerlink" title="查找字符串"></a>查找字符串</h1><p>windows中的<code>find/findstr</code>更改为<code>grep</code>即可，实现在单个文件中查找某个字符串。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$grep</span> <span class="string">"hello there"</span> hi.txt</span><br><span class="line">hello there</span><br></pre></td></tr></table></figure><h1 id="查找的字符串中有-quot"><a href="#查找的字符串中有-quot" class="headerlink" title="查找的字符串中有&quot;"></a>查找的字符串中有<code>&quot;</code></h1><p>由于<code>grep</code>的pattern是支持正则表达式regex的，所有只要用<code>\&quot;</code>转义<code>&quot;</code>即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$grep</span> <span class="string">"\"hello"</span> hi.txt</span><br><span class="line">h<span class="string">"hello"</span>h</span><br></pre></td></tr></table></figure><h1 id="多文件查找"><a href="#多文件查找" class="headerlink" title="多文件查找"></a>多文件查找</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">"hello"</span> *.txt</span><br></pre></td></tr></table></figure><h1 id="查找目录"><a href="#查找目录" class="headerlink" title="查找目录"></a>查找目录</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grep -nir <span class="string">"music.163"</span> ./ <span class="comment"># 查找当前文件夹及其子目录下包含`music.163`字符串的文件，并打印行号</span></span><br><span class="line"></span><br><span class="line">find . -name <span class="string">"file_name"</span> | xargs grep -nir <span class="string">"search_string"</span> <span class="comment"># 过滤文件之后，对每个文件查找</span></span><br></pre></td></tr></table></figure><h1 id="显示行号"><a href="#显示行号" class="headerlink" title="显示行号"></a>显示行号</h1><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$grep</span> -n <span class="string">"hello"</span> hi.txt</span><br><span class="line"><span class="number">1</span><span class="symbol">:hello</span></span><br><span class="line"><span class="number">2</span><span class="symbol">:h<span class="string">"hello"</span>h</span></span><br><span class="line"><span class="number">3</span><span class="symbol">:hello</span> there</span><br></pre></td></tr></table></figure><h1 id="通配符查找"><a href="#通配符查找" class="headerlink" title="通配符查找"></a>通配符查找</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$grep</span>  <span class="string">'.*llo'</span> hi.txt</span><br><span class="line">hello</span><br><span class="line">h<span class="string">"hello"</span>h</span><br><span class="line">hello there</span><br></pre></td></tr></table></figure><h1 id="find"><a href="#find" class="headerlink" title="find"></a>find</h1><p>常用option：<br><code>-name</code>: name matching, can use regex.<br><code>-iname</code>: like<code>-name</code>, but case insensitive.<br><code>-regex</code>: regex匹配文件名（包含路径），eg<code>find ./ -regex &quot;.*/*hexo.py&quot;</code>.<br><code>-type</code>: file type.<code>d</code> is directory, <code>f</code> is file.</p><figure class="highlight bash"><figcaption><span>find-examples</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">find / \! -name <span class="string">"*.c"</span> -<span class="built_in">print</span></span><br><span class="line">     Print out a list of all the files whose names <span class="keyword">do</span> not end <span class="keyword">in</span> .c.</span><br><span class="line"></span><br><span class="line">find / -newer ttt -user wnj -<span class="built_in">print</span></span><br><span class="line">     Print out a list of all the files owned by user ``wnj<span class="string">''</span> that are</span><br><span class="line">     newer than the file ttt.</span><br><span class="line"></span><br><span class="line">find / \! \( -newer ttt -user wnj \) -<span class="built_in">print</span></span><br><span class="line">     Print out a list of all the files <span class="built_in">which</span> are not both newer than</span><br><span class="line">     ttt and owned by ``wnj<span class="string">''</span>.</span><br><span class="line"></span><br><span class="line">find / \( -newer ttt -or -user wnj \) -<span class="built_in">print</span></span><br><span class="line">     Print out a list of all the files that are either owned by</span><br><span class="line">     ``wnj<span class="string">''</span> or that are newer than ttt.</span><br><span class="line"></span><br><span class="line">find / -newerct <span class="string">'1 minute ago'</span> -<span class="built_in">print</span></span><br><span class="line">     Print out a list of all the files whose inode change time is more</span><br><span class="line">     recent than the current time minus one minute.</span><br><span class="line"></span><br><span class="line">find / -<span class="built_in">type</span> f -<span class="built_in">exec</span> <span class="built_in">echo</span> &#123;&#125; \;</span><br><span class="line">      Use the <span class="built_in">echo</span>(1) <span class="built_in">command</span> to <span class="built_in">print</span> out a list of all the files.</span><br><span class="line"></span><br><span class="line">find -L /usr/ports/packages -<span class="built_in">type</span> l -<span class="built_in">exec</span> rm -- &#123;&#125; +</span><br><span class="line">     Delete all broken symbolic links <span class="keyword">in</span> /usr/ports/packages.</span><br><span class="line"></span><br><span class="line">find /usr/src -name CVS -prune -o -depth +6 -<span class="built_in">print</span></span><br><span class="line">     Find files and directories that are at least seven levels deep <span class="keyword">in</span></span><br><span class="line">     the working directory /usr/src.</span><br><span class="line"></span><br><span class="line">find /usr/src -name CVS -prune -o -mindepth 7 -<span class="built_in">print</span></span><br><span class="line">     Is not equivalent to the previous example, since -prune is not</span><br><span class="line">     evaluated below level seven.</span><br></pre></td></tr></table></figure><h1 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h1><p>常用option:<br><code>-i（--ignore-case）</code>: 忽略大小写<br><code>-r (--recursive）</code>: 递归查找子目录<br><code>-n (--line-number)</code>: 打印行号<br><code>-l (--files-with-match)</code>: 只打印匹配的文件名</p><figure class="highlight bash"><figcaption><span>grep-examples</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># To find all occurrences of the word `patricia' in a file:</span></span><br><span class="line"></span><br><span class="line">$ grep <span class="string">'patricia'</span> myfile</span><br><span class="line"></span><br><span class="line"><span class="comment"># To find all occurrences of the pattern `.Pp' at the beginning of a line:</span></span><br><span class="line"></span><br><span class="line">$ grep <span class="string">'^\.Pp'</span> myfile</span><br><span class="line"></span><br><span class="line"><span class="comment"># The apostrophes ensure the entire expression is evaluated by grep instead</span></span><br><span class="line"><span class="comment"># of by the user's shell.  The caret `^' matches the null string at the</span></span><br><span class="line"><span class="comment"># beginning of a line, and the `\' escapes the `.', which would otherwise</span></span><br><span class="line"><span class="comment"># match any character.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># To find all lines in a file which do not contain the words `foo' or</span></span><br><span class="line"><span class="comment"># `bar':</span></span><br><span class="line"></span><br><span class="line">$ grep -v -e <span class="string">'foo'</span> -e <span class="string">'bar'</span> myfile</span><br><span class="line"></span><br><span class="line"><span class="comment"># A simple example of an extended regular expression:</span></span><br><span class="line">$ egrep <span class="string">'19|20|25'</span> calendar</span><br><span class="line"><span class="comment"># Peruses the file `calendar' looking for either 19, 20, or 25.</span></span><br></pre></td></tr></table></figure><p>References:</p><ol><li><code>man find</code> 与 <code>man grep</code></li><li><a href="http://man7.org/linux/man-pages/man1/find.1.html" target="_blank" rel="noopener">man find</a></li><li><a href="http://www.tutorialspoint.com/unix_commands/find.htm" target="_blank" rel="noopener">find example</a></li><li><a href="http://man7.org/linux/man-pages/man1/grep.1.html" target="_blank" rel="noopener">man grep</a></li><li><a href="http://www.tutorialspoint.com/unix_commands/grep.htm" target="_blank" rel="noopener">grep example</a></li><li><a href="http://www.cnblogs.com/jiangzhaowei/p/5451173.html" target="_blank" rel="noopener">linux find -regex 使用正则表达式</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;find - search for files in a directory hierarchy&lt;br&gt;grep, egrep, fgrep, zgrep, zegrep, zfgrep - print lines that match patterns&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux cmd" scheme="https://www.wuchenxu.com/categories/Linux-cmd/"/>
    
    
      <category term="Linux cmd" scheme="https://www.wuchenxu.com/tags/Linux-cmd/"/>
    
  </entry>
  
  <entry>
    <title>理想的知识结构模型</title>
    <link href="https://www.wuchenxu.com/2018/12/27/Knowledge-model/"/>
    <id>https://www.wuchenxu.com/2018/12/27/Knowledge-model/</id>
    <published>2018-12-27T14:14:20.000Z</published>
    <updated>2021-09-11T13:54:59.824Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/12/27/Knowledge-model/knowledge-model.jpeg" class=""><blockquote><p>在某个领域深耕细作的同时，不要忘记拓宽自己的知识面。如果一个人的领域太过专业化，一段时间后，你可能会发现自己的专业已经陈旧了。如果一个人的知识面很广，在终身教育的配合下，你的专业可以随着时代的变化而改变。<br>—  《MacTalk跨越边界》</p></blockquote><a id="more"></a><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>知识的广度（Breath）是指在很多领域都知道一点点知识（know a little about a lot);<br>知识的深度（Deepth）是指在某个领域知道很多很深的知识（know a lot about a little）。<br>理想的知识结构模型应该是T字形，横表示广度，竖表示深度。缺一不可。</p><p><a href="https://wiki.mbalib.com/wiki/%E6%9C%A8%E6%A1%B6%E5%8E%9F%E7%90%86" target="_blank" rel="noopener">木桶理论</a>过分强调不要短板，广度优先，处处平衡;<br><a href="https://baike.sogou.com/v62597640.htm?fromTitle=%E9%95%BF%E6%9D%BF%E7%90%86%E8%AE%BA" target="_blank" rel="noopener">长板理论</a>过分强调深度，深度优先，精耕细作。<br>考虑到多个领域，可以是多个T的叠加（有些地方称为π型结构, π type talent），最终的结果就是类似于上图所示的图形，有点像二师兄的九齿钉耙。 :)<br>如果考虑到知识随着时间的迭代（动态性），那么我们最终会看到三个维度：</p><ul><li>广度：博</li><li>深度：专</li><li>时间：新</li></ul><h1 id="知识分类"><a href="#知识分类" class="headerlink" title="知识分类"></a>知识分类</h1><h2 id="广义"><a href="#广义" class="headerlink" title="广义"></a>广义</h2><p>所有的文字、语言、经验、哲学、科学、宗教都可以算是一种广义的知识。</p><h2 id="狭义"><a href="#狭义" class="headerlink" title="狭义"></a>狭义</h2><p>以软件开发为例：</p><ul><li>通用性的：如C语言、编程范式、设计模式、软件架构、软件开发流程。。。</li><li>领域相关的：如汽车领域软件开发：AUTOSAR架构、诊断、ASPICE、ISO26262.。。</li><li>产品相关的：如ADAS产品软件开发： 功能、距离检测算法、路径规划、横向控制、纵向控制。。。</li></ul><h1 id="训练方法"><a href="#训练方法" class="headerlink" title="训练方法"></a>训练方法</h1><ul><li>广度：<a href="https://ideas.ted.com/dont-have-10000-hours-to-learn-something-new-thats-fine-all-you-need-is-20-hours/" target="_blank" rel="noopener">关键20小时</a></li></ul><ol><li>Break down a skill into its components.</li><li>Learn enough to know when you’re making a mistake.</li><li>Remove any and all barriers to practice.</li><li>Practice for at least 20 hours.</li></ol><ul><li><p>深度：10000小时理论<br>人们眼中的天才之所以卓越非凡，并非天资超人一等，而是付出了持续不断的努力。只要经过1万小时的锤炼，任何人都能从平凡变成超凡。 — 《异类》（Utliers）</p></li><li><p>时间：<br>根据不同的知识种类进行迭代，可以通过RSS订阅，查看最新的前沿论文等。<br>职位的变化也需要重新调整知识结构，比如同样是沟通技能，在技术岗位转成领导岗位的要求程度是不一样的。</p></li></ul><p>Reference:</p><ol><li><a href="https://blog.csdn.net/u014805066/article/details/64437617" target="_blank" rel="noopener">T型知识结构</a></li><li><a href="https://ideas.ted.com/dont-have-10000-hours-to-learn-something-new-thats-fine-all-you-need-is-20-hours/" target="_blank" rel="noopener">20 hours to learn something new</a></li><li><a href="https://www.zhihu.com/question/19933005" target="_blank" rel="noopener">哪些网站适合用于充电、学习新知识？</a></li><li><a href="https://www.jianshu.com/p/d625356dc3c5" target="_blank" rel="noopener">实现从T型知识结构到π型知识结构的转变</a></li><li><a href="https://vimeo.com/83107245" target="_blank" rel="noopener">Steve Mann, Keynote Address, eLeo Symposium, 2013dec05, OCAD </a></li><li><a href="https://nested.substack.com/p/short-fat-engineers-are-undervalued" target="_blank" rel="noopener">Short Fat Engineers Are Undervalued</a></li><li><a href="https://www.ruanyifeng.com/blog/2021/09/weekly-issue-175.html" target="_blank" rel="noopener">科技爱好者周刊（第 175 期）：知识广度 vs 知识深度</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2018/12/27/Knowledge-model/knowledge-model.jpeg&quot; class=&quot;&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;在某个领域深耕细作的同时，不要忘记拓宽自己的知识面。如果一个人的领域太过专业化，一段时间后，你可能会发现自己的专业已经陈旧了。如果一个人的知识面很广，在终身教育的配合下，你的专业可以随着时代的变化而改变。&lt;br&gt;—  《MacTalk跨越边界》&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="knowledge" scheme="https://www.wuchenxu.com/categories/knowledge/"/>
    
    
      <category term="knowledge" scheme="https://www.wuchenxu.com/tags/knowledge/"/>
    
  </entry>
  
  <entry>
    <title>functional safety and cyber security</title>
    <link href="https://www.wuchenxu.com/2018/05/11/safety-and-security/"/>
    <id>https://www.wuchenxu.com/2018/05/11/safety-and-security/</id>
    <published>2018-05-11T14:03:39.000Z</published>
    <updated>2018-05-11T15:23:04.237Z</updated>
    
    <content type="html"><![CDATA[<p>safety: 安全，侧重于防止系统的内部故障导致生命财产损失。<br>security： 安保/防护，侧重于防止外部侵入导致生命财产损失。<br>对应到汽车领域：functional safety(功能安全)与cyber security(网络安全)</p><a id="more"></a><h1 id="overview"><a href="#overview" class="headerlink" title="overview"></a>overview</h1><p>functional safety: absence of unreasonable risk due to hazards caused by malfunctioning behavior of E/E systems.<br>Cyber security : protection of systems from the theft and damage to their hardware, software or information, as well as from disruption or misdirection of the services they provide.</p><img src="/2018/05/11/safety-and-security/overview_safety_security.png" class=""><p>功能安全还有个进化版本 SOTIF(Safety of the intended functionality, ISO21448).</p><h1 id="method"><a href="#method" class="headerlink" title="method"></a>method</h1><p>功能安全和网络安全的方法都需要在考虑整个产品生命周期（life cycle）的基础上，从两个大的方面来实施：技术与流程。</p><img src="/2018/05/11/safety-and-security/methods_safety_security.png" class=""><p>功能安全的一些方法在ISO26262里有详细的推荐，包括硬件失效分析以及诊断方法，软件开发方法，测试方法等。</p><img src="/2018/05/11/safety-and-security/security_solutions.png" class=""><img src="/2018/05/11/safety-and-security/safety_efforts.png" class=""><h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><p><a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check" target="_blank" rel="noopener">CRC(Cyclic redundancy check)</a> - safety point of view: data error detection<br><a href="https://en.wikipedia.org/wiki/Message_authentication_code#Security" target="_blank" rel="noopener">MAC(Message authentication code)</a> - security point of view：data autenticity check.</p><p>References</p><ol><li><a href="https://www.zhihu.com/question/28426435?sort=created" target="_blank" rel="noopener">关于safety和security的翻译问题</a></li><li><a href="https://www.controleng.com/single-article/combining-functional-safety-and-cyber-security/" target="_blank" rel="noopener">Combining functional safety and cyber security</a></li><li><a href="https://vector.com/technologie-tage/files/VTT17_Grundlagenseminar_Security_Safety.pdf" target="_blank" rel="noopener">Functional safety and cyber security</a></li><li><a href="http://www.umtri.umich.edu/sites/default/files/Safety.2014.Andre_.Weimerskirch_0.pdf" target="_blank" rel="noopener">The relevance of cyber-security to functional safety of connected and automated vehicles</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;safety: 安全，侧重于防止系统的内部故障导致生命财产损失。&lt;br&gt;security： 安保/防护，侧重于防止外部侵入导致生命财产损失。&lt;br&gt;对应到汽车领域：functional safety(功能安全)与cyber security(网络安全)&lt;/p&gt;
    
    </summary>
    
    
      <category term="safety" scheme="https://www.wuchenxu.com/categories/safety/"/>
    
      <category term="security" scheme="https://www.wuchenxu.com/categories/safety/security/"/>
    
    
      <category term="safety" scheme="https://www.wuchenxu.com/tags/safety/"/>
    
      <category term="security" scheme="https://www.wuchenxu.com/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>软件开发(3):软件集成重名解决方案</title>
    <link href="https://www.wuchenxu.com/2018/04/15/integrate-files-with-same-name-same-function-in-C/"/>
    <id>https://www.wuchenxu.com/2018/04/15/integrate-files-with-same-name-same-function-in-C/</id>
    <published>2018-04-15T09:55:16.000Z</published>
    <updated>2019-01-01T14:40:02.539Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍了一种在软件集成过程中，遇到重名文件 和/或 重名函数时的解决方案。</p><a id="more"></a><h1 id="why"><a href="#why" class="headerlink" title="why"></a>why</h1><p>在<a href="https://wuchenxu.com/2017/02/27/software-design-2-variant-handling/" target="_blank" rel="noopener">software development(2):variant handling</a>一文中介绍了很多种variant管理的方法，其中有关于[link different libs](<a href="https://wuchenxu.com/2017/02/27/software-design-2-variant-handling/#link" target="_blank" rel="noopener">https://wuchenxu.com/2017/02/27/software-design-2-variant-handling/#link</a> different libs)的方法。<br>设想如下场景：开发过程中（针对C语言），各个模块分别由不同的团队开发，最后集成的时候，如果遇到重名的函数怎么处理？<br>本文针对这种场景，搜集了几种解决方案。</p><h1 id="what"><a href="#what" class="headerlink" title="what"></a>what</h1><p>场景设置: 三个模块，<code>a</code> <code>b</code> <code>os</code>，其中<code>a</code>和<code>b</code>模块都包含一个名字为<code>func_internal.c</code>的文件，这个同名文件中包含了名字一样的函数，分别为<code>int func_internal(void)</code>与<code>int func_internal(int a)</code>。这两个函数都没有申明为static，但是没有外部调用。</p><p><a href="https://github.com/WuChenxu/C/tree/master/link2step" target="_blank" rel="noopener">demo in github</a></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── README.md</span><br><span class="line">├── component_a</span><br><span class="line">│   ├── exported_sym.list</span><br><span class="line">│   ├── func_a.c</span><br><span class="line">│   ├── func_internal.c</span><br><span class="line">│   ├── func_internal.h</span><br><span class="line">│   ├── functions.h</span><br><span class="line">│   ├── makefile</span><br><span class="line">│   └── redefine.syms</span><br><span class="line">├── component_b</span><br><span class="line">│   ├── exported_sym.list</span><br><span class="line">│   ├── func_b.c</span><br><span class="line">│   ├── func_internal.c</span><br><span class="line">│   ├── func_internal.h</span><br><span class="line">│   ├── functions.h</span><br><span class="line">│   └── makefile</span><br><span class="line">├── makefile</span><br><span class="line">├── obj</span><br><span class="line">└── os</span><br><span class="line">    ├── exported_sym.list</span><br><span class="line">    ├── main.c</span><br><span class="line">    └── makefile</span><br></pre></td></tr></table></figure><figure class="highlight c"><figcaption><span> component_a/func_a.c</span><a href="/downloads/code/link2steps/component_a/func_a.c">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"functions.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"func_internal.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">func_internal_s</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func_a</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">   <span class="keyword">int</span> a = func_internal();</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"this is func a. %d\n"</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"this is static internal %d\n"</span>, func_internal_s());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure><figure class="highlight c"><figcaption><span> component_a/func_internal.c</span><a href="/downloads/code/link2steps/component_a/func_internal.c">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"functions.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func_internal</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><figure class="highlight c"><figcaption><span> component_b/func_b.c</span><a href="/downloads/code/link2steps/component_b/func_b.c">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"functions.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"func_internal.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">func_internal_s</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"func B %d\n"</span>, a);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func_b</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> a = func_internal(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"this is func b. %d"</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"internal func %d\n."</span>, func_internal_s(<span class="number">-100</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure><figure class="highlight c"><figcaption><span> component_b/func_internal.c</span><a href="/downloads/code/link2steps/component_b/func_internal.c">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"functions.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func_internal</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h1 id="how"><a href="#how" class="headerlink" title="how"></a>how</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol><li><p>由于有文件重名，所以不能每个<code>.c</code>单独编译成<code>.o</code>，然后再链接；<br>出现两个同名的<code>.o</code>，要不然链接器报错，要不然只用了其中一个<code>.o</code>，这样会导致运行时异常。</p></li><li><p>由于有函数重名，且函数没有申明为局部，链接的时候必然会出现错误：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">duplicate symbol _func_internal <span class="keyword">in</span>:</span><br><span class="line">    component_a/func_internal.o</span><br><span class="line">    component_b/func_internal.o</span><br></pre></td></tr></table></figure><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>本文采用的方法：<br>每个模块单独编译成一个<code>.o</code>文件。</p></li></ol><p>其他方法：</p><ol><li>重名文件改名；重名函数改名；局部函数申明为static。</li><li>定义函数时定义visibility属性（GUN only）<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((<span class="name">visibility</span>(<span class="string">"hidden"</span>)))</span><br></pre></td></tr></table></figure></li></ol><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>本文采用的方法：</p><p><code>-exported_symbols_list filename</code>(Mac) 或者 <code>--retain-symbols-file=filename</code>(linux)</p><figure class="highlight plain"><figcaption><span>link all the .o in each component to one .o file; and only export symbols in the list</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ld -r -exported_symbols_list exported_sym.list $&#123;OBJECTS&#125;  -o $&#123;TARGET&#125;.o</span><br></pre></td></tr></table></figure><img src="/2018/04/15/integrate-files-with-same-name-same-function-in-C/ld.png" class=""><p>其实是强制将符号表里的全局符号(<code>T</code>)变成了局部符号(<code>t</code>)，这样除了列表文件里的函数，其他对外均不可见。</p><p>其他方法：</p><ol><li><p>gcc在链接时设置 -fvisibility=hidden，则不加 visibility声明的都默认为hidden; gcc默认设置 -fvisibility=default，即全部可见；</p></li><li><p>使用export map，gcc -Wl,–version-script=export.map, 在export.map中指定</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="attribute">global</span>:export_func;</span><br><span class="line"></span><br><span class="line"><span class="attribute">local</span>:*;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h3 id="objcopy"><a href="#objcopy" class="headerlink" title="objcopy"></a>objcopy</h3><ol><li><p>将全局符号修改为局部符号：<br><code>-L symbolname</code></p></li><li><p>替换符号名<br><code>--redefine-sym old=new</code><br><code>--redefine-syms=filename</code></p></li></ol><h1 id="recap"><a href="#recap" class="headerlink" title="recap"></a>recap</h1><ol><li>由于C语言没有namespace的概念，可以在开发之前约定好，所有的<code>全局函数</code>和<code>全局变量</code>都加上特殊的前缀，eg. <code>CompanyName_ProductName_ComponentName_FunctionName</code>。</li><li>所有的局部函数定义都加上static。</li><li>可以先编译各个模块，再链接（类似于每个模块编译成静态库），这样可以防止重名的文件名报错。</li><li>可以在链接的时候控制各个模块编译后全局函数，将内部使用的但没有申明为static的函数，在符号表中强制修改为local的符号。</li><li>链接后，可以通过<code>objcopy</code>改变符号的属性（全局-&gt;局部）或者 修改全局符号的名字。</li></ol><p>Reference：</p><ol><li><a href="https://developer.apple.com/library/content/technotes/tn2185/_index.html#//apple_ref/doc/uid/DTS10004200-CH1-SUBSECTION5" target="_blank" rel="noopener">Choosing Visibility Options for Mac</a></li><li><a href="https://www.ibm.com/developerworks/aix/library/au-aix-symbol-visibility/index.html" target="_blank" rel="noopener">Introduction to symbol visibility</a></li><li><a href="http://www.man7.org/linux/man-pages/man1/ld.1.html" target="_blank" rel="noopener">man ld</a></li><li><a href="http://www.it1352.com/539295.html" target="_blank" rel="noopener">将两个GCC编译的.o目标文件合并到第三个.o文件中</a></li><li><a href="https://stackoverflow.com/questions/1506346/with-gcc-how-do-i-export-only-certain-functions-in-a-static-library" target="_blank" rel="noopener">export obly centain functioins in a static lib</a></li><li><a href="https://gcc.gnu.org/wiki/Visibility" target="_blank" rel="noopener">visibility of GCC</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍了一种在软件集成过程中，遇到重名文件 和/或 重名函数时的解决方案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="software" scheme="https://www.wuchenxu.com/categories/software/"/>
    
      <category term="build" scheme="https://www.wuchenxu.com/categories/software/build/"/>
    
    
      <category term="software" scheme="https://www.wuchenxu.com/tags/software/"/>
    
      <category term="build" scheme="https://www.wuchenxu.com/tags/build/"/>
    
      <category term="c-lang" scheme="https://www.wuchenxu.com/tags/c-lang/"/>
    
  </entry>
  
  <entry>
    <title>Machine Learning笔记</title>
    <link href="https://www.wuchenxu.com/2018/02/04/machine_learning_notes/"/>
    <id>https://www.wuchenxu.com/2018/02/04/machine_learning_notes/</id>
    <published>2018-02-04T12:38:54.000Z</published>
    <updated>2018-02-25T14:56:46.597Z</updated>
    
    <content type="html"><![CDATA[<p>学习吴恩达的machine learning课程笔记。</p><a id="more"></a><h1 id="resources"><a href="#resources" class="headerlink" title="resources"></a>resources</h1><h2 id="website"><a href="#website" class="headerlink" title="website"></a>website</h2><p><a href="http://cs229.stanford.edu/" target="_blank" rel="noopener">http://cs229.stanford.edu/</a><br><a href="https://see.stanford.edu/Course/CS229" target="_blank" rel="noopener">https://see.stanford.edu/Course/CS229</a></p><h2 id="tool"><a href="#tool" class="headerlink" title="tool"></a>tool</h2><p>商业软件<a href="https://www.mathworks.com/" target="_blank" rel="noopener">Matlab</a> or 免费开源软件<a href="http://www.gnu.org/software/octave/" target="_blank" rel="noopener">Octave</a></p><h1 id="动机与应用"><a href="#动机与应用" class="headerlink" title="动机与应用"></a>动机与应用</h1><h2 id="why？"><a href="#why？" class="headerlink" title="why？"></a>why？</h2><p>很多程序是无法手动编写出来的，eg. 手写文字识别，自动飞行器，自然语言处理NLP</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul><li>learning algorithm容易实现手动无法编写程序的问题。</li><li>learning algorithm在数据挖掘（data mining）有很好的效果，eg.电子化病例数据，帮助医生更好地决策</li><li>zip code识别</li><li>amazon，netflix推荐系统</li></ul><h2 id="machine-learning-definiton"><a href="#machine-learning-definiton" class="headerlink" title="machine learning definiton"></a>machine learning definiton</h2><ol><li><p>Arthur Samuel (1959). Machine Learning: Field of study that gives computers the ability to learn without being explicitly programmed.<br><code>Checkers program</code></p></li><li><p>Tom Mitchell (1998). Well-posed Learning Problem: A computer program is said to learn from experience E with respect to some task T and some performance measure P, if its performance on T, as measured by P, improves with experience E.</p></li></ol><h2 id="课程由4部分组成"><a href="#课程由4部分组成" class="headerlink" title="课程由4部分组成"></a>课程由4部分组成</h2><h3 id="Supervised-Learning-监督学习"><a href="#Supervised-Learning-监督学习" class="headerlink" title="Supervised Learning(监督学习)"></a>Supervised Learning(监督学习)</h3><p>监督学习中所有的样本都是带有标记的，“正确答案”已经在样本中。</p><ol><li><p>regression problem（回归问题）<br>预测的值是连续（continuous）的。</p><img src="/2018/02/04/machine_learning_notes/regression_problem_continuous.png" class="" title="regression problem"></li><li><p>classification problem（分类问题）<br>预测的值是离散（discreet）的,eg. SVM(supported vector machine)</p><img src="/2018/02/04/machine_learning_notes/classification_problem_discreet.png" class="" title="classification problem"></li></ol><h3 id="Learning-Theory"><a href="#Learning-Theory" class="headerlink" title="Learning Theory"></a>Learning Theory</h3><p>learning algorith 为什么是有效的；可以证明什么时候（eg.多大的数据量）可以保证算法有效（eg.&gt;99.9%的正确率)。</p><h3 id="Unspervised-Learning（无监督学习）"><a href="#Unspervised-Learning（无监督学习）" class="headerlink" title="Unspervised Learning（无监督学习）"></a>Unspervised Learning（无监督学习）</h3><p>无监督学习的样本是不带有标记的，无监督学习需要从数据中自己发现特定的结构。</p><ul><li><p><a href="https://en.wikipedia.org/wiki/Cluster_analysis" target="_blank" rel="noopener">Cluster Analysis Algorithm</a><br>给定一个训练数据集，从中找到某种结构，即将数据集分为几个聚类。（让算法自己从数据中发现规律）</p></li><li><p><a href="https://en.wikipedia.org/wiki/Independent_component_analysis" target="_blank" rel="noopener">ICA(Independent Component Analysis) Algorithm</a><br>Cocktail party problem<br>在嘈杂的鸡尾酒会区分不同人的语音</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[W,s,v] = svd((<span class="built_in">repmat</span>(sum(x.*x,<span class="number">1</span>),<span class="built_in">size</span>(x,<span class="number">1</span>),<span class="number">1</span>).*x)*x');</span><br></pre></td></tr></table></figure></li></ul><h3 id="Reinforcement-Learning（增强学习）"><a href="#Reinforcement-Learning（增强学习）" class="headerlink" title="Reinforcement Learning（增强学习）"></a>Reinforcement Learning（增强学习）</h3><p>reward function（回报函数）</p><h1 id="Supervised-Learning"><a href="#Supervised-Learning" class="headerlink" title="Supervised Learning"></a>Supervised Learning</h1><h2 id="Linear-regression"><a href="#Linear-regression" class="headerlink" title="Linear regression"></a>Linear regression</h2><img src="/2018/02/04/machine_learning_notes/supervised_learning_notation_1.png" class=""><img src="/2018/02/04/machine_learning_notes/supervised_learning_notation_2.png" class=""><img src="/2018/02/04/machine_learning_notes/supervised_learning_notation_3.png" class=""><h3 id="Gradient-descent"><a href="#Gradient-descent" class="headerlink" title="Gradient descent"></a><a href="https://en.wikipedia.org/wiki/Gradient_descent" target="_blank" rel="noopener">Gradient descent</a></h3><img src="/2018/02/04/machine_learning_notes/gradient_descent.png" class=""><p>随机选择一个点（特征参数），通过梯度算法找到下降最陡的方向，一步一步迭代，直到找到一个局部最优解（cost函数取最小值）。<br>如果初始化的值不一样，得到的局部最优解可能会不一样。<br>适用于：局部最优解等于全局最优解的情况，想象一个碗形的代价函数。</p><h4 id="Batch-gradient-descent"><a href="#Batch-gradient-descent" class="headerlink" title="Batch gradient descent"></a>Batch gradient descent</h4><p>每次迭代都要遍历所有的训练数据，适用于数据量小的训练集合。</p><img src="/2018/02/04/machine_learning_notes/batch_gradient_descent.png" class=""><p>这种迭代规则，称为LMS(Least Mean Squares) update rule.</p><h4 id="Stochastic-gradient-descent-Incremental-gradient-descent"><a href="#Stochastic-gradient-descent-Incremental-gradient-descent" class="headerlink" title="Stochastic gradient descent(Incremental gradient descent)"></a>Stochastic gradient descent(Incremental gradient descent)</h4><p>只需要遍历一次训练数据，适用于数据量很大的训练集合。</p><img src="/2018/02/04/machine_learning_notes/stochastic_gradient_descent.png" class=""><p>$ \alpha $表示学习速率，训练的步进，可以随着梯度的下降，减小该值。</p><h3 id="Normal-equations"><a href="#Normal-equations" class="headerlink" title="Normal equations"></a>Normal equations</h3><p>通过矩阵（matrix）的方法推导出的一种不需要迭代，直接可以计算出特征向量的方法。</p><img src="/2018/02/04/machine_learning_notes/normal_equation.png" class=""><p>$(X^TX)$不可逆的可能原因：</p><ul><li>存在冗余特征（$\theta $中存在重复）</li><li>特征数量n过多，训练样本数m太少</li></ul><h3 id="Non-parameterical-learning-algorithm"><a href="#Non-parameterical-learning-algorithm" class="headerlink" title="Non-parameterical learning algorithm"></a>Non-parameterical learning algorithm</h3><ul><li><p>parameterical learning algorithm 的参数数量n是固定的，训练完成后不需要样本。<br>特征参数过少，导致欠拟合（underfitting）；特征数过多，导致过拟合（overfitting）。<br>可以通过Feature slection algorithm来自动选取特征参数。</p></li><li><p>Non-parameterical learning algorithm 的参数数量n是随着样本数m的增加而增加的，每次输出结果都需要重新评估训练样本。<br>LWR(Locally weighted linear regressioin)是一种无参数的算法</p><img src="/2018/02/04/machine_learning_notes/LWR_1.png" class=""><img src="/2018/02/04/machine_learning_notes/LWR_2.png" class=""></li></ul><h3 id="Probabilistic-interpretatioin"><a href="#Probabilistic-interpretatioin" class="headerlink" title="Probabilistic interpretatioin"></a>Probabilistic interpretatioin</h3><p>最小二乘法的概率学解释：假设误差服从正态分布（高斯分布），最小二乘法求得的特征参数，可以使代价函数最小。</p><h2 id="Classification-and-logistic-regression"><a href="#Classification-and-logistic-regression" class="headerlink" title="Classification and logistic regression"></a>Classification and logistic regression</h2><p>除了y的取值是离散的之外，分类问题与线性回归问题类似。</p><h3 id="Logistic-regression"><a href="#Logistic-regression" class="headerlink" title="Logistic regression"></a>Logistic regression</h3><h4 id="sigmoid-function"><a href="#sigmoid-function" class="headerlink" title="sigmoid function"></a>sigmoid function</h4><img src="/2018/02/04/machine_learning_notes/logistic_regression_1.png" class=""><img src="/2018/02/04/machine_learning_notes/logistic_regression_2.png" class=""><img src="/2018/02/04/machine_learning_notes/logistic_regression_3.png" class=""><h4 id="Newton’s-method"><a href="#Newton’s-method" class="headerlink" title="Newton’s method"></a>Newton’s method</h4><img src="/2018/02/04/machine_learning_notes/Newtons_method_1.png" class=""><img src="/2018/02/04/machine_learning_notes/Newtons_method_2.png" class=""><h3 id="Perceptron-learning-algorithm"><a href="#Perceptron-learning-algorithm" class="headerlink" title="Perceptron learning algorithm"></a>Perceptron learning algorithm</h3><img src="/2018/02/04/machine_learning_notes/perceptron_learning_algorithm.png" class=""><h2 id="GLM-Generalized-Linear-Models"><a href="#GLM-Generalized-Linear-Models" class="headerlink" title="GLM(Generalized Linear Models)"></a>GLM(Generalized Linear Models)</h2><h3 id="Exponential-family"><a href="#Exponential-family" class="headerlink" title="Exponential family"></a>Exponential family</h3><p>之前的例子中，线性回归算法（最小二乘法）服从高斯分布，逻辑回归算法（sigmoid函数）服从伯努利分布。而这些都是GLM的一些特例。</p><img src="/2018/02/04/machine_learning_notes/exponential_family.png" class=""><p>以下分布都属于指数家族：<br>高斯分布（Gaussian）：结果是连续的<br>伯努利分布（Bernoulli）：结果是离散的，只有两种结果<br>多项式分布（multinomial）：结果是离散的，有k种结果<br>泊松分布（Poisson）：计数问题，eg.网站访客量，放射性衰变数目。<br>伽马分布（gamma）：时间间隔，eg.等公交车的时间<br>指数分布<br>beta分布<br>Dirichlet分布</p><h3 id="Constructing-GLMs"><a href="#Constructing-GLMs" class="headerlink" title="Constructing GLMs"></a>Constructing GLMs</h3><p>一个重要的设计决策是：</p><img src="/2018/02/04/machine_learning_notes/GLM_design_decision.png" class=""><h4 id="Ordinary-Least-Squares"><a href="#Ordinary-Least-Squares" class="headerlink" title="Ordinary Least Squares"></a>Ordinary Least Squares</h4><p>高斯分布在指数家族的表示如下：</p><img src="/2018/02/04/machine_learning_notes/Gaussian_in_exponential_family.png" class=""><p>可以推导出，最小二乘法是GLM的一个特例：</p><img src="/2018/02/04/machine_learning_notes/ordianary_least_squares_in_GLM.png" class=""><h4 id="Logistic-regression-1"><a href="#Logistic-regression-1" class="headerlink" title="Logistic regression"></a>Logistic regression</h4><p>伯努利分布在指数家族表示如下：</p><img src="/2018/02/04/machine_learning_notes/Bernoulli_in_exponential_family.png" class=""><p>可以推导出，逻辑回归是GLM的一个特例：</p><img src="/2018/02/04/machine_learning_notes/logistic_regression_in_GLM.png" class=""><h4 id="Softmax-regression"><a href="#Softmax-regression" class="headerlink" title="Softmax regression"></a>Softmax regression</h4><p>多项式分布在指数家族表示如下：</p><img src="/2018/02/04/machine_learning_notes/multinomial_in_exponential_family.png" class=""><p>softmax函数：</p><img src="/2018/02/04/machine_learning_notes/softmax_functin.png" class=""><p>可以推导出，softmax回归是GLM的一个特例：</p><img src="/2018/02/04/machine_learning_notes/softmax_regression_in_GLM.png" class=""><p>logistic回归是softmax回归在k=2时的特例。</p><h2 id="Generative-learning-algorithms"><a href="#Generative-learning-algorithms" class="headerlink" title="Generative learning algorithms"></a>Generative learning algorithms</h2><ul><li>判别（discriminative）学习算法<br>如逻辑回归，直接学习p(y|x)；或者如感知器算法（perceptron），直接尝试学习从输入到输出的映射（mapping）。</li><li>生成（generative）学习算法<br>对每种类别分别建模,然后通过贝叶斯公式计算出在给定x条件下y的后验分布。<img src="/2018/02/04/machine_learning_notes/generative_learning_algorithm_1.png" class=""><img src="/2018/02/04/machine_learning_notes/generative_learning_algorithm_2.png" class=""></li></ul><h3 id="GDA（Gaussian-Discriminant-Analysis）"><a href="#GDA（Gaussian-Discriminant-Analysis）" class="headerlink" title="GDA（Gaussian Discriminant Analysis）"></a>GDA（Gaussian Discriminant Analysis）</h3><p>GDA假设p(x|y)服从多元正态分布（multivariate normal distribution）。</p><h4 id="多元正态分布"><a href="#多元正态分布" class="headerlink" title="多元正态分布"></a>多元正态分布</h4><img src="/2018/02/04/machine_learning_notes/multivariant_normal_distribution_1.png" class=""><img src="/2018/02/04/machine_learning_notes/multivariant_normal_distribution_2.png" class=""><h4 id="高斯判定分析模型"><a href="#高斯判定分析模型" class="headerlink" title="高斯判定分析模型"></a>高斯判定分析模型</h4><img src="/2018/02/04/machine_learning_notes/GDA_1.png" class=""><p>通过计算最大化的似然函数，可以得到参数$\phi \mu_0 \mu_1 \Sigma$的值。</p><img src="/2018/02/04/machine_learning_notes/GDA_2.png" class=""><h4 id="GDA与逻辑回归"><a href="#GDA与逻辑回归" class="headerlink" title="GDA与逻辑回归"></a>GDA与逻辑回归</h4><p>如果我们将$p(y=1|x;\phi, \mu_0, \mu_1, \Sigma)$视为$x$的函数，那么我们发现可以有如下表示形式：<br>$$ p(y=1|x;\phi, \mu_0, \mu_1, \Sigma)={1 \over {1+exp(-\theta^T x)}}$$<br>这就是逻辑回归—一种判定算法—用来给$p(y=1|x)$建模的形式。</p><p>也就是说，如果数据服从多元高斯分布，那后验分布是逻辑函数；反之，不成立。</p><p>如果$x|y=0 ~ Poisson(\lamda_0), x|y=1 ~Poisson(\lamda_1$,那么$p(y|x)$也是逻辑的（logistic）。<br>也就是说，如果数据服从泊松分布，那后验分布也是逻辑函数；反之，不成立。</p><p>逻辑回归对多元高斯分布，泊松分布等都有效。</p><p>相比逻辑回归，GDA使用了更强的（stronger）假设。<br>如果模型假设正确（服从多元高斯分布），那么GDA可以更好地fit数据，可以通过更少的数据达到更好的效果，这种情况下GDA是更好的模型；<br>与之相对，逻辑回归使用了更弱（weaker）的假设，所以逻辑回归更健壮（robust），且对不正确的模型假设更不敏感。<br>如果数据不符合高斯分布，使用GDA得不到更好的估算，此时使用逻辑回归更好。</p><h3 id="朴素贝叶斯算法（Naive-Bayes）"><a href="#朴素贝叶斯算法（Naive-Bayes）" class="headerlink" title="朴素贝叶斯算法（Naive Bayes）"></a>朴素贝叶斯算法（Naive Bayes）</h3><h4 id="Naive-Bayes"><a href="#Naive-Bayes" class="headerlink" title="Naive Bayes"></a>Naive Bayes</h4><ul><li>GDA的特征向量是连续的实数向量。</li><li>Naive Bayes的特征向量是离散的值。<br>以垃圾邮件分类器（email span filter）为例,这个模型也称为多元伯努利事件模型（multi-variate Bernoulli event model）：</li></ul><img src="/2018/02/04/machine_learning_notes/NB_feature_vector_1.png" class=""><img src="/2018/02/04/machine_learning_notes/NB_feature_vector_2.png" class=""><p>朴素贝叶斯算法假设：</p><img src="/2018/02/04/machine_learning_notes/NB_assumption.png" class=""><p>朴素贝叶斯算法的参数：</p><img src="/2018/02/04/machine_learning_notes/NB_1.png" class=""><img src="/2018/02/04/machine_learning_notes/NB_2.png" class=""><img src="/2018/02/04/machine_learning_notes/NB_3.png" class=""><img src="/2018/02/04/machine_learning_notes/NB_4.png" class=""><h4 id="Laplace-smoothing"><a href="#Laplace-smoothing" class="headerlink" title="Laplace smoothing"></a>Laplace smoothing</h4><p>设想如下场景：<br>一个从来没有在训练邮件中出现过的单词，但是这个单词在字典里，如果有一天收到一封邮件里包含这类单词。<br>会导致$\phi_{i|y=1}=0$,且$\phi_{i|y=0}=0$<br>从而<br>$$ p(y=1|x) = {0 \over 0}$$<br>这是一个未定义的值，无法作出估计。</p><img src="/2018/02/04/machine_learning_notes/Laplace_smoothing.png" class=""><p>计算明天太阳升起来的概率(假设太阳已经连续n天升起来了)<br>明天太阳不会升起来的概率：<br>$$ \phi_0 = {1 \over n+2}$$<br>明天太阳还会升起来的概率：<br>$$ \phi_1 = {n+1 \over n+2}$$</p><h4 id="Event-models-for-text-classification"><a href="#Event-models-for-text-classification" class="headerlink" title="Event models for text classification"></a>Event models for text classification</h4><img src="/2018/02/04/machine_learning_notes/multinomial_event_model_1.png" class=""><img src="/2018/02/04/machine_learning_notes/multinomial_event_model_2.png" class=""><img src="/2018/02/04/machine_learning_notes/multinomial_event_model_3.png" class=""><img src="/2018/02/04/machine_learning_notes/multinomial_event_model_4.png" class=""><p>References:</p><ol><li><a href="http://blog.csdn.net/artprog/article/details/51172025" target="_blank" rel="noopener">机器学习笔记03：Normal equation与梯度下降的比较</a></li><li><a href="http://blog.csdn.net/google19890102/article/details/49738427" target="_blank" rel="noopener">深度学习算法原理——Softmax Regression</a></li><li><a href="https://www.cnblogs.com/realkate1/p/5683939.html" target="_blank" rel="noopener">生成模型（Generative）和判别模型（Discriminative)</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习吴恩达的machine learning课程笔记。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="https://www.wuchenxu.com/categories/AI/"/>
    
    
      <category term="AI" scheme="https://www.wuchenxu.com/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>ABZ计划</title>
    <link href="https://www.wuchenxu.com/2017/12/31/ABZ-Plan/"/>
    <id>https://www.wuchenxu.com/2017/12/31/ABZ-Plan/</id>
    <published>2017-12-31T12:38:54.000Z</published>
    <updated>2017-12-31T15:45:43.893Z</updated>
    
    <content type="html"><![CDATA[<img src="/2017/12/31/ABZ-Plan/ABZ_plan.png" class="">  <p>今天是2017年最后一天了，可以按照<code>ABZ理论</code>好好计划一下2018年的计划了。</p><a id="more"></a><p>《至关重要的关系》(The Start-up of You)一书中提出的“ABZ计划”理论。<br>现在的世界变化太快（VUCA时代），我们需要一个人生规划：能让我们最大限度做好当前工作（A计划）；同时，在适当的时候可以转移到的下一份工作（B计划）；最差的情况，有个兜底的退路（Z计划）。</p><h1 id="A计划：当前的位置"><a href="#A计划：当前的位置" class="headerlink" title="A计划：当前的位置"></a>A计划：当前的位置</h1><p>A计划是当前正在从事的工作，是当前具有竞争优势的位置，并且值得持续投入。在A计划中，我们只需要对所学的知识技能做微调，并周期性地迭代。</p><h1 id="B计划：支点（Pivot-Point）"><a href="#B计划：支点（Pivot-Point）" class="headerlink" title="B计划：支点（Pivot Point）"></a>B计划：支点（Pivot Point）</h1><p>你的支点是你围绕的中心，就像篮球运动员只要以一只脚为支撑点，可以在一个圆圈里自由移动。<br>B计划是当你需要改变目标或者改变达到目标的路径的时候，可以转换过去的支点。你可能因为A计划行不通或者发现了比A计划更好的机会，从而准想B计划。一旦你转向B计划，它就变成了新的A计划。<br>为什么需要B计划，因为这个时代变化太快，你不知道什么时候你的公司或者你所在的行业就会迎来拐点（inflection point）。这样根本性的变化会强迫你改变自己的技能或者换一个新的环境。因为拐点的不可预测性，为了减轻拐点到来时的冲击，我们可以未雨绸缪：建立个人的软技能，拥抱变化，随时准备快速切换的B计划。<br>最好的B计划通常与你当前所做的工作有所不同，但是又有很大的相关性。转换到相近的领域，既可以借力已有的技能，又可以在一个新的方向开发出新的技能。通常，需要利用晚上或者周末的时间。你可以在空余时间开始学习新的技能，并与相邻领域工作的人建立联系。</p><h1 id="Z计划：安全网"><a href="#Z计划：安全网" class="headerlink" title="Z计划：安全网"></a>Z计划：安全网</h1><p>Z计划是你的安全撤退点（fallback point），你的救生船，它能让你承受失败的结果，并卷土重来。<br>如果你的职业生涯终结或者你的生活遭受重大变故，你的计划是什么？这就是Z计划。有了Z计划，你就可以在A计划和B计划里接受不确定性和风险。有了Z计划，你至少知道可以承受风险。没有Z计划，你可能在担心最坏情况的恐惧中束手束脚。<br>也许你会在恢复之前过一段简朴的生活，但是至少你知道不会无家可归，不会破产或者永远失业。<br>Z计划不是一个终点，它更像一张安全网，让你知道最差不过如此，这样你可以更加放心大胆地执行AB计划，甚至重新制定更加激进而不是更加保守的AB计划。</p><p>Reference：</p><ol><li><a href="http://mindmappingsoftwareblog.com/wp-content/bs-e197d/ABZ-Career-Plan-Map.pdf" target="_blank" rel="noopener">How to create an ABZ career plan mind map</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2017/12/31/ABZ-Plan/ABZ_plan.png&quot; class=&quot;&quot;&gt;  

&lt;p&gt;今天是2017年最后一天了，可以按照&lt;code&gt;ABZ理论&lt;/code&gt;好好计划一下2018年的计划了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="management" scheme="https://www.wuchenxu.com/categories/management/"/>
    
    
      <category term="management" scheme="https://www.wuchenxu.com/tags/management/"/>
    
  </entry>
  
  <entry>
    <title>技术炒作周期(Hype Cycle)</title>
    <link href="https://www.wuchenxu.com/2017/09/21/hype-cycle/"/>
    <id>https://www.wuchenxu.com/2017/09/21/hype-cycle/</id>
    <published>2017-09-21T12:38:54.000Z</published>
    <updated>2021-09-12T10:24:26.329Z</updated>
    
    <content type="html"><![CDATA[<p>Hype cycle直译过来是<code>炒作周期</code>的意思，是美国咨询公司Gartner从1995年开始每年发布的一个关于技术成熟度报告，从时间维度将技术的成熟度分成5个周期：<br><code>Innovation Trigger（萌芽期）</code> <code>Peak of Inflated Expectations（过热期）</code> <code>Trough of Disillusionment（低谷期）</code> <code>Slope of Enlightenment（复苏期）</code> <code>Plateau of Productivity（成熟期）</code>。</p><a id="more"></a><h1 id="阿马拉法则"><a href="#阿马拉法则" class="headerlink" title="阿马拉法则"></a>阿马拉法则</h1><p>阿马拉法则（Amara’s law）：人们常常高估技术的短期影响力，而低估技术的长期影响力。<br>Hype cycle可以看作是阿马拉法则的一种图像化描述。<br>Hype cycle可以看到不同技术随着时间的起起伏伏，也可以看到一项技术从萌芽到成熟的经过。</p><h1 id="2021年Garnter整理的3个主题"><a href="#2021年Garnter整理的3个主题" class="headerlink" title="2021年Garnter整理的3个主题"></a>2021年Garnter整理的3个主题</h1><p>新增了Nonfungible tokens (NFTs，不可替代代币), digital humans（数字人类） and physics-informed AI（基于物理的AI）。<br>很多主题的出发点都是由于新冠疫情大流行，导致的对非接触办公，灾害管理，信任的需求。</p><ul><li><p>Engineering trust（工程信任）<br>为了让 IT 团队有效地领导技术支持的业务转型，他们必须设计一个值得信赖的业务核心。信任需要安全性和可靠性，但也必须建立在可重复、经过验证、可扩展和创新的工作实践之上。这些实践为 IT 提供了一个弹性核心和基础，以交付业务价值。<br>例如，实时事件指挥中心作为一种服务，通过将来自不同来源的信息融合在一起，提高了组织的态势感知能力。通常，公共安全组织采用更多手动方式为应急指挥中心集成数据库、传感器、视频和通信系统。<br>属于工程信任桶的其他技术包括主权云、同态加密和数据网络结构（data fabric）。</p></li><li><p>Accelerating growth（加速增长）<br>有了值得信赖的业务核心，作为 IT 领导者和 CIO，您必须专注于推动组织增长的计划。这意味着平衡技术风险与业务风险偏好，并确保组织增长目标是近期和可实现的。<br>考虑数字人，这是人的数字孪生表示。这项技术为获得许可的角色提供了机会，可以实现新的收入流。它们可以表现为化身、人形机器人或对话式用户界面，如聊天机器人或智能扬声器。这些由 AI 驱动的交互式表示看起来像人，并以“类人”方式行事，并得到一系列技术的支持，包括对话 UI、CGI 和 3D 实时自主动画。<br>这些类人技术在人力资源培训、通信、医疗保健和客户服务中的用例比比皆是。COVID-19 推动了技术潜力，以实现无接触体验、消除社会孤立并为老年人提供护理。数字人出现在故事​​片中，在会议上表演并充当品牌影响者。除了不成熟的技术之外，社会障碍和道德问题也给数字人类带来了挑战，但业务影响和差异化的潜力正在推动一些组织追求这项技术。<br>其他加速增长的新兴技术包括多体验、行业云和量子机器学习。</p></li><li><p>Sculpting change（雕刻变化）<br>变化自然是破坏性的。关键是要认识到中断，并采用技术来塑造转变，并为原本可能是混乱的事物带来秩序。必须预测并影响变化以降低风险。<br>例如，基于物理的人工智能 (PIAI，physics-informed AI) 是可以构建物理和科学上合理的人工智能模型的人工智能。PIAI 作为一种对气候和环境问题等复杂系统进行建模的更有效选择而引起了特别的兴趣，鉴于其规模，对这些系统进行建模具有挑战性。<br>传统的数字 AI 模型适应性有限，因为它们无法在训练数据之外进行泛化。PIAI 为上下文和物理产品创建了更可靠的表示。COVID-19 凸显了过于脆弱的商业模式的脆弱性。PIAI 为系统运行的环境和条件创建了更灵活的表示，允许开发人员构建更具适应性的系统。它还可以创建更强大和适应性更强的业务模拟系统，这些系统在更广泛的场景中更加可靠。<br>该领域的其他新兴技术包括可组合应用程序、可组合网络和影响工程。</p></li></ul><h1 id="2020年Garnter整理的5个趋势"><a href="#2020年Garnter整理的5个趋势" class="headerlink" title="2020年Garnter整理的5个趋势"></a>2020年Garnter整理的5个趋势</h1><h2 id="Composite-architectures"><a href="#Composite-architectures" class="headerlink" title="Composite architectures"></a>Composite architectures</h2><p>In the face of rapid changes and decentralization, organizations need to shift to more agile, responsive architectures. A composite architecture is made up of packaged business capabilities built on a flexible data fabric. This allows the enterprise to respond to rapidly changing business needs.<br>The composable enterprise has four core principles: Modularity, efficiency, continuous improvement and adaptive innovation.</p><ul><li>composable enterprise</li><li>packaged business capabilities</li><li>data fabric</li><li>private 5G</li><li>embedded AI</li></ul><h2 id="Algorithmic-trust"><a href="#Algorithmic-trust" class="headerlink" title="Algorithmic trust"></a>Algorithmic trust</h2><p>Increased amounts of consumer data exposure, fake news and videos, and biased AI, have caused organizations to shift from trusting central authorities (government registrars, clearing houses) to trusting algorithms. Algorithmic trust models ensure the privacy and security of data, provenance of assets, and the identities of people and things.</p><ul><li>authenticated provenance</li><li>differential privacy</li><li>responsible AI </li><li>explainable AI</li></ul><h2 id="Beyond-silicon"><a href="#Beyond-silicon" class="headerlink" title="Beyond silicon"></a>Beyond silicon</h2><p>Moore’s Law predicts that the number of transistors in a dense integrated circuit would double every two years, but technology is quickly reaching the physical limits of silicon. This has led to the evolution of new advanced materials with enhanced capabilities designed to support smaller, faster technologies.</p><ul><li>DNA computing and storage</li><li>biodegradable sensors</li><li>carbon-based transistors</li></ul><h2 id="Formative-AI"><a href="#Formative-AI" class="headerlink" title="Formative AI"></a>Formative AI</h2><p>Formative AI is a type of AI capable of dynamically changing to respond to a situation. There are a variety of types, ranging from AI that can dynamically adapt over time to technologies that can generate novel models to solve specific problems.</p><ul><li>generative AI</li><li>composite AI</li><li>differential privacy</li><li>small data</li><li>self-supervising learning</li></ul><h2 id="Digital-me"><a href="#Digital-me" class="headerlink" title="Digital me"></a>Digital me</h2><p>From health passports to digital twins, as technology integrates with people, there are more opportunities to create digital versions of ourselves. These digital models represent humans in both the real and virtual worlds.</p><ul><li>health passports</li><li>digital twins</li><li>BMI(bidirectional brain-machine interfaces)    </li></ul><h1 id="2019年Garnter整理的5个趋势"><a href="#2019年Garnter整理的5个趋势" class="headerlink" title="2019年Garnter整理的5个趋势"></a>2019年Garnter整理的5个趋势</h1><img src="/2017/09/21/hype-cycle/Trends_in_the_Emerging_Tech_Hype_Cycle_2019.png" class=""> <h1 id="2018年Garnter整理的5个趋势"><a href="#2018年Garnter整理的5个趋势" class="headerlink" title="2018年Garnter整理的5个趋势"></a>2018年Garnter整理的5个趋势</h1><img src="/2017/09/21/hype-cycle/Trends_in_the_Emerging_Tech_Hype_Cycle_2018.png" class=""> <h1 id="历年的Garnter-Hype-Cycle图："><a href="#历年的Garnter-Hype-Cycle图：" class="headerlink" title="历年的Garnter Hype Cycle图："></a>历年的Garnter Hype Cycle图：</h1><img src="/2017/09/21/hype-cycle/Emerging-Technology-Hype-Cycle-for-2021.png" class=""><img src="/2017/09/21/hype-cycle/Emerging-Technology-Hype-Cycle-for-2020.png" class=""><img src="/2017/09/21/hype-cycle/Emerging-Technology-Hype-Cycle-for-2019.png" class=""><img src="/2017/09/21/hype-cycle/Emerging-Technology-Hype-Cycle-for-2018.png" class=""> <img src="/2017/09/21/hype-cycle/Emerging-Technology-Hype-Cycle-for-2017.jpg" class="">  <img src="/2017/09/21/hype-cycle/Emerging-Technology-Hype-Cycle-for-2016.jpg" class="">  <img src="/2017/09/21/hype-cycle/Emerging-Technology-Hype-Cycle-for-2015.png" class=""><img src="/2017/09/21/hype-cycle/Emerging-Technology-Hype-Cycle-for-2014.jpg" class=""><img src="/2017/09/21/hype-cycle/Emerging-Technology-Hype-Cycle-for-2013.png" class=""><img src="/2017/09/21/hype-cycle/Emerging-Technology-Hype-Cycle-for-2012.png" class=""><img src="/2017/09/21/hype-cycle/Emerging-Technology-Hype-Cycle-for-2011.gif" class=""><img src="/2017/09/21/hype-cycle/Emerging-Technology-Hype-Cycle-for-2010.png" class=""><img src="/2017/09/21/hype-cycle/Emerging-Technology-Hype-Cycle-for-2009.jpeg" class=""><p>References:</p><ol><li><a href="http://www.gartner.com/technology/research/methodologies/hype-cycle.jsp" target="_blank" rel="noopener">Gartner hype clcle</a></li><li><a href="https://en.wikipedia.org/wiki/Hype_cycle" target="_blank" rel="noopener">wiki hype cycle</a></li><li><a href="https://spotlessdata.com/amaras-law" target="_blank" rel="noopener">AMARA’S LAW</a></li><li><a href="https://www.gartner.com/smarterwithgartner/5-trends-emerge-in-gartner-hype-cycle-for-emerging-technologies-2018/" target="_blank" rel="noopener">Hype Cycle for Emerging Technologies, 2018</a></li><li><a href="https://www.gartner.com/smarterwithgartner/5-trends-appear-on-the-gartner-hype-cycle-for-emerging-technologies-2019/" target="_blank" rel="noopener">5 Trends Appear on the Gartner Hype Cycle for Emerging Technologies, 2019</a></li><li><a href="https://www.gartner.com/smarterwithgartner/5-trends-drive-the-gartner-hype-cycle-for-emerging-technologies-2020/" target="_blank" rel="noopener">5 Trends Drive the Gartner Hype Cycle for Emerging Technologies, 2020</a></li><li><a href="https://www.gartner.com/smarterwithgartner/3-themes-surface-in-the-2021-hype-cycle-for-emerging-technologies/" target="_blank" rel="noopener">3 Themes Surface in the 2021 Hype Cycle for Emerging Technologies</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hype cycle直译过来是&lt;code&gt;炒作周期&lt;/code&gt;的意思，是美国咨询公司Gartner从1995年开始每年发布的一个关于技术成熟度报告，从时间维度将技术的成熟度分成5个周期：&lt;br&gt;&lt;code&gt;Innovation Trigger（萌芽期）&lt;/code&gt; &lt;code&gt;Peak of Inflated Expectations（过热期）&lt;/code&gt; &lt;code&gt;Trough of Disillusionment（低谷期）&lt;/code&gt; &lt;code&gt;Slope of Enlightenment（复苏期）&lt;/code&gt; &lt;code&gt;Plateau of Productivity（成熟期）&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="technical" scheme="https://www.wuchenxu.com/categories/technical/"/>
    
    
      <category term="technical" scheme="https://www.wuchenxu.com/tags/technical/"/>
    
  </entry>
  
  <entry>
    <title>程序在哪里执行？</title>
    <link href="https://www.wuchenxu.com/2017/05/30/where-program-execute-in/"/>
    <id>https://www.wuchenxu.com/2017/05/30/where-program-execute-in/</id>
    <published>2017-05-30T15:54:00.000Z</published>
    <updated>2017-07-16T12:05:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>先上结论：计算机程序可以在ROM或者RAM里执行。</p><a id="more"></a><p>摘自RL78芯片datasheet：</p><blockquote><p>The RL78/F13 and RL78/F14 incorporate the flash memory to which a program can be written, erased, and overwritten. The flash memory includes the “code flash memory”, in which programs can be executed, and the “data flash memory”, an area for storing data.</p></blockquote><p>计算机设备，包括单片机，PC，DSP，FPGA等不同类型的电子设备，可以从ROM中执行程序（试想系统刚上电，也只有ROM中可以读取指令）。初始化完成后，为了提高执行速度可以将ROM中存储的程序到RAM中，再从RAM中执行。</p><p>由于RAM执行速度（～GHz）相较于NorFlash的XIP执行速度（～100MHz）快很多，所以如果RAM空间足够的情况下，从RAM执行程序速度更快。<br>但是由于成本原因，NorFlash在单片机（code flash一般从几K到几M大小）中作为存储程序的主存储器也是很常见的。</p><p>NorFlash支持XIP（<a href="https://en.wikipedia.org/wiki/Execute_in_place" target="_blank" rel="noopener">eXecute In Place</a>），CPU直接从NorFlash取指令、译码、执行。<br>NorFlash更像RAM，使用标准的存储接口，具有独立的地址总线和数据总线，支持随机访问，地址总线与数据总线共用；而NandFlash更像一个硬盘，需要特殊的驱动来访问，地址总线和数据总线是与I/O总线共享，只允许按页访问，。<br>NorFlash直接执行的设备，还是需要RAM的，因为NorFlash中只能存储不可变的指令或数据，运行过程中可变的数据还是需要存储在RAM中。<br>NorFlash的特点(线性存储空间，100%无坏点，随机访问)决定了支持XIP。<br>NorFlash的XIP最快执行速度～100MHz。<br>NorFlash的读取速度（～100ns）比NandFlash（us）快，NandFlash的擦除和写入速度比NorFlash快很多。</p><p>NandFlash只能保证98%无坏块（bad block），需要坏块处理；会有位翻转（bit-flipping）问题，需要EDC（Error Detection Code）/ECC（Error Correction Code）来检错纠错。</p><img src="/2017/05/30/where-program-execute-in/comparison_NOR_NAND.png" class=""><ul><li>SRAM(Static Random Access Memory) - cache/register - faster but more expensive</li><li>DRAM(Dynamic Random Access Memory) - Main Memory - slower but cheaper<br>动态随机存取存储器，最为常见的系统内存。DRAM 只能将数据保持很短的时间。为了保持数据，DRAM使用电容存储，所以必须隔一段时间刷新（refresh）一次，如果存储单元没有被刷新，存储的信息就会丢失。 （关机就会丢失数据）<ul><li>SDRAM(Synchronous Dynamic Random Access Memory):<br>同步动态随机存储器，同步是指内存工作需要同步时钟，内部的命令的发送与数据的传输都以它为基准.</li><li>DDR(Dual Data Rate) SDRAM:双倍速率同步动态随机存储器</li></ul></li><li>Flash <ul><li>NorFlash</li><li>NandFlash <ul><li>SD（Secure Digital）卡</li><li>eMMC（embedded multi-media card）</li><li>SSD（Solid State Disk）</li><li>UFS（Universal Flash Storage）</li></ul></li></ul></li></ul><p>References：</p><ol><li><a href="https://en.wikipedia.org/wiki/Flash_memory" target="_blank" rel="noopener">Flash Memory</a></li><li><a href="https://en.wikipedia.org/wiki/Execute_in_place" target="_blank" rel="noopener">Execute In Place</a></li><li><a href="http://www.blog.chinaunix.net/uid-26404697-id-3152290.html" target="_blank" rel="noopener">norflash芯片内执行（XIP） </a></li><li><a href="http://aturing.umcs.maine.edu/~meadow/courses/cos335/Toshiba%20NAND_vs_NOR_Flash_Memory_Technology_Overviewt.pdf" target="_blank" rel="noopener">Toshiba NAND vs. NOR Flash Memory Technology Overview</a></li><li><a href="https://focus.ti.com/pdfs/omap/diskonchipvsnor.pdf" target="_blank" rel="noopener">Two Flash Technologies Compared: NOR vs. NAND Two Flash Technologies Compared: NOR vs. NAND </a></li><li><a href="https://superuser.com/questions/163425/does-ram-access-slow-down-cpu" target="_blank" rel="noopener">Does RAM access slow-down CPU?</a></li><li><a href="https://electronics.stackexchange.com/questions/102764/flash-and-ram-code-execution" target="_blank" rel="noopener">flash-and-ram-code-execution</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先上结论：计算机程序可以在ROM或者RAM里执行。&lt;/p&gt;
    
    </summary>
    
    
      <category term="technical" scheme="https://www.wuchenxu.com/categories/technical/"/>
    
    
      <category term="software" scheme="https://www.wuchenxu.com/tags/software/"/>
    
      <category term="technical" scheme="https://www.wuchenxu.com/tags/technical/"/>
    
  </entry>
  
  <entry>
    <title>软件工程的事实与谬误 by Robert L·Glass</title>
    <link href="https://www.wuchenxu.com/2017/05/12/reading-notes-3-Facts-and-fallacies-of-software-engineering/"/>
    <id>https://www.wuchenxu.com/2017/05/12/reading-notes-3-Facts-and-fallacies-of-software-engineering/</id>
    <published>2017-05-12T15:54:00.000Z</published>
    <updated>2017-07-16T13:09:51.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/2017/05/12/reading-notes-3-Facts-and-fallacies-of-software-engineering/cover.jpg" class=""><p>软件工程的55个事实和5+5个谬误。<br>划重点：</p><ul><li>软件过程和软件产品的<code>复杂性</code>决定了我们在该领域的许多认识和行为。复杂性不可避免，我们不应该与之对立，而应该学会适应它。</li><li>在软件领域，糟糕的<code>估算</code>和由此带来的<code>时间表压力</code>一直在迫害我们。</li><li>在软件管理者和技术人员之间有<code>隔阂</code>。</li><li><code>鼓吹</code>和<code>通用</code>的观念影响了我们形成专注于有力的、明智的项目方案的能力。</li></ul><a id="more"></a><h1 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h1><p>处于管理最底层且专长于干活的人通常比其他任何人有更大的威力。</p><h2 id="人员"><a href="#人员" class="headerlink" title="人员"></a>人员</h2><p>1.<code>在软件开发中，最重要的因素不是程序员采用的工具和技术，而是程序员自身的质量。</code></p><p>CMM假设良好的过程会得到良好的软件。</p><p>Q：假如你的生命依靠某一软件，那么，关于该软件你最想知道什么？ A：与其他事情相比，我最想知道写该软件的人，这人一定才华横溢，严谨认真，狂热追求软件完美并按照需求运作。其他对我来说都是次要的。</p><p>2.<code>对“个体差异”的研究表明，最好的程序员要比最差的程序员强28倍之多，即使他们的报酬不同，优秀程序员也是软件业中最廉价的劳动力。</code></p><p>3.<code>给延期的项目增加人手会使项目进一步延期。</code><br>    Brooks法则，出自《人月神话》</p><p>4.<code>工作环境对工作效率和产品质量具有深刻影响。</code><br>    你必须找到优秀的人员并善待他们，特别是给她们提供舒适的环境。</p><h2 id="工具和技术"><a href="#工具和技术" class="headerlink" title="工具和技术"></a>工具和技术</h2><p>5.<code>夸大宣传是软件的瘟疫，多数软件工具对于效率和质量的提高幅度仅为5%～35%，但总有人反复说提高幅度是“数量级”的。</code></p><p>6.<code>在学习新工具或者新技术的初期，程序员的工作效率和产品质量都会下降。只有克服了学习曲线之后，才可能得到实质性的收益。只有满足下面两个条件，采用新工具或者新技术才有意义：（a）新东西确实有用；（b）要想获得真正的收益，必须耐心等待。</code></p><p>7.<code>软件开发者对于工具说的多，评估的少，买的多，用的少。</code></p><h2 id="估算"><a href="#估算" class="headerlink" title="估算"></a>估算</h2><p>8.<code>项目失控的两个最主要的原因之一是糟糕的估算（另一个原因见事实23）。</code></p><p>估算是确定项目成本和开发时间表的过程。</p><p>依靠专家—无论专家曾经做过什么项目，无论这些项目与当前项目何等相似，专家都不可能做出合理的推断（软件项目的重要特征之一是各个项目所解决的问题差异很大。）</p><p>依靠估算算法（复杂算法，Line of Code，Function Point）—采用一个假想的项目，按照各种建议算法输入相关数据，得到的结果差异很大（2～8倍）。</p><p>9.<code>许多估算是在软件生命周期开始时完成的。后来，我们才认识到在需求定义之前，即理解问题之前进行项目估算是不正确的；也就是说，估算时机是错误的。</code></p><p>10.<code>许多软件项目都是由高层管理人员或者营销人员来估算，而不是由真正构建软件的人或者他们的主管来进行估算。因此，估算软件的人员是错误的。</code></p><p>高级人员和营销人员搞“政治”预测；软件人员做“理性”预测。</p><p>许多（70%）估算是由与“人事部门”相关的人员完成的，很少（4%）由项目团队进行估算。</p><p>11.<code>软件估算很少根据项目进度进行调整。因此，这些估算通常是错误的人在错误的时间得出的错误结果。</code></p><p>12.<code>因为估算的数据是如此糟糕，所以在软件项目不能达到估算目标时，不应该再考虑估算。但是无论如何，每个人都在考虑它。</code></p><p>极限编程建议客户或者用户先确定成本、时间表、功能和质量这四个因素中的前三个，软件开发者再确定第四个。</p><p>我要求参与者完成一个小任务。我有意增加他的工作量，使工作时间不足。我希望参与者尽力正确地完成整体工作，这样他们会因为时间不够而得出一个未完成的作品。事实并非如此，这些参与者按照不可能的时间表勉强完成了工作。他们的作品粗糙而虚假，看起来完整但根本不可用。这说明人们为了满足不可能的时间表，以至于愿意为此牺牲作品的完整性和质量。</p><p>13.<code>在管理者和程序员之间存在隔阂。对于一个未满足估算目标的项目的调查表明：从管理者看来这是一个失败的项目，而在技术人员看来却是最成功的项目。</code></p><p>根本就没有做过估计的项目进展速度最快，其次是技术人员做估计得项目，最糟糕的是由管理人员做估计。</p><p>在工作效率和驾驭感之间有非常强的关联性。也就是说，如果程序员感觉到能驾驭自己的结局，那么他们的工作效率会高很多。换句话说，高度控制的管理并不一定会得到最好的或者效率最高的项目。</p><p>14.<code>对于可行性调研的回答几乎总是“可行”。</code></p><h2 id="复用"><a href="#复用" class="headerlink" title="复用"></a>复用</h2><p>15.<code>小规模的复用（子程序库）开始于50多年以前，这个问题已经得到很好的解决。</code></p><p>16.<code>虽然每个人都认为大规模服用（组件）非常重要、非常急需，但是这个问题至今还没有基本解决。</code></p><p>作者认为此问题无解，根源在于软件的多样性。</p><p>17.<code>大规模复用最好适用于相关的系统，也就是依赖于具体应用领域，这样就限制了它的应用范围。</code></p><p>在一个更小的特定应用领域中采用大规模复用的方法，成功的概率就比较大。而在跨项目和跨应用领域中采用大规模复用方法的成功概率很小。（McBreen 2002）。</p><p>18.<code>有关复用问题，有两个“三倍法则”：（a）构建可复用的组件比使用组件难三倍；（b）在将组件收录到复用库并成为通用组件之前，应该在三个不同的应用中尝试使用该组件。</code></p><p>19.<code>修改复用的代码特别容易引起错误。如果一个组件中超过20%～25%的代码需要修改，那么重新实现的效率会更高。</code></p><p>20.<code>设计模式复用是解决代码复用中固有问题的一种方法。</code></p><p>设计模式是对反复出现的问题以及该问题的解决方案的一种描述。</p><p>设计模式源于实践，而不是源于理论。</p><h2 id="复杂性"><a href="#复杂性" class="headerlink" title="复杂性"></a>复杂性</h2><p>21.<strong><code>问题的复杂性每增加25%，解决方案的复杂性就增加100%。这不是一个可改变的条件（即使人们都努力降低复杂性），而是客观存在的。</code></strong></p><p>22.<code>80%的软件工作是智力活动。相当大的比例是创造性的活动。很少是文书性的工作。</code></p><h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p>生命周期（software life cycle）开始于<code>需求</code>的定义和开发，在这一阶段，定义和分析“什么”问题。接着是<code>设计</code>，在这一阶段确定如何解决问题。然后是<code>编码</code>，将设计转化为计算机上可运行的代码。随后，因为整个过程中极易出现错误，所以进行<code>错误消除</code>。最终，完成了全部测试之后，软件产品交付使用，便开始了<code>维护</code>.<br>不同的步骤形成了瀑布模型，螺旋模型等，这些模型只是将步骤的顺序调整，需求、设计、编码、错误消除和维护，这些步骤都需要完成。</p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>23.<code>导致项目失控的两个最常见原因之一是不稳定的需求（另一个见事实8所说的项目估算失误）。</code></p><p>24.<code>在产品完成时修订需求错误的代价最大，在开发早期修订需求错误的代价最小。</code></p><p>错误在软件的存留时间越长，修订的代价越大。</p><p>怎么做？</p><ul><li>计算机学者会坚持采用格式化的规格说明书技术；</li><li>开发者则将复审放在首位；</li><li>测试和质量人员要求有可测试的需求，并建立早期测试用例；</li><li>系统分析员可能会要求采用建模的方法；</li><li>极限编程者提倡在开发团队中吸纳一个客户代表。</li></ul><p>25.<code>遗漏需求是最难修订的需求错误。</code></p><p>最持久的软件错误是遗漏逻辑错误，它可以逃过软件测试过程，进入发布的产品中。遗漏需求会导致遗漏逻辑。</p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>26.<strong><code>从需求转入设计时，因为制定方案过程的复杂性，会激增出大量的衍生需求（针对一种特定设计方案的需求）。设计需求时原始需求的50倍之多。</code></strong></p><p>虽然大家都认为需求追溯很有必要，但是需求扩充在一定程度上影响了需求追溯。需求追溯是指在产品的各个阶段的制品中追溯原始需求。</p><p>27.<code>对于一个软件问题，通常不存在唯一的最佳设计方案。</code></p><blockquote><p>在一个房间中坐满了顶级的软件设计人员，如果其中任意两个人达成一致，那就可以通过了。—Bill Curtis</p></blockquote><p>28.<code>设计是一个复杂的、迭代的过程。最初的设计方案可能是错误的，当然也不是最优的。</code></p><p>“从难点开始”。</p><p>设计方案可能是启发式的、试验性的。</p><p>复杂的设计过程通常不能得出最佳的结果，但是我们必须尽力寻找一个“令人满意的”方案。找到最佳设计方案不可能或者代价太高，而“令人满意的”方案（而不是最佳方案）可以满足优秀设计标准，是值得（冒险）选择的解决问题的方法。</p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>29.<code>从设计转到编码阶段时，设计者按照自己掌握的水平，已经将问题分解为“原语”。如果编程者和设计者不是同一个人，二者的“原语”不吻合，就会出问题。</code></p><p>如果设计者的原语层次比编码者高，编码者无法将此设计作为起点。因此，编码者在真正编码之前需要花费时间完成额外的设计，填补中间的层次。</p><p>不要轻易将设计工作和编码工作分开。</p><p>30.<code>COBOL是一种糟糕的语言，但是其他的（用于商业数据处理的）语言也同样糟糕。</code></p><p>31.<code>错误消除是软件生命周期中最耗时的阶段。</code></p><p>对于许多软件产品而言，错误消除所用的时间比汇集需求、进行设计或编码都长，通常长一倍。</p><p>“需求-分析-编码-错误消除”所占比例：20-20-20-40 或者 25-25-20-30。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>32.<code>普通程序员认为已经彻底测试过的软件其实只执行了55%～60%的逻辑路径。采用覆盖分析器等自动工具，可以将上述比例提高到85%～90，几乎不可能测试软件中100%的逻辑路径。</code></p><ul><li>需求驱动测试（测试是否满足了所有需求）</li><li>结构驱动测试（测试已构建的软件的所有组成部分是否正确运行）</li><li>统计驱动测试（随机测试确定软件执行的时间和结果）</li><li>风险驱动测试（测试确定是否已经消除了最主要的风险）</li></ul><p>由于软件产品固有的复杂性，任何测试都不会是彻底的测试。因此，（a）测试工作实际上是一种折衷的活动，关键是作出适当的折衷选择；（b）许多重要软件的发行版中存在错误，这不足为奇（追求无瑕疵软件的想法是天真的）。</p><p>33.<strong><code>即使测试覆盖有可能达到100%，这种测试也不够。大约35%的错误是源于逻辑路径的缺失，还有40%的错误源于执行特定的路径组合。不可能实现100%的覆盖。</code></strong></p><p>为了构建成功的、可靠的软件，需要综合采用多种错误消除方法，通常是越多越好。对于这个问题，没有神奇魔法。</p><p>34.<code>没有工具就无法做好错误消除工作。人们常用调试器，很少使用覆盖分析器等其他工具。</code></p><p>35.<code>自动测试很少，也就是说有些测试可以也应该自动化，但是有许多测试任务不能自动完成。</code></p><p>36.<code>程序员在程序中嵌入测试代码、目标代码中的编译参数等方法，都是测试工具的重要补充。</code></p><h2 id="评审和检查"><a href="#评审和检查" class="headerlink" title="评审和检查"></a>评审和检查</h2><p>37.<code>在运行第一个测试用例之前进行严格审查可以消除软件产品中多大90%的错误。</code></p><p>要找到同一个错误，审查的成本低于测试的成本。</p><p>在软件生命周期各个阶段的产品都可以审查。</p><p>决定检查成败的关键不是采用形式化的过程，而是团队成员在审查过程中的严格程度和注意力集中程度。</p><p>38.<code>虽然严格审查有很多优点，但是不能也不应该代替测试。</code></p><p>39.<code>通常认为，事后评审对于了解客户的满意程度和改进过程都很重要。但是很多软件公司不开展事后评审。</code></p><p>软件业的智慧一直没有增长。</p><p>我们在疯狂追求新东西时，往往抛弃了许多旧东西（例如极限编程和敏捷开发等最新的软件方法倾向于拒绝老方法中积累的智慧）。</p><p>软件业一直忙于加速工作，以致于没有时间考虑如何做得更好，而不只是更快。</p><p>40.<code>同行评审涉及技术和社会两方面问题，忽视任何一方面都会产生严重的灾难。</code></p><p>在评审过程中，参与者应该尽力熟知当前软件中的每一个决定和细节。</p><p>评审者必须从评审对象作者的角度来处理评审对象，而不是按照自己的方式，所以评审非常难。许多人穿上别人的鞋都寸步难行。</p><p>大多数人在软件产品中投入大量的情感和智力，因此如果被别人评头论足将会非常敏感。</p><p>禁止经理参加评审（他们倾向于评审开发者，而不是评审产品）；<br>禁止没有准备的人参加评审（他们会使有准备着失望，还会偏离主题）；<br>开发者不能作为评审主管（缩小可能涉及到开发者的自我因素）。</p><h2 id="维护"><a href="#维护" class="headerlink" title="维护"></a>维护</h2><p>41.<strong><code>维护开支通常占软件成本的40%～80%（平均为60%）。因此，维护可能是软件生命周期中最重要的阶段。</code></strong></p><p>软件维护就是在发现错误时进行修订，并在必要时做修改。</p><blockquote><p> 古老的硬件会被抛弃，古老的软件每天都在使用。</p></blockquote><p>42.<strong><code>增强功能大约占软件维护成本的60%，错误更正仅占17%。因此，软件维护的主体是在旧软件中加入新功能，而不是更正错误。</code></strong></p><p>60%: 改进，增强功能<br>18%: 适应性维护，即在改变工作环境时保证软件正常运行，如再另一台计算机上运行、在另一种操作系统上运行、与新的软件包交互、引入新设备等。<br>17%: 错误更正<br>5%:  为了使软件更容易维护所作出的维护工作（预防性维护Preventive Maintenance，重构refactoring）</p><p><strong>60/60规则：60%的软件成本用于软件维护，维护成本60%用于功能增强。因此，增强旧软件是个大问题。</strong></p><p>43.<code>维护是解决方案，而不是问题。</code></p><p>假设软件维护只是修正错误，那么软件维护才是个问题。</p><p>只有维护才能解决在软件中独有的一个问题，即“我们已经构建了一个东西，但是现在需要一个稍微不同的东西。”</p><p>44.<code>比较软件开发和软件维护中的工作，除了维护中“理解现有的产品”这项工作之外，其他工作都一样。这项工作占据了大约30%的维护时间，是主要的维护活动，因此可以说维护比开发更难。</code></p><p>45.<strong><code>更好的软件工程开发导致更多而不是更少的维护。</code></strong></p><p>与构建糟糕的系统相比，构建良好的系统更容易实现功能增强，这样人们对他们的修改更多，导致这些系统的维护时间更长。</p><p>如果我们把维护活动视为一种方案，那么维护越多越好。假如我们执意认为维护是一个问题，那么就无法将维护活动的增加视为一件好事。</p><h1 id="质量"><a href="#质量" class="headerlink" title="质量"></a>质量</h1><h2 id="质量-1"><a href="#质量-1" class="headerlink" title="质量"></a>质量</h2><p>46.<code>质量是一组属性的组合。</code></p><ol><li><strong>可移植性</strong>是指生成易于在不同平台之间移植的软件产品。</li><li><strong>可靠性</strong>是指软件产品满足预期的要求，值得信赖。</li><li><strong>效率</strong>是指软件产品在运行时间和空间消耗上的经济性。</li><li><strong>人类工程学</strong>(又称为可用性)是指软件产品用起来既容易又舒服。</li><li><strong>可测试性</strong>是指软件产品易于测试。</li><li><strong>易理解性</strong>是指维护者易于理解软件产品。</li><li><strong>可修改性</strong>是指维护者易于修改软件产品。</li></ol><p>47.<code>软件质量不是用户满意、满足需求、满足成本和时间表目标，或者可靠性。</code></p><blockquote><p>用户满意 = 满足需求 + 按时提交 + 适当的成本 + 产品质量</p></blockquote><h2 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h2><ol start="48"><li><code>绝大多数程序员都会犯某些错误。</code></li></ol><p>49.<code>错误通畅聚集在一起。</code></p><blockquote><p>半数的错误发现在15%的模块中。</p></blockquote><p>50.<code>没有唯一最好的消除软件错误的方法。</code></p><p>51.<code>总会有残存的错误。我们的目标应该是消除严重错误，或者使之最少。</code></p><p>一项2002年的研究：两个采用完全不同软件开发方法（一个团队使用传统方法，处于CMM4；另一个团队采用前卫的形式化方法）的团队都不能构建一个可靠性达到98%的简单产品。</p><p>关于残存错误：</p><ul><li>有经验的个人实践可以使错误的发生减少75%</li><li>大约40%～50%的用户程序包含着较显著的缺陷。</li><li>你不会发现所有的bug<br>关于残存的严重错误：</li><li>小于10%的错误导致90%故障的发生。</li></ul><h2 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h2><p>52.<code>效率主要来自于优秀的设计，而不是优秀的编码。</code></p><p>数据结构是增加逻辑复杂性和改善数据访问效率之间的折衷。因此在设计阶段应认真选择正确的数据结构、文件结构或者数据库访问方法。</p><p>在设计阶段对效率的细微考虑比漂亮的编码更有意义。</p><p>53.<code>高级语言（High-order language，HOL）代码配合适当的编译器优化，大约可以达到汇编语言90%的效率。对于一些复杂的现代体系结构，效率更高。</code></p><p>54.<code>在空间和时间之前存在折衷。通常，改进一方面会降低另一方面。</code></p><p>三角函数：函数值列表，空间换时间。<br>Java: 编译后的字节码比机器码紧凑，但是时间效率很低；JIT（Just-In-Time）编译器可以将字节码编译为机器码。</p><h1 id="研究"><a href="#研究" class="headerlink" title="研究"></a>研究</h1><p>55.<code>许多软件研究者不是做调查，而是鼓吹。因此，（a）有些概念比鼓吹的糟糕、更少；（b）缺少有助于确定这些概念真实价值的评估性研究。</code></p><h1 id="谬误"><a href="#谬误" class="headerlink" title="谬误"></a>谬误</h1><p>1.<code>你不能管理自己无法度量的东西。</code></p><p>优秀的知识管理者趋向于定性度量，而非定量度量。</p><p>实际情况是度量对于软件管理非常重要，谬误存在于具体进行度量的手段和过程中。</p><p>2.<code>可以管理软件产品的质量。</code></p><p>所有的质量属性都有很深刻的技术内容，只有技术人员才能处理这些技术内容。</p><p>3.<code>可以，也应该“忘我”地编程。</code></p><p>我们不可能为了满足别人的需求来抑制自己的需求，我们也同样不太可能为了团队的利益而抑制自我。一个有效运行的系统必须承认人的个性，也必须在这些个性的范围内运作。</p><p>4.<code>工具和技术是通用（one site fits all）的。</code></p><p>5.<code>软件需要更多的方法论。</code></p><p>6.<code>要估算成本和时间表，应首先估算代码行数。</code></p><p>7.<code>随机测试输入是优化测试的好方法。</code></p><p>8.<code>如果有了足够多的关注，所有的bug都显而易见。</code></p><ul><li>错误的深浅与查找错误的人数没有关系。</li><li>有关审查的研究表明：增加审查人数，发现错误数量的增加幅度会迅速减少。</li><li>没有数据表明这句话的正确性。</li></ul><p>9.<code>估计将来的维护成本和做出产品更新的决策需要参考过去的成本数据。</code></p><p>10.<code>教别人编程的方法是教别人写程序。</code></p><p>就像写作一样，要先读后写。</p><ul><li>要教授读代码，我们必须选择所读的范例。</li><li>要教授读代码，需要指导性的教科书，但是却没有。都是关于如何写代码的。</li><li>标准课程教授先写后读，形成了制度。</li><li>我们在软件中需要读代码的唯一时机是维护。维护很不受欢迎，理由之一是读代码是一项非常难的活动。发挥你的创造力写新代码比读别人的老代码有意思得多。</li></ul><blockquote><p>成为程序员最好的方法是写程序，研究别人所写的优秀的程序。。。我到计算机科学中心的垃圾桶里找到了他们操作系统的列表。 —Bill Gates</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2017/05/12/reading-notes-3-Facts-and-fallacies-of-software-engineering/cover.jpg&quot; class=&quot;&quot;&gt;

&lt;p&gt;软件工程的55个事实和5+5个谬误。&lt;br&gt;划重点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;软件过程和软件产品的&lt;code&gt;复杂性&lt;/code&gt;决定了我们在该领域的许多认识和行为。复杂性不可避免，我们不应该与之对立，而应该学会适应它。&lt;/li&gt;
&lt;li&gt;在软件领域，糟糕的&lt;code&gt;估算&lt;/code&gt;和由此带来的&lt;code&gt;时间表压力&lt;/code&gt;一直在迫害我们。&lt;/li&gt;
&lt;li&gt;在软件管理者和技术人员之间有&lt;code&gt;隔阂&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;鼓吹&lt;/code&gt;和&lt;code&gt;通用&lt;/code&gt;的观念影响了我们形成专注于有力的、明智的项目方案的能力。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="reading-notes" scheme="https://www.wuchenxu.com/categories/reading-notes/"/>
    
    
      <category term="technical" scheme="https://www.wuchenxu.com/tags/technical/"/>
    
      <category term="reading-notes" scheme="https://www.wuchenxu.com/tags/reading-notes/"/>
    
  </entry>
  
  <entry>
    <title>一线架构师实践指南 by 温昱</title>
    <link href="https://www.wuchenxu.com/2017/05/05/reading-notes-2-practice-guide-for-frontline-architects/"/>
    <id>https://www.wuchenxu.com/2017/05/05/reading-notes-2-practice-guide-for-frontline-architects/</id>
    <published>2017-05-05T15:54:00.000Z</published>
    <updated>2017-07-16T13:18:06.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/2017/05/05/reading-notes-2-practice-guide-for-frontline-architects/cover.png" class=""><p>本书从架构师实际困惑出发，提出一套具有可操作性的方法体系来解决这些问题，作者很擅长用图例、表格来阐述观点，让人很受用。</p><a id="more"></a><p>思维导图：</p><img src="/2017/05/05/reading-notes-2-practice-guide-for-frontline-architects/%E4%B8%80%E7%BA%BF%E6%9E%B6%E6%9E%84%E5%B8%88%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97.png" class="">]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2017/05/05/reading-notes-2-practice-guide-for-frontline-architects/cover.png&quot; class=&quot;&quot;&gt;
&lt;p&gt;本书从架构师实际困惑出发，提出一套具有可操作性的方法体系来解决这些问题，作者很擅长用图例、表格来阐述观点，让人很受用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="reading-notes" scheme="https://www.wuchenxu.com/categories/reading-notes/"/>
    
    
      <category term="technical" scheme="https://www.wuchenxu.com/tags/technical/"/>
    
      <category term="reading-notes" scheme="https://www.wuchenxu.com/tags/reading-notes/"/>
    
  </entry>
  
</feed>
