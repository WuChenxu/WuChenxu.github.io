<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>玉汝于成，功不唐捐</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.wuchenxu.com/"/>
  <updated>2019-10-07T13:53:01.559Z</updated>
  <id>https://www.wuchenxu.com/</id>
  
  <author>
    <name>WU Chenxu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>The Clean Coder by Robert C. Martin</title>
    <link href="https://www.wuchenxu.com/2019/10/07/reading-notes-5-The-Clean-Coder/"/>
    <id>https://www.wuchenxu.com/2019/10/07/reading-notes-5-The-Clean-Coder/</id>
    <published>2019-10-07T13:44:27.000Z</published>
    <updated>2019-10-07T13:53:01.559Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/10/07/reading-notes-5-The-Clean-Coder/clean_coder_cover.jpg"><a id="more"></a><img src="/2019/10/07/reading-notes-5-The-Clean-Coder/Clean_Coder.png">]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2019/10/07/reading-notes-5-The-Clean-Coder/clean_coder_cover.jpg&quot;&gt;
    
    </summary>
    
      <category term="reading-notes" scheme="https://www.wuchenxu.com/categories/reading-notes/"/>
    
    
      <category term="reading-notes" scheme="https://www.wuchenxu.com/tags/reading-notes/"/>
    
      <category term="coder" scheme="https://www.wuchenxu.com/tags/coder/"/>
    
  </entry>
  
  <entry>
    <title>Head Frist 设计模式 by Freeman E.</title>
    <link href="https://www.wuchenxu.com/2019/05/02/reading-notes-4-Head-First-Design-Pattern/"/>
    <id>https://www.wuchenxu.com/2019/05/02/reading-notes-4-Head-First-Design-Pattern/</id>
    <published>2019-05-02T09:28:05.000Z</published>
    <updated>2019-08-04T08:54:26.199Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/02/reading-notes-4-Head-First-Design-Pattern/HFDP.jpg"><a id="more"></a><h1 id="Head-First-Design-Patterns"><a href="#Head-First-Design-Patterns" class="headerlink" title="Head First Design Patterns"></a>Head First Design Patterns</h1><h2 id="Head-Frist学习原则"><a href="#Head-Frist学习原则" class="headerlink" title="Head Frist学习原则"></a>Head Frist学习原则</h2><ol><li>慢一点，你理解的越多，需要记的就越少。</li><li>勤做练习，自己记笔记。</li><li>There are no dumb Questions。</li><li>上床睡觉之前不要再看别的书了，或者至少不再看其他有难度的东西。</li><li>要喝水，而且要多喝水。</li><li>大声说出来。</li><li>听听你大脑怎么说。</li><li>要有点感觉！</li><li>设计一些东西！</li></ol><h2 id="为什么需要设计模式"><a href="#为什么需要设计模式" class="headerlink" title="为什么需要设计模式"></a>为什么需要设计模式</h2><ol><li>知道OO基础，并不足以让你设计出良好的OO系统。</li><li>良好的OO设计必须具备可复用、可扩展、可维护三个特性。</li><li>模式可以让我们建造出具有良好OO设计质量的系统。</li><li>模式被认为是经过验证的OO设计经验。</li><li>模式不是代码，而是针对设计问题的通用解决方案。你可以把它们应用到特定的应用中。</li><li>模式不是被发明，而是被发现。</li><li>大多数的模式和原则着眼于软件变化的主题。</li><li>大多数的模式都允许系统局部变化独立于其他部分。</li><li>我们常把系统中变化的部分抽出来封装。</li><li>模式让开发人员之间有共享的语言，能够最大化沟通的价值。</li></ol><h1 id="OO基础"><a href="#OO基础" class="headerlink" title="OO基础"></a>OO基础</h1><ol><li>抽象（Abstract）</li><li>封装（Encapsulate）</li><li>多态（Polymorphic）</li><li>继承（Inheritance）</li></ol><h1 id="OO设计原则"><a href="#OO设计原则" class="headerlink" title="OO设计原则"></a>OO设计原则</h1><h2 id="高内聚，低耦合"><a href="#高内聚，低耦合" class="headerlink" title="高内聚，低耦合"></a>高内聚，低耦合</h2><blockquote><p>High cohesion, low coupling.<br>这是最基本的设计原则，其他原则可以认为是该原则的外延。</p></blockquote><h2 id="单一职责原则（Single-Responsibility-Priciple）"><a href="#单一职责原则（Single-Responsibility-Priciple）" class="headerlink" title="单一职责原则（Single Responsibility Priciple）"></a>单一职责原则（<strong>S</strong>ingle <strong>R</strong>esponsibility <strong>P</strong>riciple）</h2><blockquote><p>一个类应该只有一个职责。一个类应该只有一个引起变化的原因。</p></blockquote><h2 id="开闭原则（Open-Closed-Priciple）"><a href="#开闭原则（Open-Closed-Priciple）" class="headerlink" title="开闭原则（Open/Closed Priciple）"></a>开闭原则（<strong>O</strong>pen/<strong>C</strong>losed <strong>P</strong>riciple）</h2><blockquote><p>类应该对扩展开放，对修改关闭。Open to extension and closed to modifcaiton.</p></blockquote><p>遵循开放-关闭原则通常会引入新的抽象层次，增加代码的复杂度。我们要把注意力几种在设计中最有可能改变的地方来应用开闭原则。</p><h2 id="里氏代换原则（Liskov-Substitution-Priciple）"><a href="#里氏代换原则（Liskov-Substitution-Priciple）" class="headerlink" title="里氏代换原则（Liskov Substitution Priciple）"></a>里氏代换原则（<strong>L</strong>iskov <strong>S</strong>ubstitution <strong>P</strong>riciple）</h2><blockquote><p>一个可以接受基类对象的地方必然可以接受一个子类对象。</p></blockquote><h2 id="接口隔离原则（Interface-Segregation-Priciple）"><a href="#接口隔离原则（Interface-Segregation-Priciple）" class="headerlink" title="接口隔离原则（Interface Segregation Priciple）"></a>接口隔离原则（<strong>I</strong>nterface <strong>S</strong>egregation <strong>P</strong>riciple）</h2><blockquote><p>使用多个专门接口来取代一个统一的接口。</p></blockquote><h2 id="依赖倒置原则（Dependence-Inversion-Principle）"><a href="#依赖倒置原则（Dependence-Inversion-Principle）" class="headerlink" title="依赖倒置原则（Dependence Inversion Principle）"></a>依赖倒置原则（<strong>D</strong>ependence <strong>I</strong>nversion <strong>P</strong>rinciple）</h2><blockquote><p>要依赖抽象，不要依赖具体类。</p></blockquote><h2 id="针对接口编程，不针对实现编程（Program-to-interface，-not-an-implementation）"><a href="#针对接口编程，不针对实现编程（Program-to-interface，-not-an-implementation）" class="headerlink" title="针对接口编程，不针对实现编程（Program to interface， not an implementation）"></a>针对接口编程，不针对实现编程（Program to interface， not an implementation）</h2><h2 id="封装变化（Encapsulate-what-varies）"><a href="#封装变化（Encapsulate-what-varies）" class="headerlink" title="封装变化（Encapsulate what varies）"></a>封装变化（Encapsulate what varies）</h2><h2 id="合成复用原则（Composite-Reuse-Principle）"><a href="#合成复用原则（Composite-Reuse-Principle）" class="headerlink" title="合成复用原则（Composite Reuse Principle）"></a>合成复用原则（<strong>C</strong>omposite <strong>R</strong>euse <strong>P</strong>rinciple）</h2><blockquote><p>多用组合，少用继承（Composition Favor over inheritance）</p></blockquote><h2 id="为交互对象之间的松耦合设计而努力（loose-coupling）"><a href="#为交互对象之间的松耦合设计而努力（loose-coupling）" class="headerlink" title="为交互对象之间的松耦合设计而努力（loose coupling）"></a>为交互对象之间的松耦合设计而努力（loose coupling）</h2><h2 id="最少知识原则（Least-Knowledge-Principle）"><a href="#最少知识原则（Least-Knowledge-Principle）" class="headerlink" title="最少知识原则（Least Knowledge Principle）"></a>最少知识原则（<strong>L</strong>east <strong>K</strong>nowledge <strong>P</strong>rinciple）</h2><p>又称为<code>迪米特法则（Law of Demeter）</code></p><blockquote><p>只和你的密友谈话。</p></blockquote><h2 id="好莱坞原则（Hollywood-Principle）"><a href="#好莱坞原则（Hollywood-Principle）" class="headerlink" title="好莱坞原则（Hollywood Principle）"></a>好莱坞原则（Hollywood Principle）</h2><blockquote><p>别调用我们，我们会调用你。（Dont’t call us, we will call you.）</p></blockquote><p>将决策权放在高层模块中，以便决定如何以及何时调用低层模块。</p><h1 id="与架构模式、框架、模块的对比"><a href="#与架构模式、框架、模块的对比" class="headerlink" title="与架构模式、框架、模块的对比"></a>与架构模式、框架、模块的对比</h1><p>参考<a href="https://wuchenxu.com/2017/05/05/reading-notes-2-practice-guide-for-frontline-architects/" target="_blank" rel="noopener">一线架构师实践指南</a><br>设计模式，相比架构模式应用面更狭窄，针对于特定场景；相比与框架活着模块，更抽象。框架、模块本身也会用到设计模式。</p><img src="/2019/05/02/reading-notes-4-Head-First-Design-Pattern/design-patten_framework_architecture_module.jpeg"><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote><p><strong><code>策略模式（Strategy Pattern）</code></strong>定义算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。</p></blockquote><ul><li><p><a href="#OO设计原则">设计原则</a>：多用组合，少用继承; 封装变化；针对接口编程，不针对实现编程。</p></li><li><p><code>IS-A</code>：继承 ； <code>HAS-A/Implements</code>：组合</p></li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><a href="https://github.com/WuChenxu/Ruby/tree/master/HeadFirstDesignPattern/StrategyPattern" target="_blank" rel="noopener">strategy pattern in ruby</a></p><h3 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h3><img src="/2019/05/02/reading-notes-4-Head-First-Design-Pattern/strategy_pattern.svg" title="strategy pattern UML"><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><blockquote><p><strong><code>观察者模式（Observer Pattern）</code></strong>在对象之间定义一对多依赖，当一个对象的状态改变时，它的所有依赖者都会收到通知并自动更新。</p></blockquote><ul><li><p><a href="#OO设计原则">设计原则</a> ：松耦合；好莱坞原则。</p></li><li><p><code>观察者</code>和<code>可观察者</code>（主题）之间用松耦合方式结合（loose coupling），<code>可观察者</code>不知道<code>观察者</code>的细节，只知道<code>观察者</code>实现了<code>观察者</code>接口。</p></li><li><p>使用观察者模式，可以从观察者处推（push）或者拉（pull）数据。</p></li><li><p>有多个观察者时，不可以依赖特定的通知次序。</p></li></ul><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p><a href="https://github.com/WuChenxu/Ruby/tree/master/HeadFirstDesignPattern/ObserverPattern" target="_blank" rel="noopener">observer pattern in ruby</a></p><h3 id="UML-1"><a href="#UML-1" class="headerlink" title="UML"></a>UML</h3><img src="/2019/05/02/reading-notes-4-Head-First-Design-Pattern/observer_pattern.svg" title="observer pattern UML"><h3 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a>常见场景</h3><p>GUI框架里的按键等组件，注册不同的观察者到组件的不同类型事件上（如按键按下）。</p><h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><blockquote><p><strong><code>装饰者模式（Decorator/Wrapper Pattern）</code></strong>动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。</p></blockquote><ul><li><p><a href="#OO设计原则">设计原则</a> ：类应对扩展开放，对修改关闭。</p></li><li><p>装饰者和被装饰者对象有相同的超类，这里利用继承来达到“类型匹配”，而不是用继承来获得“行为”。</p></li><li><p>可以用一个或多个装饰着包装一个对象。</p></li><li><p>装饰者可以在所委托被装饰者的行为之前与/或之后，加上自己的行为。</p></li><li><p>装饰者一般对组件的客户是透明的，除非客户程序依赖于组件的具体类型。</p></li><li><p>装饰者会导致设计中出现许多小对象，如果过度使用，会让程序变得很复杂。</p></li><li><p>装饰者将一个对象包装起来以增加新的行为和责任；<a href="#适配器模式">适配器</a>将一个对象包装起来以改变其接口；<a href="#外观模式">外观</a>将一群对象“包装”起来以简化接口。</p></li><li><p>相关模式：<a href="#适配器模式">适配器</a>,<a href="#外观模式">外观模式</a></p></li></ul><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p><a href="https://github.com/WuChenxu/Ruby/tree/master/HeadFirstDesignPattern/DecoratorPattern" target="_blank" rel="noopener">decorator pattern in ruby</a></p><h3 id="UML-2"><a href="#UML-2" class="headerlink" title="UML"></a>UML</h3><img src="/2019/05/02/reading-notes-4-Head-First-Design-Pattern/decorator_pattern.svg" title="decorator pattern UML"><img src="/2019/05/02/reading-notes-4-Head-First-Design-Pattern/decorator_pattern_example.svg" title="decorator pattern example UML"><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><blockquote><p><strong><code>工厂方法模式（Factory Method Pattern）</code></strong>定义了创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。</p></blockquote><ul><li><a href="#OO设计原则">设计原则</a> ：要依赖抽象，不要依赖具体类；好莱坞原则。</li></ul><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><h3 id="UML-3"><a href="#UML-3" class="headerlink" title="UML"></a>UML</h3><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><blockquote><p><strong><code>抽象工厂模式（Abstract Factory Pattern）</code></strong>提供了一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。</p></blockquote><h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><h3 id="UML-4"><a href="#UML-4" class="headerlink" title="UML"></a>UML</h3><h2 id="单件模式"><a href="#单件模式" class="headerlink" title="单件模式"></a>单件模式</h2><h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h3><blockquote><p><strong><code>单件模式（Singleton Pattern）</code></strong>确保一个类只有一个实例，并提供一个全局访问点。</p></blockquote><ul><li>在JAVA中实现单件模式需要私有的构造器、一个静态方法和一个静态变量。</li><li>确定在性能和资源上的限制，然后小心地选择适当的方案来实现单件，以解决多线程问题（我们必须认定所有的程序都是多线程的）。</li></ul><h3 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h3><p><a href="https://github.com/WuChenxu/Ruby/tree/master/HeadFirstDesignPattern/SingletonPattern" target="_blank" rel="noopener">singleton pattern in ruby</a></p><h3 id="UML-5"><a href="#UML-5" class="headerlink" title="UML"></a>UML</h3><img src="/2019/05/02/reading-notes-4-Head-First-Design-Pattern/singleton_pattern.svg" title="singleton pattern UML"><h3 id="常见场景-1"><a href="#常见场景-1" class="headerlink" title="常见场景"></a>常见场景</h3><p>共享资源管理，如线程池（thread pool）、缓存池（cache）、注册表设置（registry setting）。</p><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><h3 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h3><blockquote><p><strong><code>命令模式（Command Pattern）</code></strong>将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。</p></blockquote><ul><li><a href="#OO设计原则">设计原则</a> ：松耦合。</li><li>在被解耦的两者之间是通过命令对象进行沟通的，命令对象封装了接受者和一个或一组动作。</li><li>调用者通过调用命令对象的execute()发出请求，这会使得接收者的动作被调用。</li><li>调用者可以接受命令当作参数，甚至在运行时动态地进行。</li><li>命令可以支持撤销，做法是实现一个undo()方法来回到execute()被执行前的状态。</li><li>宏命令是命令的一种简单的延伸，允许调用多个命令。宏方法也可以支持撤销。</li><li>实际操作时，很常见使用“聪明”命令对象，也就是直接实现了请求，而不是将工作委托给接收者。</li></ul><h3 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h3><h3 id="UML-6"><a href="#UML-6" class="headerlink" title="UML"></a>UML</h3><h3 id="常见场景-2"><a href="#常见场景-2" class="headerlink" title="常见场景"></a>常见场景</h3><p>队列请求（日程安排，线程池，工作队列等），日志请求，事务系统。</p><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><h3 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h3><blockquote><p><strong><code>适配器模式（Adapter Pattern）</code></strong>将一个类的接口，转换成客户期望的另一个接口。适配器让原来接口不兼容的类可以合作无间。</p></blockquote><ul><li><p>当使用一个现有的类而其接口并不符合你的需求时，就使用适配器。</p></li><li><p>适配器改变接口以符合客户的期望。</p></li><li><p>实现一个适配器可能需要一番功夫，也可能不费功夫，视目标接口的大小与复杂度而定。</p></li><li><p>适配器有两种形式：对象适配器和类适配器。类适配器需要用到多重继承。</p></li><li><p>适配器将一个对象包装起来以改变其接口；<a href="#装饰者模式">装饰者</a>将一个对象包装起来以增加新的行为和责任；<a href="#外观模式">外观</a>将一群对象“包装”起来以简化接口。</p></li><li><p>相关模式：<a href="#外观模式">外观模式</a>，<a href="#装饰者模式">装饰者模式</a></p></li></ul><h3 id="实现-7"><a href="#实现-7" class="headerlink" title="实现"></a>实现</h3><h3 id="UML-7"><a href="#UML-7" class="headerlink" title="UML"></a>UML</h3><h3 id="常见场景-3"><a href="#常见场景-3" class="headerlink" title="常见场景"></a>常见场景</h3><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><h3 id="定义-8"><a href="#定义-8" class="headerlink" title="定义"></a>定义</h3><blockquote><p><strong><code>外观模式（Facade Pattern）</code></strong>提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。</p></blockquote><ul><li><a href="#OO设计原则">设计原则</a> ：最少知识原则。</li><li>当需要简化并统一一个很大的接口或者一群复杂的接口时，使用外观。</li><li>外观将客户从一个复杂的子系统中解耦。</li><li>实现一个外观，需要将子系统组合进外观中，然后将工作委托给子系统执行。</li><li>外观将一群对象“包装”起来以简化接口；<a href="#适配器模式">适配器</a>将一个对象包装起来以改变其接口；<a href="#装饰者模式">装饰者</a>将一个对象包装起来以增加新的行为和责任；</li><li>相关模式：<a href="#适配器模式">适配器模式</a>，<a href="#装饰者模式">装饰者模式</a></li></ul><h3 id="实现-8"><a href="#实现-8" class="headerlink" title="实现"></a>实现</h3><h3 id="UML-8"><a href="#UML-8" class="headerlink" title="UML"></a>UML</h3><h3 id="常见场景-4"><a href="#常见场景-4" class="headerlink" title="常见场景"></a>常见场景</h3><h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><h3 id="定义-9"><a href="#定义-9" class="headerlink" title="定义"></a>定义</h3><blockquote><p><strong><code>模板方法模式（Template Method Pattern）</code></strong>在一个方法中定义了一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。</p></blockquote><ul><li><a href="#OO设计原则">设计原则</a> ：好莱坞原则。</li><li>模板方法是一种重要的代码复用技巧。</li><li>模板方法的抽象类可以定义具体方法、抽象方法和钩子。</li><li>钩子是一种方法，它在抽象类中不做事，活着只做默认的事情，子类可以选择要不要取覆盖它。</li><li><a href="#策略模式">策略模式</a>和模板方法模式都封装算法，一个用组合，一个用继承。</li><li><a href="#工厂方法模式">工厂方法</a>由子类决定实例化哪个类，是模板方法的一个特殊版本。</li><li>相关模式：<a href="#工厂方法模式">工厂方法</a>，<a href="#策略模式">策略模式</a></li></ul><h3 id="实现-9"><a href="#实现-9" class="headerlink" title="实现"></a>实现</h3><h3 id="UML-9"><a href="#UML-9" class="headerlink" title="UML"></a>UML</h3><h3 id="常见场景-5"><a href="#常见场景-5" class="headerlink" title="常见场景"></a>常见场景</h3><p>排序算法（CompareTo接口），Swing窗口，Applet</p><h2 id="外观模式-1"><a href="#外观模式-1" class="headerlink" title="外观模式"></a>外观模式</h2><h3 id="定义-10"><a href="#定义-10" class="headerlink" title="定义"></a>定义</h3><blockquote><p><strong><code>外观模式（Facade Pattern）</code></strong>提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。</p></blockquote><ul><li><a href="#OO设计原则">设计原则</a> ：最少知识原则。</li><li>当需要简化并统一一个很大的接口或者一群复杂的接口时，使用外观。</li><li>外观将客户从一个复杂的子系统中解耦。</li><li>实现一个外观，需要将子系统组合进外观中，然后将工作委托给子系统执行。</li><li>外观将一群对象“包装”起来以简化接口；<a href="#适配器模式">适配器</a>将一个对象包装起来以改变其接口；<a href="#装饰者模式">装饰者</a>将一个对象包装起来以增加新的行为和责任；</li><li>相关模式：<a href="#适配器模式">适配器模式</a>，<a href="#装饰者模式">装饰者模式</a></li></ul><h3 id="实现-10"><a href="#实现-10" class="headerlink" title="实现"></a>实现</h3><h3 id="UML-10"><a href="#UML-10" class="headerlink" title="UML"></a>UML</h3><h3 id="常见场景-6"><a href="#常见场景-6" class="headerlink" title="常见场景"></a>常见场景</h3><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><h3 id="定义-11"><a href="#定义-11" class="headerlink" title="定义"></a>定义</h3><blockquote><p><strong><code>迭代器模式（Iterator Pattern）</code></strong>提供一种方法顺序访问一个聚合（aggregate）对象的各个元素，而又不暴露其内部的表示。</p></blockquote><ul><li><a href="#OO设计原则">设计原则</a> ：封装变化；单一职责。</li><li>迭代器将遍历聚合的工具封装进一个对象中。</li><li>当使用迭代器的时候，我们依赖聚合提供遍历。</li><li>把游走的任务放在迭代器上，而不是聚合上。这样简化了聚合的接口和实现，也让责任各得其所。</li><li>迭代器提供了一个通用的接口，让我们遍历聚合的项，当我们编码使用聚合的项时，就可以使用多态机制。</li><li>对迭代器而言，数据结构可以是有次序的，或者没有次序的，甚至数据可以重复的。除非某个集合的文件有特别说明，否则不可以对迭代器取出元素的大小顺序作假设。</li></ul><h3 id="实现-11"><a href="#实现-11" class="headerlink" title="实现"></a>实现</h3><h3 id="UML-11"><a href="#UML-11" class="headerlink" title="UML"></a>UML</h3><h3 id="常见场景-7"><a href="#常见场景-7" class="headerlink" title="常见场景"></a>常见场景</h3><p>排序算法（CompareTo接口），Swing窗口，Applet<br>Reference:</p><ol><li><a href="https://appliedstochastics.com/articles/hfdp_ruby_01.html" target="_blank" rel="noopener">strategy pattern in ruby</a></li><li><a href="http://www.cnblogs.com/zhaoyan001/p/6365064.html" target="_blank" rel="noopener">单例模式的八种写法比较</a></li><li><a href="https://thoughtbot.com/blog/evaluating-alternative-decorator-implementations-in" target="_blank" rel="noopener">Evaluating Alternative Decorator Implementations In Ruby</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2019/05/02/reading-notes-4-Head-First-Design-Pattern/HFDP.jpg&quot;&gt;
    
    </summary>
    
      <category term="reading-notes" scheme="https://www.wuchenxu.com/categories/reading-notes/"/>
    
    
      <category term="technical" scheme="https://www.wuchenxu.com/tags/technical/"/>
    
      <category term="reading-notes" scheme="https://www.wuchenxu.com/tags/reading-notes/"/>
    
      <category term="ruby" scheme="https://www.wuchenxu.com/tags/ruby/"/>
    
  </entry>
  
  <entry>
    <title>Unix/Linux command(1):find 与 grep</title>
    <link href="https://www.wuchenxu.com/2018/12/31/Unix-Linux-cmd-1-find-grep/"/>
    <id>https://www.wuchenxu.com/2018/12/31/Unix-Linux-cmd-1-find-grep/</id>
    <published>2018-12-31T14:10:04.000Z</published>
    <updated>2019-01-01T14:46:51.995Z</updated>
    
    <content type="html"><![CDATA[<p>find - search for files in a directory hierarchy<br>grep, egrep, fgrep, zgrep, zegrep, zfgrep - print lines that match patterns</p><a id="more"></a><p>此文与<a href="https://wuchenxu.com/2016/03/30/windows-cmd-9-find-findstr/" target="_blank" rel="noopener">windows command(9):FIND FINDSTR</a>对照。</p><h1 id="查找字符串"><a href="#查找字符串" class="headerlink" title="查找字符串"></a>查找字符串</h1><p>windows中的<code>find/findstr</code>更改为<code>grep</code>即可，实现在单个文件中查找某个字符串。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$grep</span> <span class="string">"hello there"</span> hi.txt</span><br><span class="line">hello there</span><br></pre></td></tr></table></figure><h1 id="查找的字符串中有-quot"><a href="#查找的字符串中有-quot" class="headerlink" title="查找的字符串中有&quot;"></a>查找的字符串中有<code>&quot;</code></h1><p>由于<code>grep</code>的pattern是支持正则表达式regex的，所有只要用<code>\&quot;</code>转义<code>&quot;</code>即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$grep</span> <span class="string">"\"hello"</span> hi.txt</span><br><span class="line">h<span class="string">"hello"</span>h</span><br></pre></td></tr></table></figure><h1 id="多文件查找"><a href="#多文件查找" class="headerlink" title="多文件查找"></a>多文件查找</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">"hello"</span> *.txt</span><br></pre></td></tr></table></figure><h1 id="查找目录"><a href="#查找目录" class="headerlink" title="查找目录"></a>查找目录</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grep -nir <span class="string">"music.163"</span> ./ <span class="comment"># 查找当前文件夹及其子目录下包含`music.163`字符串的文件，并打印行号</span></span><br><span class="line"></span><br><span class="line">find . -name <span class="string">"file_name"</span> | xargs grep -nir <span class="string">"search_string"</span> <span class="comment"># 过滤文件之后，对每个文件查找</span></span><br></pre></td></tr></table></figure><h1 id="显示行号"><a href="#显示行号" class="headerlink" title="显示行号"></a>显示行号</h1><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$grep</span> -n <span class="string">"hello"</span> hi.txt</span><br><span class="line"><span class="number">1</span><span class="symbol">:hello</span></span><br><span class="line"><span class="number">2</span><span class="symbol">:h<span class="string">"hello"</span>h</span></span><br><span class="line"><span class="number">3</span><span class="symbol">:hello</span> there</span><br></pre></td></tr></table></figure><h1 id="通配符查找"><a href="#通配符查找" class="headerlink" title="通配符查找"></a>通配符查找</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$grep</span>  <span class="string">'.*llo'</span> hi.txt</span><br><span class="line">hello</span><br><span class="line">h<span class="string">"hello"</span>h</span><br><span class="line">hello there</span><br></pre></td></tr></table></figure><h1 id="find"><a href="#find" class="headerlink" title="find"></a>find</h1><p>常用option：<br><code>-name</code>: name matching, can use regex.<br><code>-iname</code>: like<code>-name</code>, but case insensitive.<br><code>-regex</code>: regex匹配文件名（包含路径），eg<code>find ./ -regex &quot;.*/*hexo.py&quot;</code>.<br><code>-type</code>: file type.<code>d</code> is directory, <code>f</code> is file.</p><figure class="highlight bash"><figcaption><span>find-examples</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">find / \! -name <span class="string">"*.c"</span> -<span class="built_in">print</span></span><br><span class="line">     Print out a list of all the files whose names <span class="keyword">do</span> not end <span class="keyword">in</span> .c.</span><br><span class="line"></span><br><span class="line">find / -newer ttt -user wnj -<span class="built_in">print</span></span><br><span class="line">     Print out a list of all the files owned by user ``wnj<span class="string">''</span> that are</span><br><span class="line">     newer than the file ttt.</span><br><span class="line"></span><br><span class="line">find / \! \( -newer ttt -user wnj \) -<span class="built_in">print</span></span><br><span class="line">     Print out a list of all the files <span class="built_in">which</span> are not both newer than</span><br><span class="line">     ttt and owned by ``wnj<span class="string">''</span>.</span><br><span class="line"></span><br><span class="line">find / \( -newer ttt -or -user wnj \) -<span class="built_in">print</span></span><br><span class="line">     Print out a list of all the files that are either owned by</span><br><span class="line">     ``wnj<span class="string">''</span> or that are newer than ttt.</span><br><span class="line"></span><br><span class="line">find / -newerct <span class="string">'1 minute ago'</span> -<span class="built_in">print</span></span><br><span class="line">     Print out a list of all the files whose inode change time is more</span><br><span class="line">     recent than the current time minus one minute.</span><br><span class="line"></span><br><span class="line">find / -<span class="built_in">type</span> f -<span class="built_in">exec</span> <span class="built_in">echo</span> &#123;&#125; \;</span><br><span class="line">      Use the <span class="built_in">echo</span>(1) <span class="built_in">command</span> to <span class="built_in">print</span> out a list of all the files.</span><br><span class="line"></span><br><span class="line">find -L /usr/ports/packages -<span class="built_in">type</span> l -<span class="built_in">exec</span> rm -- &#123;&#125; +</span><br><span class="line">     Delete all broken symbolic links <span class="keyword">in</span> /usr/ports/packages.</span><br><span class="line"></span><br><span class="line">find /usr/src -name CVS -prune -o -depth +6 -<span class="built_in">print</span></span><br><span class="line">     Find files and directories that are at least seven levels deep <span class="keyword">in</span></span><br><span class="line">     the working directory /usr/src.</span><br><span class="line"></span><br><span class="line">find /usr/src -name CVS -prune -o -mindepth 7 -<span class="built_in">print</span></span><br><span class="line">     Is not equivalent to the previous example, since -prune is not</span><br><span class="line">     evaluated below level seven.</span><br></pre></td></tr></table></figure><h1 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h1><p>常用option:<br><code>-i（--ignore-case）</code>: 忽略大小写<br><code>-r (--recursive）</code>: 递归查找子目录<br><code>-n (--line-number)</code>: 打印行号<br><code>-l (--files-with-match)</code>: 只打印匹配的文件名</p><figure class="highlight bash"><figcaption><span>grep-examples</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># To find all occurrences of the word `patricia' in a file:</span></span><br><span class="line"></span><br><span class="line">$ grep <span class="string">'patricia'</span> myfile</span><br><span class="line"></span><br><span class="line"><span class="comment"># To find all occurrences of the pattern `.Pp' at the beginning of a line:</span></span><br><span class="line"></span><br><span class="line">$ grep <span class="string">'^\.Pp'</span> myfile</span><br><span class="line"></span><br><span class="line"><span class="comment"># The apostrophes ensure the entire expression is evaluated by grep instead</span></span><br><span class="line"><span class="comment"># of by the user's shell.  The caret `^' matches the null string at the</span></span><br><span class="line"><span class="comment"># beginning of a line, and the `\' escapes the `.', which would otherwise</span></span><br><span class="line"><span class="comment"># match any character.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># To find all lines in a file which do not contain the words `foo' or</span></span><br><span class="line"><span class="comment"># `bar':</span></span><br><span class="line"></span><br><span class="line">$ grep -v -e <span class="string">'foo'</span> -e <span class="string">'bar'</span> myfile</span><br><span class="line"></span><br><span class="line"><span class="comment"># A simple example of an extended regular expression:</span></span><br><span class="line">$ egrep <span class="string">'19|20|25'</span> calendar</span><br><span class="line"><span class="comment"># Peruses the file `calendar' looking for either 19, 20, or 25.</span></span><br></pre></td></tr></table></figure><p>References:</p><ol><li><code>man find</code> 与 <code>man grep</code></li><li><a href="http://man7.org/linux/man-pages/man1/find.1.html" target="_blank" rel="noopener">man find</a></li><li><a href="http://www.tutorialspoint.com/unix_commands/find.htm" target="_blank" rel="noopener">find example</a></li><li><a href="http://man7.org/linux/man-pages/man1/grep.1.html" target="_blank" rel="noopener">man grep</a></li><li><a href="http://www.tutorialspoint.com/unix_commands/grep.htm" target="_blank" rel="noopener">grep example</a></li><li><a href="http://www.cnblogs.com/jiangzhaowei/p/5451173.html" target="_blank" rel="noopener">linux find -regex 使用正则表达式</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;find - search for files in a directory hierarchy&lt;br&gt;grep, egrep, fgrep, zgrep, zegrep, zfgrep - print lines that match patterns&lt;/p&gt;
    
    </summary>
    
      <category term="Linux cmd" scheme="https://www.wuchenxu.com/categories/Linux-cmd/"/>
    
    
      <category term="Linux cmd" scheme="https://www.wuchenxu.com/tags/Linux-cmd/"/>
    
  </entry>
  
  <entry>
    <title>理想的知识结构模型</title>
    <link href="https://www.wuchenxu.com/2018/12/27/Knowledge-model/"/>
    <id>https://www.wuchenxu.com/2018/12/27/Knowledge-model/</id>
    <published>2018-12-27T14:14:20.000Z</published>
    <updated>2019-11-24T12:56:00.555Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/12/27/Knowledge-model/knowledge-model.jpeg"><blockquote><p>在某个领域深耕细作的同时，不要忘记拓宽自己的知识面。如果一个人的领域太过专业化，一段时间后，你可能会发现自己的专业已经陈旧了。如果一个人的知识面很广，在终身教育的配合下，你的专业可以随着时代的变化而改变。<br>—  《MacTalk跨越边界》</p></blockquote><a id="more"></a><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>理想的知识结构模型应该是T字形，横表示广度，竖表示深度。缺一不可。<br><a href="https://wiki.mbalib.com/wiki/%E6%9C%A8%E6%A1%B6%E5%8E%9F%E7%90%86" target="_blank" rel="noopener">木桶理论</a>过分强调不要短板，广度优先，处处平衡;<br><a href="https://baike.sogou.com/v62597640.htm?fromTitle=%E9%95%BF%E6%9D%BF%E7%90%86%E8%AE%BA" target="_blank" rel="noopener">长板理论</a>过分强调深度，深度优先，精耕细作。<br>考虑到多个领域，可以是多个T的叠加（有些地方称为π型结构, π type talent），最终的结果就是类似于上图所示的图形，有点像二师兄的九齿钉耙。 :)<br>如果考虑到知识随着时间的迭代（动态性），那么我们最终会看到三个维度：</p><ul><li>广度：博</li><li>深度：专</li><li>时间：新</li></ul><h1 id="知识分类"><a href="#知识分类" class="headerlink" title="知识分类"></a>知识分类</h1><h2 id="广义"><a href="#广义" class="headerlink" title="广义"></a>广义</h2><p>所有的文字、语言、经验、哲学、科学、宗教都可以算是一种广义的知识。</p><h2 id="狭义"><a href="#狭义" class="headerlink" title="狭义"></a>狭义</h2><p>以软件开发为例：</p><ul><li>通用性的：如C语言、编程范式、设计模式、软件架构、软件开发流程。。。</li><li>领域相关的：如汽车领域软件开发：AUTOSAR架构、诊断、ASPICE、ISO26262.。。</li><li>产品相关的：如ADAS产品软件开发： 功能、距离检测算法、路径规划、横向控制、纵向控制。。。</li></ul><h1 id="训练方法"><a href="#训练方法" class="headerlink" title="训练方法"></a>训练方法</h1><ul><li>广度：<a href="https://ideas.ted.com/dont-have-10000-hours-to-learn-something-new-thats-fine-all-you-need-is-20-hours/" target="_blank" rel="noopener">关键20小时</a></li></ul><ol><li>Break down a skill into its components.</li><li>Learn enough to know when you’re making a mistake.</li><li>Remove any and all barriers to practice.</li><li>Practice for at least 20 hours.</li></ol><ul><li><p>深度：10000小时理论<br>人们眼中的天才之所以卓越非凡，并非天资超人一等，而是付出了持续不断的努力。只要经过1万小时的锤炼，任何人都能从平凡变成超凡。 — 《异类》（Utliers）</p></li><li><p>时间：<br>根据不同的知识种类进行迭代，可以通过RSS订阅，查看最新的前沿论文等。</p></li></ul><p>Reference:</p><ol><li><a href="https://blog.csdn.net/u014805066/article/details/64437617" target="_blank" rel="noopener">T型知识结构</a></li><li><a href="https://ideas.ted.com/dont-have-10000-hours-to-learn-something-new-thats-fine-all-you-need-is-20-hours/" target="_blank" rel="noopener">20 hours to learn something new</a></li><li><a href="https://www.zhihu.com/question/19933005" target="_blank" rel="noopener">哪些网站适合用于充电、学习新知识？</a></li><li><a href="https://www.jianshu.com/p/d625356dc3c5" target="_blank" rel="noopener">实现从T型知识结构到π型知识结构的转变</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2018/12/27/Knowledge-model/knowledge-model.jpeg&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;在某个领域深耕细作的同时，不要忘记拓宽自己的知识面。如果一个人的领域太过专业化，一段时间后，你可能会发现自己的专业已经陈旧了。如果一个人的知识面很广，在终身教育的配合下，你的专业可以随着时代的变化而改变。&lt;br&gt;—  《MacTalk跨越边界》&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="knowledge" scheme="https://www.wuchenxu.com/categories/knowledge/"/>
    
    
      <category term="knowledge" scheme="https://www.wuchenxu.com/tags/knowledge/"/>
    
  </entry>
  
  <entry>
    <title>functional safety and cyber security</title>
    <link href="https://www.wuchenxu.com/2018/05/11/safety-and-security/"/>
    <id>https://www.wuchenxu.com/2018/05/11/safety-and-security/</id>
    <published>2018-05-11T14:03:39.000Z</published>
    <updated>2018-05-11T15:23:04.237Z</updated>
    
    <content type="html"><![CDATA[<p>safety: 安全，侧重于防止系统的内部故障导致生命财产损失。<br>security： 安保/防护，侧重于防止外部侵入导致生命财产损失。<br>对应到汽车领域：functional safety(功能安全)与cyber security(网络安全)</p><a id="more"></a><h1 id="overview"><a href="#overview" class="headerlink" title="overview"></a>overview</h1><p>functional safety: absence of unreasonable risk due to hazards caused by malfunctioning behavior of E/E systems.<br>Cyber security : protection of systems from the theft and damage to their hardware, software or information, as well as from disruption or misdirection of the services they provide.</p><img src="/2018/05/11/safety-and-security/overview_safety_security.png"><p>功能安全还有个进化版本 SOTIF(Safety of the intended functionality, ISO21448).</p><h1 id="method"><a href="#method" class="headerlink" title="method"></a>method</h1><p>功能安全和网络安全的方法都需要在考虑整个产品生命周期（life cycle）的基础上，从两个大的方面来实施：技术与流程。</p><img src="/2018/05/11/safety-and-security/methods_safety_security.png"><p>功能安全的一些方法在ISO26262里有详细的推荐，包括硬件失效分析以及诊断方法，软件开发方法，测试方法等。</p><img src="/2018/05/11/safety-and-security/security_solutions.png"><img src="/2018/05/11/safety-and-security/safety_efforts.png"><h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><p><a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check" target="_blank" rel="noopener">CRC(Cyclic redundancy check)</a> - safety point of view: data error detection<br><a href="https://en.wikipedia.org/wiki/Message_authentication_code#Security" target="_blank" rel="noopener">MAC(Message authentication code)</a> - security point of view：data autenticity check.</p><p>References</p><ol><li><a href="https://www.zhihu.com/question/28426435?sort=created" target="_blank" rel="noopener">关于safety和security的翻译问题</a></li><li><a href="https://www.controleng.com/single-article/combining-functional-safety-and-cyber-security/" target="_blank" rel="noopener">Combining functional safety and cyber security</a></li><li><a href="https://vector.com/technologie-tage/files/VTT17_Grundlagenseminar_Security_Safety.pdf" target="_blank" rel="noopener">Functional safety and cyber security</a></li><li><a href="http://www.umtri.umich.edu/sites/default/files/Safety.2014.Andre_.Weimerskirch_0.pdf" target="_blank" rel="noopener">The relevance of cyber-security to functional safety of connected and automated vehicles</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;safety: 安全，侧重于防止系统的内部故障导致生命财产损失。&lt;br&gt;security： 安保/防护，侧重于防止外部侵入导致生命财产损失。&lt;br&gt;对应到汽车领域：functional safety(功能安全)与cyber security(网络安全)&lt;/p&gt;
    
    </summary>
    
      <category term="safety" scheme="https://www.wuchenxu.com/categories/safety/"/>
    
      <category term="security" scheme="https://www.wuchenxu.com/categories/safety/security/"/>
    
    
      <category term="safety" scheme="https://www.wuchenxu.com/tags/safety/"/>
    
      <category term="security" scheme="https://www.wuchenxu.com/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>软件开发(3):软件集成重名解决方案</title>
    <link href="https://www.wuchenxu.com/2018/04/15/integrate-files-with-same-name-same-function-in-C/"/>
    <id>https://www.wuchenxu.com/2018/04/15/integrate-files-with-same-name-same-function-in-C/</id>
    <published>2018-04-15T09:55:16.000Z</published>
    <updated>2019-01-01T14:40:02.539Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍了一种在软件集成过程中，遇到重名文件 和/或 重名函数时的解决方案。</p><a id="more"></a><h1 id="why"><a href="#why" class="headerlink" title="why"></a>why</h1><p>在<a href="https://wuchenxu.com/2017/02/27/software-design-2-variant-handling/" target="_blank" rel="noopener">software development(2):variant handling</a>一文中介绍了很多种variant管理的方法，其中有关于[link different libs](<a href="https://wuchenxu.com/2017/02/27/software-design-2-variant-handling/#link" target="_blank" rel="noopener">https://wuchenxu.com/2017/02/27/software-design-2-variant-handling/#link</a> different libs)的方法。<br>设想如下场景：开发过程中（针对C语言），各个模块分别由不同的团队开发，最后集成的时候，如果遇到重名的函数怎么处理？<br>本文针对这种场景，搜集了几种解决方案。</p><h1 id="what"><a href="#what" class="headerlink" title="what"></a>what</h1><p>场景设置: 三个模块，<code>a</code> <code>b</code> <code>os</code>，其中<code>a</code>和<code>b</code>模块都包含一个名字为<code>func_internal.c</code>的文件，这个同名文件中包含了名字一样的函数，分别为<code>int func_internal(void)</code>与<code>int func_internal(int a)</code>。这两个函数都没有申明为static，但是没有外部调用。</p><p><a href="https://github.com/WuChenxu/C/tree/master/link2step" target="_blank" rel="noopener">demo in github</a></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── README.md</span><br><span class="line">├── component_a</span><br><span class="line">│   ├── exported_sym.list</span><br><span class="line">│   ├── func_a.c</span><br><span class="line">│   ├── func_internal.c</span><br><span class="line">│   ├── func_internal.h</span><br><span class="line">│   ├── functions.h</span><br><span class="line">│   ├── makefile</span><br><span class="line">│   └── redefine.syms</span><br><span class="line">├── component_b</span><br><span class="line">│   ├── exported_sym.list</span><br><span class="line">│   ├── func_b.c</span><br><span class="line">│   ├── func_internal.c</span><br><span class="line">│   ├── func_internal.h</span><br><span class="line">│   ├── functions.h</span><br><span class="line">│   └── makefile</span><br><span class="line">├── makefile</span><br><span class="line">├── obj</span><br><span class="line">└── os</span><br><span class="line">    ├── exported_sym.list</span><br><span class="line">    ├── main.c</span><br><span class="line">    └── makefile</span><br></pre></td></tr></table></figure><figure class="highlight c"><figcaption><span> component_a/func_a.c</span><a href="/downloads/code/link2steps/component_a/func_a.c">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"functions.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"func_internal.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">func_internal_s</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func_a</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">   <span class="keyword">int</span> a = func_internal();</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"this is func a. %d\n"</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"this is static internal %d\n"</span>, func_internal_s());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure><figure class="highlight c"><figcaption><span> component_a/func_internal.c</span><a href="/downloads/code/link2steps/component_a/func_internal.c">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"functions.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func_internal</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><figure class="highlight c"><figcaption><span> component_b/func_b.c</span><a href="/downloads/code/link2steps/component_b/func_b.c">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"functions.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"func_internal.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">func_internal_s</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"func B %d\n"</span>, a);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func_b</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> a = func_internal(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"this is func b. %d"</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"internal func %d\n."</span>, func_internal_s(<span class="number">-100</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure><figure class="highlight c"><figcaption><span> component_b/func_internal.c</span><a href="/downloads/code/link2steps/component_b/func_internal.c">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"functions.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func_internal</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h1 id="how"><a href="#how" class="headerlink" title="how"></a>how</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol><li><p>由于有文件重名，所以不能每个<code>.c</code>单独编译成<code>.o</code>，然后再链接；<br>出现两个同名的<code>.o</code>，要不然链接器报错，要不然只用了其中一个<code>.o</code>，这样会导致运行时异常。</p></li><li><p>由于有函数重名，且函数没有申明为局部，链接的时候必然会出现错误：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">duplicate symbol _func_internal <span class="keyword">in</span>:</span><br><span class="line">    component_a/func_internal.o</span><br><span class="line">    component_b/func_internal.o</span><br></pre></td></tr></table></figure></li></ol><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>本文采用的方法：<br>每个模块单独编译成一个<code>.o</code>文件。</p><p>其他方法：</p><ol><li>重名文件改名；重名函数改名；局部函数申明为static。</li><li>定义函数时定义visibility属性（GUN only）<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((<span class="name">visibility</span>(<span class="string">"hidden"</span>)))</span><br></pre></td></tr></table></figure></li></ol><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>本文采用的方法：</p><p><code>-exported_symbols_list filename</code>(Mac) 或者 <code>--retain-symbols-file=filename</code>(linux)</p><figure class="highlight plain"><figcaption><span>link all the .o in each component to one .o file; and only export symbols in the list</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ld -r -exported_symbols_list exported_sym.list $&#123;OBJECTS&#125;  -o $&#123;TARGET&#125;.o</span><br></pre></td></tr></table></figure><img src="/2018/04/15/integrate-files-with-same-name-same-function-in-C/ld.png"><p>其实是强制将符号表里的全局符号(<code>T</code>)变成了局部符号(<code>t</code>)，这样除了列表文件里的函数，其他对外均不可见。</p><p>其他方法：</p><ol><li><p>gcc在链接时设置 -fvisibility=hidden，则不加 visibility声明的都默认为hidden; gcc默认设置 -fvisibility=default，即全部可见；</p></li><li><p>使用export map，gcc -Wl,–version-script=export.map, 在export.map中指定</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="attribute">global</span>:export_func;</span><br><span class="line"></span><br><span class="line"><span class="attribute">local</span>:*;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h3 id="objcopy"><a href="#objcopy" class="headerlink" title="objcopy"></a>objcopy</h3><ol><li><p>将全局符号修改为局部符号：<br><code>-L symbolname</code></p></li><li><p>替换符号名<br><code>--redefine-sym old=new</code><br><code>--redefine-syms=filename</code></p></li></ol><h1 id="recap"><a href="#recap" class="headerlink" title="recap"></a>recap</h1><ol><li>由于C语言没有namespace的概念，可以在开发之前约定好，所有的<code>全局函数</code>和<code>全局变量</code>都加上特殊的前缀，eg. <code>CompanyName_ProductName_ComponentName_FunctionName</code>。</li><li>所有的局部函数定义都加上static。</li><li>可以先编译各个模块，再链接（类似于每个模块编译成静态库），这样可以防止重名的文件名报错。</li><li>可以在链接的时候控制各个模块编译后全局函数，将内部使用的但没有申明为static的函数，在符号表中强制修改为local的符号。</li><li>链接后，可以通过<code>objcopy</code>改变符号的属性（全局-&gt;局部）或者 修改全局符号的名字。</li></ol><p>Reference：</p><ol><li><a href="https://developer.apple.com/library/content/technotes/tn2185/_index.html#//apple_ref/doc/uid/DTS10004200-CH1-SUBSECTION5" target="_blank" rel="noopener">Choosing Visibility Options for Mac</a></li><li><a href="https://www.ibm.com/developerworks/aix/library/au-aix-symbol-visibility/index.html" target="_blank" rel="noopener">Introduction to symbol visibility</a></li><li><a href="http://www.man7.org/linux/man-pages/man1/ld.1.html" target="_blank" rel="noopener">man ld</a></li><li><a href="http://www.it1352.com/539295.html" target="_blank" rel="noopener">将两个GCC编译的.o目标文件合并到第三个.o文件中</a></li><li><a href="https://stackoverflow.com/questions/1506346/with-gcc-how-do-i-export-only-certain-functions-in-a-static-library" target="_blank" rel="noopener">export obly centain functioins in a static lib</a></li><li><a href="https://gcc.gnu.org/wiki/Visibility" target="_blank" rel="noopener">visibility of GCC</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍了一种在软件集成过程中，遇到重名文件 和/或 重名函数时的解决方案。&lt;/p&gt;
    
    </summary>
    
      <category term="software" scheme="https://www.wuchenxu.com/categories/software/"/>
    
      <category term="build" scheme="https://www.wuchenxu.com/categories/software/build/"/>
    
    
      <category term="software" scheme="https://www.wuchenxu.com/tags/software/"/>
    
      <category term="build" scheme="https://www.wuchenxu.com/tags/build/"/>
    
      <category term="c-lang" scheme="https://www.wuchenxu.com/tags/c-lang/"/>
    
  </entry>
  
  <entry>
    <title>Machine Learning笔记</title>
    <link href="https://www.wuchenxu.com/2018/02/04/machine_learning_notes/"/>
    <id>https://www.wuchenxu.com/2018/02/04/machine_learning_notes/</id>
    <published>2018-02-04T12:38:54.000Z</published>
    <updated>2018-02-25T14:56:46.597Z</updated>
    
    <content type="html"><![CDATA[<p>学习吴恩达的machine learning课程笔记。</p><a id="more"></a><h1 id="resources"><a href="#resources" class="headerlink" title="resources"></a>resources</h1><h2 id="website"><a href="#website" class="headerlink" title="website"></a>website</h2><p><a href="http://cs229.stanford.edu/" target="_blank" rel="noopener">http://cs229.stanford.edu/</a><br><a href="https://see.stanford.edu/Course/CS229" target="_blank" rel="noopener">https://see.stanford.edu/Course/CS229</a></p><h2 id="tool"><a href="#tool" class="headerlink" title="tool"></a>tool</h2><p>商业软件<a href="https://www.mathworks.com/" target="_blank" rel="noopener">Matlab</a> or 免费开源软件<a href="http://www.gnu.org/software/octave/" target="_blank" rel="noopener">Octave</a></p><h1 id="动机与应用"><a href="#动机与应用" class="headerlink" title="动机与应用"></a>动机与应用</h1><h2 id="why？"><a href="#why？" class="headerlink" title="why？"></a>why？</h2><p>很多程序是无法手动编写出来的，eg. 手写文字识别，自动飞行器，自然语言处理NLP</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul><li>learning algorithm容易实现手动无法编写程序的问题。</li><li>learning algorithm在数据挖掘（data mining）有很好的效果，eg.电子化病例数据，帮助医生更好地决策</li><li>zip code识别</li><li>amazon，netflix推荐系统</li></ul><h2 id="machine-learning-definiton"><a href="#machine-learning-definiton" class="headerlink" title="machine learning definiton"></a>machine learning definiton</h2><ol><li><p>Arthur Samuel (1959). Machine Learning: Field of study that gives computers the ability to learn without being explicitly programmed.<br><code>Checkers program</code></p></li><li><p>Tom Mitchell (1998). Well-posed Learning Problem: A computer program is said to learn from experience E with respect to some task T and some performance measure P, if its performance on T, as measured by P, improves with experience E.</p></li></ol><h2 id="课程由4部分组成"><a href="#课程由4部分组成" class="headerlink" title="课程由4部分组成"></a>课程由4部分组成</h2><h3 id="Supervised-Learning-监督学习"><a href="#Supervised-Learning-监督学习" class="headerlink" title="Supervised Learning(监督学习)"></a>Supervised Learning(监督学习)</h3><p>监督学习中所有的样本都是带有标记的，“正确答案”已经在样本中。</p><ol><li><p>regression problem（回归问题）<br>预测的值是连续（continuous）的。</p><img src="/2018/02/04/machine_learning_notes/regression_problem_continuous.png" title="regression problem"></li><li><p>classification problem（分类问题）<br>预测的值是离散（discreet）的,eg. SVM(supported vector machine)</p><img src="/2018/02/04/machine_learning_notes/classification_problem_discreet.png" title="classification problem"></li></ol><h3 id="Learning-Theory"><a href="#Learning-Theory" class="headerlink" title="Learning Theory"></a>Learning Theory</h3><p>learning algorith 为什么是有效的；可以证明什么时候（eg.多大的数据量）可以保证算法有效（eg.&gt;99.9%的正确率)。</p><h3 id="Unspervised-Learning（无监督学习）"><a href="#Unspervised-Learning（无监督学习）" class="headerlink" title="Unspervised Learning（无监督学习）"></a>Unspervised Learning（无监督学习）</h3><p>无监督学习的样本是不带有标记的，无监督学习需要从数据中自己发现特定的结构。</p><ul><li><p><a href="https://en.wikipedia.org/wiki/Cluster_analysis" target="_blank" rel="noopener">Cluster Analysis Algorithm</a><br>给定一个训练数据集，从中找到某种结构，即将数据集分为几个聚类。（让算法自己从数据中发现规律）</p></li><li><p><a href="https://en.wikipedia.org/wiki/Independent_component_analysis" target="_blank" rel="noopener">ICA(Independent Component Analysis) Algorithm</a><br>Cocktail party problem<br>在嘈杂的鸡尾酒会区分不同人的语音</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[W,s,v] = svd((<span class="built_in">repmat</span>(sum(x.*x,<span class="number">1</span>),<span class="built_in">size</span>(x,<span class="number">1</span>),<span class="number">1</span>).*x)*x');</span><br></pre></td></tr></table></figure></li></ul><h3 id="Reinforcement-Learning（增强学习）"><a href="#Reinforcement-Learning（增强学习）" class="headerlink" title="Reinforcement Learning（增强学习）"></a>Reinforcement Learning（增强学习）</h3><p>reward function（回报函数）</p><h1 id="Supervised-Learning"><a href="#Supervised-Learning" class="headerlink" title="Supervised Learning"></a>Supervised Learning</h1><h2 id="Linear-regression"><a href="#Linear-regression" class="headerlink" title="Linear regression"></a>Linear regression</h2><img src="/2018/02/04/machine_learning_notes/supervised_learning_notation_1.png"><img src="/2018/02/04/machine_learning_notes/supervised_learning_notation_2.png"><img src="/2018/02/04/machine_learning_notes/supervised_learning_notation_3.png"><h3 id="Gradient-descent"><a href="#Gradient-descent" class="headerlink" title="Gradient descent"></a><a href="https://en.wikipedia.org/wiki/Gradient_descent" target="_blank" rel="noopener">Gradient descent</a></h3><img src="/2018/02/04/machine_learning_notes/gradient_descent.png"><p>随机选择一个点（特征参数），通过梯度算法找到下降最陡的方向，一步一步迭代，直到找到一个局部最优解（cost函数取最小值）。<br>如果初始化的值不一样，得到的局部最优解可能会不一样。<br>适用于：局部最优解等于全局最优解的情况，想象一个碗形的代价函数。</p><h4 id="Batch-gradient-descent"><a href="#Batch-gradient-descent" class="headerlink" title="Batch gradient descent"></a>Batch gradient descent</h4><p>每次迭代都要遍历所有的训练数据，适用于数据量小的训练集合。</p><img src="/2018/02/04/machine_learning_notes/batch_gradient_descent.png"><p>这种迭代规则，称为LMS(Least Mean Squares) update rule.</p><h4 id="Stochastic-gradient-descent-Incremental-gradient-descent"><a href="#Stochastic-gradient-descent-Incremental-gradient-descent" class="headerlink" title="Stochastic gradient descent(Incremental gradient descent)"></a>Stochastic gradient descent(Incremental gradient descent)</h4><p>只需要遍历一次训练数据，适用于数据量很大的训练集合。</p><img src="/2018/02/04/machine_learning_notes/stochastic_gradient_descent.png"><p>$ \alpha $表示学习速率，训练的步进，可以随着梯度的下降，减小该值。</p><h3 id="Normal-equations"><a href="#Normal-equations" class="headerlink" title="Normal equations"></a>Normal equations</h3><p>通过矩阵（matrix）的方法推导出的一种不需要迭代，直接可以计算出特征向量的方法。</p><img src="/2018/02/04/machine_learning_notes/normal_equation.png"><p>$(X^TX)$不可逆的可能原因：</p><ul><li>存在冗余特征（$\theta $中存在重复）</li><li>特征数量n过多，训练样本数m太少</li></ul><h3 id="Non-parameterical-learning-algorithm"><a href="#Non-parameterical-learning-algorithm" class="headerlink" title="Non-parameterical learning algorithm"></a>Non-parameterical learning algorithm</h3><ul><li><p>parameterical learning algorithm 的参数数量n是固定的，训练完成后不需要样本。<br>特征参数过少，导致欠拟合（underfitting）；特征数过多，导致过拟合（overfitting）。<br>可以通过Feature slection algorithm来自动选取特征参数。</p></li><li><p>Non-parameterical learning algorithm 的参数数量n是随着样本数m的增加而增加的，每次输出结果都需要重新评估训练样本。<br>LWR(Locally weighted linear regressioin)是一种无参数的算法</p><img src="/2018/02/04/machine_learning_notes/LWR_1.png"><img src="/2018/02/04/machine_learning_notes/LWR_2.png"></li></ul><h3 id="Probabilistic-interpretatioin"><a href="#Probabilistic-interpretatioin" class="headerlink" title="Probabilistic interpretatioin"></a>Probabilistic interpretatioin</h3><p>最小二乘法的概率学解释：假设误差服从正态分布（高斯分布），最小二乘法求得的特征参数，可以使代价函数最小。</p><h2 id="Classification-and-logistic-regression"><a href="#Classification-and-logistic-regression" class="headerlink" title="Classification and logistic regression"></a>Classification and logistic regression</h2><p>除了y的取值是离散的之外，分类问题与线性回归问题类似。</p><h3 id="Logistic-regression"><a href="#Logistic-regression" class="headerlink" title="Logistic regression"></a>Logistic regression</h3><h4 id="sigmoid-function"><a href="#sigmoid-function" class="headerlink" title="sigmoid function"></a>sigmoid function</h4><img src="/2018/02/04/machine_learning_notes/logistic_regression_1.png"><img src="/2018/02/04/machine_learning_notes/logistic_regression_2.png"><img src="/2018/02/04/machine_learning_notes/logistic_regression_3.png"><h4 id="Newton’s-method"><a href="#Newton’s-method" class="headerlink" title="Newton’s method"></a>Newton’s method</h4><img src="/2018/02/04/machine_learning_notes/Newtons_method_1.png"><img src="/2018/02/04/machine_learning_notes/Newtons_method_2.png"><h3 id="Perceptron-learning-algorithm"><a href="#Perceptron-learning-algorithm" class="headerlink" title="Perceptron learning algorithm"></a>Perceptron learning algorithm</h3><img src="/2018/02/04/machine_learning_notes/perceptron_learning_algorithm.png"><h2 id="GLM-Generalized-Linear-Models"><a href="#GLM-Generalized-Linear-Models" class="headerlink" title="GLM(Generalized Linear Models)"></a>GLM(Generalized Linear Models)</h2><h3 id="Exponential-family"><a href="#Exponential-family" class="headerlink" title="Exponential family"></a>Exponential family</h3><p>之前的例子中，线性回归算法（最小二乘法）服从高斯分布，逻辑回归算法（sigmoid函数）服从伯努利分布。而这些都是GLM的一些特例。</p><img src="/2018/02/04/machine_learning_notes/exponential_family.png"><p>以下分布都属于指数家族：<br>高斯分布（Gaussian）：结果是连续的<br>伯努利分布（Bernoulli）：结果是离散的，只有两种结果<br>多项式分布（multinomial）：结果是离散的，有k种结果<br>泊松分布（Poisson）：计数问题，eg.网站访客量，放射性衰变数目。<br>伽马分布（gamma）：时间间隔，eg.等公交车的时间<br>指数分布<br>beta分布<br>Dirichlet分布</p><h3 id="Constructing-GLMs"><a href="#Constructing-GLMs" class="headerlink" title="Constructing GLMs"></a>Constructing GLMs</h3><p>一个重要的设计决策是：</p><img src="/2018/02/04/machine_learning_notes/GLM_design_decision.png"><h4 id="Ordinary-Least-Squares"><a href="#Ordinary-Least-Squares" class="headerlink" title="Ordinary Least Squares"></a>Ordinary Least Squares</h4><p>高斯分布在指数家族的表示如下：</p><img src="/2018/02/04/machine_learning_notes/Gaussian_in_exponential_family.png"><p>可以推导出，最小二乘法是GLM的一个特例：</p><img src="/2018/02/04/machine_learning_notes/ordianary_least_squares_in_GLM.png"><h4 id="Logistic-regression-1"><a href="#Logistic-regression-1" class="headerlink" title="Logistic regression"></a>Logistic regression</h4><p>伯努利分布在指数家族表示如下：</p><img src="/2018/02/04/machine_learning_notes/Bernoulli_in_exponential_family.png"><p>可以推导出，逻辑回归是GLM的一个特例：</p><img src="/2018/02/04/machine_learning_notes/logistic_regression_in_GLM.png"><h4 id="Softmax-regression"><a href="#Softmax-regression" class="headerlink" title="Softmax regression"></a>Softmax regression</h4><p>多项式分布在指数家族表示如下：</p><img src="/2018/02/04/machine_learning_notes/multinomial_in_exponential_family.png"><p>softmax函数：</p><img src="/2018/02/04/machine_learning_notes/softmax_functin.png"><p>可以推导出，softmax回归是GLM的一个特例：</p><img src="/2018/02/04/machine_learning_notes/softmax_regression_in_GLM.png"><p>logistic回归是softmax回归在k=2时的特例。</p><h2 id="Generative-learning-algorithms"><a href="#Generative-learning-algorithms" class="headerlink" title="Generative learning algorithms"></a>Generative learning algorithms</h2><ul><li>判别（discriminative）学习算法<br>如逻辑回归，直接学习p(y|x)；或者如感知器算法（perceptron），直接尝试学习从输入到输出的映射（mapping）。</li><li>生成（generative）学习算法<br>对每种类别分别建模,然后通过贝叶斯公式计算出在给定x条件下y的后验分布。<img src="/2018/02/04/machine_learning_notes/generative_learning_algorithm_1.png"><img src="/2018/02/04/machine_learning_notes/generative_learning_algorithm_2.png"></li></ul><h3 id="GDA（Gaussian-Discriminant-Analysis）"><a href="#GDA（Gaussian-Discriminant-Analysis）" class="headerlink" title="GDA（Gaussian Discriminant Analysis）"></a>GDA（Gaussian Discriminant Analysis）</h3><p>GDA假设p(x|y)服从多元正态分布（multivariate normal distribution）。</p><h4 id="多元正态分布"><a href="#多元正态分布" class="headerlink" title="多元正态分布"></a>多元正态分布</h4><img src="/2018/02/04/machine_learning_notes/multivariant_normal_distribution_1.png"><img src="/2018/02/04/machine_learning_notes/multivariant_normal_distribution_2.png"><h4 id="高斯判定分析模型"><a href="#高斯判定分析模型" class="headerlink" title="高斯判定分析模型"></a>高斯判定分析模型</h4><img src="/2018/02/04/machine_learning_notes/GDA_1.png"><p>通过计算最大化的似然函数，可以得到参数$\phi \mu_0 \mu_1 \Sigma$的值。</p><img src="/2018/02/04/machine_learning_notes/GDA_2.png"><h4 id="GDA与逻辑回归"><a href="#GDA与逻辑回归" class="headerlink" title="GDA与逻辑回归"></a>GDA与逻辑回归</h4><p>如果我们将$p(y=1|x;\phi, \mu_0, \mu_1, \Sigma)$视为$x$的函数，那么我们发现可以有如下表示形式：<br>$$ p(y=1|x;\phi, \mu_0, \mu_1, \Sigma)={1 \over {1+exp(-\theta^T x)}}$$<br>这就是逻辑回归—一种判定算法—用来给$p(y=1|x)$建模的形式。</p><p>也就是说，如果数据服从多元高斯分布，那后验分布是逻辑函数；反之，不成立。</p><p>如果$x|y=0 ~ Poisson(\lamda_0), x|y=1 ~Poisson(\lamda_1$,那么$p(y|x)$也是逻辑的（logistic）。<br>也就是说，如果数据服从泊松分布，那后验分布也是逻辑函数；反之，不成立。</p><p>逻辑回归对多元高斯分布，泊松分布等都有效。</p><p>相比逻辑回归，GDA使用了更强的（stronger）假设。<br>如果模型假设正确（服从多元高斯分布），那么GDA可以更好地fit数据，可以通过更少的数据达到更好的效果，这种情况下GDA是更好的模型；<br>与之相对，逻辑回归使用了更弱（weaker）的假设，所以逻辑回归更健壮（robust），且对不正确的模型假设更不敏感。<br>如果数据不符合高斯分布，使用GDA得不到更好的估算，此时使用逻辑回归更好。</p><h3 id="朴素贝叶斯算法（Naive-Bayes）"><a href="#朴素贝叶斯算法（Naive-Bayes）" class="headerlink" title="朴素贝叶斯算法（Naive Bayes）"></a>朴素贝叶斯算法（Naive Bayes）</h3><h4 id="Naive-Bayes"><a href="#Naive-Bayes" class="headerlink" title="Naive Bayes"></a>Naive Bayes</h4><ul><li>GDA的特征向量是连续的实数向量。</li><li>Naive Bayes的特征向量是离散的值。<br>以垃圾邮件分类器（email span filter）为例,这个模型也称为多元伯努利事件模型（multi-variate Bernoulli event model）：</li></ul><img src="/2018/02/04/machine_learning_notes/NB_feature_vector_1.png"><img src="/2018/02/04/machine_learning_notes/NB_feature_vector_2.png"><p>朴素贝叶斯算法假设：</p><img src="/2018/02/04/machine_learning_notes/NB_assumption.png"><p>朴素贝叶斯算法的参数：</p><img src="/2018/02/04/machine_learning_notes/NB_1.png"><img src="/2018/02/04/machine_learning_notes/NB_2.png"><img src="/2018/02/04/machine_learning_notes/NB_3.png"><img src="/2018/02/04/machine_learning_notes/NB_4.png"><h4 id="Laplace-smoothing"><a href="#Laplace-smoothing" class="headerlink" title="Laplace smoothing"></a>Laplace smoothing</h4><p>设想如下场景：<br>一个从来没有在训练邮件中出现过的单词，但是这个单词在字典里，如果有一天收到一封邮件里包含这类单词。<br>会导致$\phi_{i|y=1}=0$,且$\phi_{i|y=0}=0$<br>从而<br>$$ p(y=1|x) = {0 \over 0}$$<br>这是一个未定义的值，无法作出估计。</p><img src="/2018/02/04/machine_learning_notes/Laplace_smoothing.png"><p>计算明天太阳升起来的概率(假设太阳已经连续n天升起来了)<br>明天太阳不会升起来的概率：<br>$$ \phi_0 = {1 \over n+2}$$<br>明天太阳还会升起来的概率：<br>$$ \phi_1 = {n+1 \over n+2}$$</p><h4 id="Event-models-for-text-classification"><a href="#Event-models-for-text-classification" class="headerlink" title="Event models for text classification"></a>Event models for text classification</h4><img src="/2018/02/04/machine_learning_notes/multinomial_event_model_1.png"><img src="/2018/02/04/machine_learning_notes/multinomial_event_model_2.png"><img src="/2018/02/04/machine_learning_notes/multinomial_event_model_3.png"><img src="/2018/02/04/machine_learning_notes/multinomial_event_model_4.png"><p>References:</p><ol><li><a href="http://blog.csdn.net/artprog/article/details/51172025" target="_blank" rel="noopener">机器学习笔记03：Normal equation与梯度下降的比较</a></li><li><a href="http://blog.csdn.net/google19890102/article/details/49738427" target="_blank" rel="noopener">深度学习算法原理——Softmax Regression</a></li><li><a href="https://www.cnblogs.com/realkate1/p/5683939.html" target="_blank" rel="noopener">生成模型（Generative）和判别模型（Discriminative)</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习吴恩达的machine learning课程笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="AI" scheme="https://www.wuchenxu.com/categories/AI/"/>
    
    
      <category term="AI" scheme="https://www.wuchenxu.com/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>ABZ计划</title>
    <link href="https://www.wuchenxu.com/2017/12/31/ABZ-Plan/"/>
    <id>https://www.wuchenxu.com/2017/12/31/ABZ-Plan/</id>
    <published>2017-12-31T12:38:54.000Z</published>
    <updated>2017-12-31T15:45:43.893Z</updated>
    
    <content type="html"><![CDATA[<img src="/2017/12/31/ABZ-Plan/ABZ_plan.png">  <p>今天是2017年最后一天了，可以按照<code>ABZ理论</code>好好计划一下2018年的计划了。</p><a id="more"></a><p>《至关重要的关系》(The Start-up of You)一书中提出的“ABZ计划”理论。<br>现在的世界变化太快（VUCA时代），我们需要一个人生规划：能让我们最大限度做好当前工作（A计划）；同时，在适当的时候可以转移到的下一份工作（B计划）；最差的情况，有个兜底的退路（Z计划）。</p><h1 id="A计划：当前的位置"><a href="#A计划：当前的位置" class="headerlink" title="A计划：当前的位置"></a>A计划：当前的位置</h1><p>A计划是当前正在从事的工作，是当前具有竞争优势的位置，并且值得持续投入。在A计划中，我们只需要对所学的知识技能做微调，并周期性地迭代。</p><h1 id="B计划：支点（Pivot-Point）"><a href="#B计划：支点（Pivot-Point）" class="headerlink" title="B计划：支点（Pivot Point）"></a>B计划：支点（Pivot Point）</h1><p>你的支点是你围绕的中心，就像篮球运动员只要以一只脚为支撑点，可以在一个圆圈里自由移动。<br>B计划是当你需要改变目标或者改变达到目标的路径的时候，可以转换过去的支点。你可能因为A计划行不通或者发现了比A计划更好的机会，从而准想B计划。一旦你转向B计划，它就变成了新的A计划。<br>为什么需要B计划，因为这个时代变化太快，你不知道什么时候你的公司或者你所在的行业就会迎来拐点（inflection point）。这样根本性的变化会强迫你改变自己的技能或者换一个新的环境。因为拐点的不可预测性，为了减轻拐点到来时的冲击，我们可以未雨绸缪：建立个人的软技能，拥抱变化，随时准备快速切换的B计划。<br>最好的B计划通常与你当前所做的工作有所不同，但是又有很大的相关性。转换到相近的领域，既可以借力已有的技能，又可以在一个新的方向开发出新的技能。通常，需要利用晚上或者周末的时间。你可以在空余时间开始学习新的技能，并与相邻领域工作的人建立联系。</p><h1 id="Z计划：安全网"><a href="#Z计划：安全网" class="headerlink" title="Z计划：安全网"></a>Z计划：安全网</h1><p>Z计划是你的安全撤退点（fallback point），你的救生船，它能让你承受失败的结果，并卷土重来。<br>如果你的职业生涯终结或者你的生活遭受重大变故，你的计划是什么？这就是Z计划。有了Z计划，你就可以在A计划和B计划里接受不确定性和风险。有了Z计划，你至少知道可以承受风险。没有Z计划，你可能在担心最坏情况的恐惧中束手束脚。<br>也许你会在恢复之前过一段简朴的生活，但是至少你知道不会无家可归，不会破产或者永远失业。<br>Z计划不是一个终点，它更像一张安全网，让你知道最差不过如此，这样你可以更加放心大胆地执行AB计划，甚至重新制定更加激进而不是更加保守的AB计划。</p><p>Reference：</p><ol><li><a href="http://mindmappingsoftwareblog.com/wp-content/bs-e197d/ABZ-Career-Plan-Map.pdf" target="_blank" rel="noopener">How to create an ABZ career plan mind map</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2017/12/31/ABZ-Plan/ABZ_plan.png&quot;&gt;  

&lt;p&gt;今天是2017年最后一天了，可以按照&lt;code&gt;ABZ理论&lt;/code&gt;好好计划一下2018年的计划了。&lt;/p&gt;
    
    </summary>
    
      <category term="management" scheme="https://www.wuchenxu.com/categories/management/"/>
    
    
      <category term="management" scheme="https://www.wuchenxu.com/tags/management/"/>
    
  </entry>
  
  <entry>
    <title>技术炒作周期(Hype Cycle)</title>
    <link href="https://www.wuchenxu.com/2017/09/21/hype-cycle/"/>
    <id>https://www.wuchenxu.com/2017/09/21/hype-cycle/</id>
    <published>2017-09-21T12:38:54.000Z</published>
    <updated>2019-11-23T10:23:57.537Z</updated>
    
    <content type="html"><![CDATA[<p>Hype cycle直译过来是<code>炒作周期</code>的意思，是美国咨询公司Gartner从1995年开始每年发布的一个关于技术成熟度报告，从时间维度将技术的成熟度分成5个周期：<br><code>Innovation Trigger（萌芽期）</code> <code>Peak of Inflated Expectations（过热期）</code> <code>Trough of Disillusionment（低谷期）</code> <code>Slope of Enlightenment（复苏期）</code> <code>Plateau of Productivity（成熟期）</code>。</p><a id="more"></a><p>阿马拉法则（Amara’s law）：人们常常高估技术的短期影响力，而低估技术的长期影响力。<br>Hype cycle可以看作是阿马拉法则的一种图像化描述。<br>Hype cycle可以看到不同技术随着时间的起起伏伏，也可以看到一项技术从萌芽到成熟的经过。</p><p>2019年Garnter整理的5个趋势</p><img src="/2017/09/21/hype-cycle/Trends_in_the_Emerging_Tech_Hype_Cycle_2019.png"> <p>2018年Garnter整理的5个趋势</p><img src="/2017/09/21/hype-cycle/Trends_in_the_Emerging_Tech_Hype_Cycle_2018.png"> <p>历年的Garnter Hype Cycle图：</p><img src="/2017/09/21/hype-cycle/Emerging-Technology-Hype-Cycle-for-2019.png"><img src="/2017/09/21/hype-cycle/Emerging-Technology-Hype-Cycle-for-2018.png"> <img src="/2017/09/21/hype-cycle/Emerging-Technology-Hype-Cycle-for-2017.jpg">  <img src="/2017/09/21/hype-cycle/Emerging-Technology-Hype-Cycle-for-2016.jpg">  <img src="/2017/09/21/hype-cycle/Emerging-Technology-Hype-Cycle-for-2015.png"><img src="/2017/09/21/hype-cycle/Emerging-Technology-Hype-Cycle-for-2014.jpg"><img src="/2017/09/21/hype-cycle/Emerging-Technology-Hype-Cycle-for-2013.png"><img src="/2017/09/21/hype-cycle/Emerging-Technology-Hype-Cycle-for-2012.png"><img src="/2017/09/21/hype-cycle/Emerging-Technology-Hype-Cycle-for-2011.gif"><img src="/2017/09/21/hype-cycle/Emerging-Technology-Hype-Cycle-for-2010.png"><img src="/2017/09/21/hype-cycle/Emerging-Technology-Hype-Cycle-for-2009.jpeg"><p>References:</p><ol><li><a href="http://www.gartner.com/technology/research/methodologies/hype-cycle.jsp" target="_blank" rel="noopener">Gartner hype clcle</a></li><li><a href="https://en.wikipedia.org/wiki/Hype_cycle" target="_blank" rel="noopener">wiki hype cycle</a></li><li><a href="https://spotlessdata.com/amaras-law" target="_blank" rel="noopener">AMARA’S LAW</a></li><li><a href="https://www.gartner.com/smarterwithgartner/5-trends-emerge-in-gartner-hype-cycle-for-emerging-technologies-2018/" target="_blank" rel="noopener">Hype Cycle for Emerging Technologies, 2018</a></li><li><a href="https://www.gartner.com/smarterwithgartner/5-trends-appear-on-the-gartner-hype-cycle-for-emerging-technologies-2019/" target="_blank" rel="noopener">5 Trends Appear on the Gartner Hype Cycle for Emerging Technologies, 2019</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hype cycle直译过来是&lt;code&gt;炒作周期&lt;/code&gt;的意思，是美国咨询公司Gartner从1995年开始每年发布的一个关于技术成熟度报告，从时间维度将技术的成熟度分成5个周期：&lt;br&gt;&lt;code&gt;Innovation Trigger（萌芽期）&lt;/code&gt; &lt;code&gt;Peak of Inflated Expectations（过热期）&lt;/code&gt; &lt;code&gt;Trough of Disillusionment（低谷期）&lt;/code&gt; &lt;code&gt;Slope of Enlightenment（复苏期）&lt;/code&gt; &lt;code&gt;Plateau of Productivity（成熟期）&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="technical" scheme="https://www.wuchenxu.com/categories/technical/"/>
    
    
      <category term="technical" scheme="https://www.wuchenxu.com/tags/technical/"/>
    
  </entry>
  
  <entry>
    <title>程序在哪里执行？</title>
    <link href="https://www.wuchenxu.com/2017/05/30/where-program-execute-in/"/>
    <id>https://www.wuchenxu.com/2017/05/30/where-program-execute-in/</id>
    <published>2017-05-30T15:54:00.000Z</published>
    <updated>2017-07-16T12:05:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>先上结论：计算机程序可以在ROM或者RAM里执行。</p><a id="more"></a><p>摘自RL78芯片datasheet：</p><blockquote><p>The RL78/F13 and RL78/F14 incorporate the flash memory to which a program can be written, erased, and overwritten. The flash memory includes the “code flash memory”, in which programs can be executed, and the “data flash memory”, an area for storing data.</p></blockquote><p>计算机设备，包括单片机，PC，DSP，FPGA等不同类型的电子设备，可以从ROM中执行程序（试想系统刚上电，也只有ROM中可以读取指令）。初始化完成后，为了提高执行速度可以将ROM中存储的程序到RAM中，再从RAM中执行。</p><p>由于RAM执行速度（～GHz）相较于NorFlash的XIP执行速度（～100MHz）快很多，所以如果RAM空间足够的情况下，从RAM执行程序速度更快。<br>但是由于成本原因，NorFlash在单片机（code flash一般从几K到几M大小）中作为存储程序的主存储器也是很常见的。</p><p>NorFlash支持XIP（<a href="https://en.wikipedia.org/wiki/Execute_in_place" target="_blank" rel="noopener">eXecute In Place</a>），CPU直接从NorFlash取指令、译码、执行。<br>NorFlash更像RAM，使用标准的存储接口，具有独立的地址总线和数据总线，支持随机访问，地址总线与数据总线共用；而NandFlash更像一个硬盘，需要特殊的驱动来访问，地址总线和数据总线是与I/O总线共享，只允许按页访问，。<br>NorFlash直接执行的设备，还是需要RAM的，因为NorFlash中只能存储不可变的指令或数据，运行过程中可变的数据还是需要存储在RAM中。<br>NorFlash的特点(线性存储空间，100%无坏点，随机访问)决定了支持XIP。<br>NorFlash的XIP最快执行速度～100MHz。<br>NorFlash的读取速度（～100ns）比NandFlash（us）快，NandFlash的擦除和写入速度比NorFlash快很多。</p><p>NandFlash只能保证98%无坏块（bad block），需要坏块处理；会有位翻转（bit-flipping）问题，需要EDC（Error Detection Code）/ECC（Error Correction Code）来检错纠错。</p><img src="/2017/05/30/where-program-execute-in/comparison_NOR_NAND.png"><ul><li>SRAM(Static Random Access Memory) - cache/register - faster but more expensive</li><li>DRAM(Dynamic Random Access Memory) - Main Memory - slower but cheaper<br>动态随机存取存储器，最为常见的系统内存。DRAM 只能将数据保持很短的时间。为了保持数据，DRAM使用电容存储，所以必须隔一段时间刷新（refresh）一次，如果存储单元没有被刷新，存储的信息就会丢失。 （关机就会丢失数据）<ul><li>SDRAM(Synchronous Dynamic Random Access Memory):<br>同步动态随机存储器，同步是指内存工作需要同步时钟，内部的命令的发送与数据的传输都以它为基准.</li><li>DDR(Dual Data Rate) SDRAM:双倍速率同步动态随机存储器</li></ul></li><li>Flash <ul><li>NorFlash</li><li>NandFlash <ul><li>SD（Secure Digital）卡</li><li>eMMC（embedded multi-media card）</li><li>SSD（Solid State Disk）</li><li>UFS（Universal Flash Storage）</li></ul></li></ul></li></ul><p>References：</p><ol><li><a href="https://en.wikipedia.org/wiki/Flash_memory" target="_blank" rel="noopener">Flash Memory</a></li><li><a href="https://en.wikipedia.org/wiki/Execute_in_place" target="_blank" rel="noopener">Execute In Place</a></li><li><a href="http://www.blog.chinaunix.net/uid-26404697-id-3152290.html" target="_blank" rel="noopener">norflash芯片内执行（XIP） </a></li><li><a href="http://aturing.umcs.maine.edu/~meadow/courses/cos335/Toshiba%20NAND_vs_NOR_Flash_Memory_Technology_Overviewt.pdf" target="_blank" rel="noopener">Toshiba NAND vs. NOR Flash Memory Technology Overview</a></li><li><a href="https://focus.ti.com/pdfs/omap/diskonchipvsnor.pdf" target="_blank" rel="noopener">Two Flash Technologies Compared: NOR vs. NAND Two Flash Technologies Compared: NOR vs. NAND </a></li><li><a href="https://superuser.com/questions/163425/does-ram-access-slow-down-cpu" target="_blank" rel="noopener">Does RAM access slow-down CPU?</a></li><li><a href="https://electronics.stackexchange.com/questions/102764/flash-and-ram-code-execution" target="_blank" rel="noopener">flash-and-ram-code-execution</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先上结论：计算机程序可以在ROM或者RAM里执行。&lt;/p&gt;
    
    </summary>
    
      <category term="technical" scheme="https://www.wuchenxu.com/categories/technical/"/>
    
    
      <category term="software" scheme="https://www.wuchenxu.com/tags/software/"/>
    
      <category term="technical" scheme="https://www.wuchenxu.com/tags/technical/"/>
    
  </entry>
  
  <entry>
    <title>软件工程的事实与谬误 by Robert L·Glass</title>
    <link href="https://www.wuchenxu.com/2017/05/12/reading-notes-3-Facts-and-fallacies-of-software-engineering/"/>
    <id>https://www.wuchenxu.com/2017/05/12/reading-notes-3-Facts-and-fallacies-of-software-engineering/</id>
    <published>2017-05-12T15:54:00.000Z</published>
    <updated>2017-07-16T13:09:51.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/2017/05/12/reading-notes-3-Facts-and-fallacies-of-software-engineering/cover.jpg"><p>软件工程的55个事实和5+5个谬误。<br>划重点：</p><ul><li>软件过程和软件产品的<code>复杂性</code>决定了我们在该领域的许多认识和行为。复杂性不可避免，我们不应该与之对立，而应该学会适应它。</li><li>在软件领域，糟糕的<code>估算</code>和由此带来的<code>时间表压力</code>一直在迫害我们。</li><li>在软件管理者和技术人员之间有<code>隔阂</code>。</li><li><code>鼓吹</code>和<code>通用</code>的观念影响了我们形成专注于有力的、明智的项目方案的能力。</li></ul><a id="more"></a><h1 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h1><p>处于管理最底层且专长于干活的人通常比其他任何人有更大的威力。</p><h2 id="人员"><a href="#人员" class="headerlink" title="人员"></a>人员</h2><p>1.<code>在软件开发中，最重要的因素不是程序员采用的工具和技术，而是程序员自身的质量。</code></p><p>CMM假设良好的过程会得到良好的软件。</p><p>Q：假如你的生命依靠某一软件，那么，关于该软件你最想知道什么？ A：与其他事情相比，我最想知道写该软件的人，这人一定才华横溢，严谨认真，狂热追求软件完美并按照需求运作。其他对我来说都是次要的。</p><p>2.<code>对“个体差异”的研究表明，最好的程序员要比最差的程序员强28倍之多，即使他们的报酬不同，优秀程序员也是软件业中最廉价的劳动力。</code></p><p>3.<code>给延期的项目增加人手会使项目进一步延期。</code><br>    Brooks法则，出自《人月神话》</p><p>4.<code>工作环境对工作效率和产品质量具有深刻影响。</code><br>    你必须找到优秀的人员并善待他们，特别是给她们提供舒适的环境。</p><h2 id="工具和技术"><a href="#工具和技术" class="headerlink" title="工具和技术"></a>工具和技术</h2><p>5.<code>夸大宣传是软件的瘟疫，多数软件工具对于效率和质量的提高幅度仅为5%～35%，但总有人反复说提高幅度是“数量级”的。</code></p><p>6.<code>在学习新工具或者新技术的初期，程序员的工作效率和产品质量都会下降。只有克服了学习曲线之后，才可能得到实质性的收益。只有满足下面两个条件，采用新工具或者新技术才有意义：（a）新东西确实有用；（b）要想获得真正的收益，必须耐心等待。</code></p><p>7.<code>软件开发者对于工具说的多，评估的少，买的多，用的少。</code></p><h2 id="估算"><a href="#估算" class="headerlink" title="估算"></a>估算</h2><p>8.<code>项目失控的两个最主要的原因之一是糟糕的估算（另一个原因见事实23）。</code></p><p>估算是确定项目成本和开发时间表的过程。</p><p>依靠专家—无论专家曾经做过什么项目，无论这些项目与当前项目何等相似，专家都不可能做出合理的推断（软件项目的重要特征之一是各个项目所解决的问题差异很大。）</p><p>依靠估算算法（复杂算法，Line of Code，Function Point）—采用一个假想的项目，按照各种建议算法输入相关数据，得到的结果差异很大（2～8倍）。</p><p>9.<code>许多估算是在软件生命周期开始时完成的。后来，我们才认识到在需求定义之前，即理解问题之前进行项目估算是不正确的；也就是说，估算时机是错误的。</code></p><p>10.<code>许多软件项目都是由高层管理人员或者营销人员来估算，而不是由真正构建软件的人或者他们的主管来进行估算。因此，估算软件的人员是错误的。</code></p><p>高级人员和营销人员搞“政治”预测；软件人员做“理性”预测。</p><p>许多（70%）估算是由与“人事部门”相关的人员完成的，很少（4%）由项目团队进行估算。</p><p>11.<code>软件估算很少根据项目进度进行调整。因此，这些估算通常是错误的人在错误的时间得出的错误结果。</code></p><p>12.<code>因为估算的数据是如此糟糕，所以在软件项目不能达到估算目标时，不应该再考虑估算。但是无论如何，每个人都在考虑它。</code></p><p>极限编程建议客户或者用户先确定成本、时间表、功能和质量这四个因素中的前三个，软件开发者再确定第四个。</p><p>我要求参与者完成一个小任务。我有意增加他的工作量，使工作时间不足。我希望参与者尽力正确地完成整体工作，这样他们会因为时间不够而得出一个未完成的作品。事实并非如此，这些参与者按照不可能的时间表勉强完成了工作。他们的作品粗糙而虚假，看起来完整但根本不可用。这说明人们为了满足不可能的时间表，以至于愿意为此牺牲作品的完整性和质量。</p><p>13.<code>在管理者和程序员之间存在隔阂。对于一个未满足估算目标的项目的调查表明：从管理者看来这是一个失败的项目，而在技术人员看来却是最成功的项目。</code></p><p>根本就没有做过估计的项目进展速度最快，其次是技术人员做估计得项目，最糟糕的是由管理人员做估计。</p><p>在工作效率和驾驭感之间有非常强的关联性。也就是说，如果程序员感觉到能驾驭自己的结局，那么他们的工作效率会高很多。换句话说，高度控制的管理并不一定会得到最好的或者效率最高的项目。</p><p>14.<code>对于可行性调研的回答几乎总是“可行”。</code></p><h2 id="复用"><a href="#复用" class="headerlink" title="复用"></a>复用</h2><p>15.<code>小规模的复用（子程序库）开始于50多年以前，这个问题已经得到很好的解决。</code></p><p>16.<code>虽然每个人都认为大规模服用（组件）非常重要、非常急需，但是这个问题至今还没有基本解决。</code></p><p>作者认为此问题无解，根源在于软件的多样性。</p><p>17.<code>大规模复用最好适用于相关的系统，也就是依赖于具体应用领域，这样就限制了它的应用范围。</code></p><p>在一个更小的特定应用领域中采用大规模复用的方法，成功的概率就比较大。而在跨项目和跨应用领域中采用大规模复用方法的成功概率很小。（McBreen 2002）。</p><p>18.<code>有关复用问题，有两个“三倍法则”：（a）构建可复用的组件比使用组件难三倍；（b）在将组件收录到复用库并成为通用组件之前，应该在三个不同的应用中尝试使用该组件。</code></p><p>19.<code>修改复用的代码特别容易引起错误。如果一个组件中超过20%～25%的代码需要修改，那么重新实现的效率会更高。</code></p><p>20.<code>设计模式复用是解决代码复用中固有问题的一种方法。</code></p><p>设计模式是对反复出现的问题以及该问题的解决方案的一种描述。</p><p>设计模式源于实践，而不是源于理论。</p><h2 id="复杂性"><a href="#复杂性" class="headerlink" title="复杂性"></a>复杂性</h2><p>21.<strong><code>问题的复杂性每增加25%，解决方案的复杂性就增加100%。这不是一个可改变的条件（即使人们都努力降低复杂性），而是客观存在的。</code></strong></p><p>22.<code>80%的软件工作是智力活动。相当大的比例是创造性的活动。很少是文书性的工作。</code></p><h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p>生命周期（software life cycle）开始于<code>需求</code>的定义和开发，在这一阶段，定义和分析“什么”问题。接着是<code>设计</code>，在这一阶段确定如何解决问题。然后是<code>编码</code>，将设计转化为计算机上可运行的代码。随后，因为整个过程中极易出现错误，所以进行<code>错误消除</code>。最终，完成了全部测试之后，软件产品交付使用，便开始了<code>维护</code>.<br>不同的步骤形成了瀑布模型，螺旋模型等，这些模型只是将步骤的顺序调整，需求、设计、编码、错误消除和维护，这些步骤都需要完成。</p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>23.<code>导致项目失控的两个最常见原因之一是不稳定的需求（另一个见事实8所说的项目估算失误）。</code></p><p>24.<code>在产品完成时修订需求错误的代价最大，在开发早期修订需求错误的代价最小。</code></p><p>错误在软件的存留时间越长，修订的代价越大。</p><p>怎么做？</p><ul><li>计算机学者会坚持采用格式化的规格说明书技术；</li><li>开发者则将复审放在首位；</li><li>测试和质量人员要求有可测试的需求，并建立早期测试用例；</li><li>系统分析员可能会要求采用建模的方法；</li><li>极限编程者提倡在开发团队中吸纳一个客户代表。</li></ul><p>25.<code>遗漏需求是最难修订的需求错误。</code></p><p>最持久的软件错误是遗漏逻辑错误，它可以逃过软件测试过程，进入发布的产品中。遗漏需求会导致遗漏逻辑。</p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>26.<strong><code>从需求转入设计时，因为制定方案过程的复杂性，会激增出大量的衍生需求（针对一种特定设计方案的需求）。设计需求时原始需求的50倍之多。</code></strong></p><p>虽然大家都认为需求追溯很有必要，但是需求扩充在一定程度上影响了需求追溯。需求追溯是指在产品的各个阶段的制品中追溯原始需求。</p><p>27.<code>对于一个软件问题，通常不存在唯一的最佳设计方案。</code></p><blockquote><p>在一个房间中坐满了顶级的软件设计人员，如果其中任意两个人达成一致，那就可以通过了。—Bill Curtis</p></blockquote><p>28.<code>设计是一个复杂的、迭代的过程。最初的设计方案可能是错误的，当然也不是最优的。</code></p><p>“从难点开始”。</p><p>设计方案可能是启发式的、试验性的。</p><p>复杂的设计过程通常不能得出最佳的结果，但是我们必须尽力寻找一个“令人满意的”方案。找到最佳设计方案不可能或者代价太高，而“令人满意的”方案（而不是最佳方案）可以满足优秀设计标准，是值得（冒险）选择的解决问题的方法。</p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>29.<code>从设计转到编码阶段时，设计者按照自己掌握的水平，已经将问题分解为“原语”。如果编程者和设计者不是同一个人，二者的“原语”不吻合，就会出问题。</code></p><p>如果设计者的原语层次比编码者高，编码者无法将此设计作为起点。因此，编码者在真正编码之前需要花费时间完成额外的设计，填补中间的层次。</p><p>不要轻易将设计工作和编码工作分开。</p><p>30.<code>COBOL是一种糟糕的语言，但是其他的（用于商业数据处理的）语言也同样糟糕。</code></p><p>31.<code>错误消除是软件生命周期中最耗时的阶段。</code></p><p>对于许多软件产品而言，错误消除所用的时间比汇集需求、进行设计或编码都长，通常长一倍。</p><p>“需求-分析-编码-错误消除”所占比例：20-20-20-40 或者 25-25-20-30。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>32.<code>普通程序员认为已经彻底测试过的软件其实只执行了55%～60%的逻辑路径。采用覆盖分析器等自动工具，可以将上述比例提高到85%～90，几乎不可能测试软件中100%的逻辑路径。</code></p><ul><li>需求驱动测试（测试是否满足了所有需求）</li><li>结构驱动测试（测试已构建的软件的所有组成部分是否正确运行）</li><li>统计驱动测试（随机测试确定软件执行的时间和结果）</li><li>风险驱动测试（测试确定是否已经消除了最主要的风险）</li></ul><p>由于软件产品固有的复杂性，任何测试都不会是彻底的测试。因此，（a）测试工作实际上是一种折衷的活动，关键是作出适当的折衷选择；（b）许多重要软件的发行版中存在错误，这不足为奇（追求无瑕疵软件的想法是天真的）。</p><p>33.<strong><code>即使测试覆盖有可能达到100%，这种测试也不够。大约35%的错误是源于逻辑路径的缺失，还有40%的错误源于执行特定的路径组合。不可能实现100%的覆盖。</code></strong></p><p>为了构建成功的、可靠的软件，需要综合采用多种错误消除方法，通常是越多越好。对于这个问题，没有神奇魔法。</p><p>34.<code>没有工具就无法做好错误消除工作。人们常用调试器，很少使用覆盖分析器等其他工具。</code></p><p>35.<code>自动测试很少，也就是说有些测试可以也应该自动化，但是有许多测试任务不能自动完成。</code></p><p>36.<code>程序员在程序中嵌入测试代码、目标代码中的编译参数等方法，都是测试工具的重要补充。</code></p><h2 id="评审和检查"><a href="#评审和检查" class="headerlink" title="评审和检查"></a>评审和检查</h2><p>37.<code>在运行第一个测试用例之前进行严格审查可以消除软件产品中多大90%的错误。</code></p><p>要找到同一个错误，审查的成本低于测试的成本。</p><p>在软件生命周期各个阶段的产品都可以审查。</p><p>决定检查成败的关键不是采用形式化的过程，而是团队成员在审查过程中的严格程度和注意力集中程度。</p><p>38.<code>虽然严格审查有很多优点，但是不能也不应该代替测试。</code></p><p>39.<code>通常认为，事后评审对于了解客户的满意程度和改进过程都很重要。但是很多软件公司不开展事后评审。</code></p><p>软件业的智慧一直没有增长。</p><p>我们在疯狂追求新东西时，往往抛弃了许多旧东西（例如极限编程和敏捷开发等最新的软件方法倾向于拒绝老方法中积累的智慧）。</p><p>软件业一直忙于加速工作，以致于没有时间考虑如何做得更好，而不只是更快。</p><p>40.<code>同行评审涉及技术和社会两方面问题，忽视任何一方面都会产生严重的灾难。</code></p><p>在评审过程中，参与者应该尽力熟知当前软件中的每一个决定和细节。</p><p>评审者必须从评审对象作者的角度来处理评审对象，而不是按照自己的方式，所以评审非常难。许多人穿上别人的鞋都寸步难行。</p><p>大多数人在软件产品中投入大量的情感和智力，因此如果被别人评头论足将会非常敏感。</p><p>禁止经理参加评审（他们倾向于评审开发者，而不是评审产品）；<br>禁止没有准备的人参加评审（他们会使有准备着失望，还会偏离主题）；<br>开发者不能作为评审主管（缩小可能涉及到开发者的自我因素）。</p><h2 id="维护"><a href="#维护" class="headerlink" title="维护"></a>维护</h2><p>41.<strong><code>维护开支通常占软件成本的40%～80%（平均为60%）。因此，维护可能是软件生命周期中最重要的阶段。</code></strong></p><p>软件维护就是在发现错误时进行修订，并在必要时做修改。</p><blockquote><p> 古老的硬件会被抛弃，古老的软件每天都在使用。</p></blockquote><p>42.<strong><code>增强功能大约占软件维护成本的60%，错误更正仅占17%。因此，软件维护的主体是在旧软件中加入新功能，而不是更正错误。</code></strong></p><p>60%: 改进，增强功能<br>18%: 适应性维护，即在改变工作环境时保证软件正常运行，如再另一台计算机上运行、在另一种操作系统上运行、与新的软件包交互、引入新设备等。<br>17%: 错误更正<br>5%:  为了使软件更容易维护所作出的维护工作（预防性维护Preventive Maintenance，重构refactoring）</p><p><strong>60/60规则：60%的软件成本用于软件维护，维护成本60%用于功能增强。因此，增强旧软件是个大问题。</strong></p><p>43.<code>维护是解决方案，而不是问题。</code></p><p>假设软件维护只是修正错误，那么软件维护才是个问题。</p><p>只有维护才能解决在软件中独有的一个问题，即“我们已经构建了一个东西，但是现在需要一个稍微不同的东西。”</p><p>44.<code>比较软件开发和软件维护中的工作，除了维护中“理解现有的产品”这项工作之外，其他工作都一样。这项工作占据了大约30%的维护时间，是主要的维护活动，因此可以说维护比开发更难。</code></p><p>45.<strong><code>更好的软件工程开发导致更多而不是更少的维护。</code></strong></p><p>与构建糟糕的系统相比，构建良好的系统更容易实现功能增强，这样人们对他们的修改更多，导致这些系统的维护时间更长。</p><p>如果我们把维护活动视为一种方案，那么维护越多越好。假如我们执意认为维护是一个问题，那么就无法将维护活动的增加视为一件好事。</p><h1 id="质量"><a href="#质量" class="headerlink" title="质量"></a>质量</h1><h2 id="质量-1"><a href="#质量-1" class="headerlink" title="质量"></a>质量</h2><p>46.<code>质量是一组属性的组合。</code></p><ol><li><strong>可移植性</strong>是指生成易于在不同平台之间移植的软件产品。</li><li><strong>可靠性</strong>是指软件产品满足预期的要求，值得信赖。</li><li><strong>效率</strong>是指软件产品在运行时间和空间消耗上的经济性。</li><li><strong>人类工程学</strong>(又称为可用性)是指软件产品用起来既容易又舒服。</li><li><strong>可测试性</strong>是指软件产品易于测试。</li><li><strong>易理解性</strong>是指维护者易于理解软件产品。</li><li><strong>可修改性</strong>是指维护者易于修改软件产品。</li></ol><p>47.<code>软件质量不是用户满意、满足需求、满足成本和时间表目标，或者可靠性。</code></p><blockquote><p>用户满意 = 满足需求 + 按时提交 + 适当的成本 + 产品质量</p></blockquote><h2 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h2><ol start="48"><li><code>绝大多数程序员都会犯某些错误。</code></li></ol><p>49.<code>错误通畅聚集在一起。</code></p><blockquote><p>半数的错误发现在15%的模块中。</p></blockquote><p>50.<code>没有唯一最好的消除软件错误的方法。</code></p><p>51.<code>总会有残存的错误。我们的目标应该是消除严重错误，或者使之最少。</code></p><p>一项2002年的研究：两个采用完全不同软件开发方法（一个团队使用传统方法，处于CMM4；另一个团队采用前卫的形式化方法）的团队都不能构建一个可靠性达到98%的简单产品。</p><p>关于残存错误：</p><ul><li>有经验的个人实践可以使错误的发生减少75%</li><li>大约40%～50%的用户程序包含着较显著的缺陷。</li><li>你不会发现所有的bug<br>关于残存的严重错误：</li><li>小于10%的错误导致90%故障的发生。</li></ul><h2 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h2><p>52.<code>效率主要来自于优秀的设计，而不是优秀的编码。</code></p><p>数据结构是增加逻辑复杂性和改善数据访问效率之间的折衷。因此在设计阶段应认真选择正确的数据结构、文件结构或者数据库访问方法。</p><p>在设计阶段对效率的细微考虑比漂亮的编码更有意义。</p><p>53.<code>高级语言（High-order language，HOL）代码配合适当的编译器优化，大约可以达到汇编语言90%的效率。对于一些复杂的现代体系结构，效率更高。</code></p><p>54.<code>在空间和时间之前存在折衷。通常，改进一方面会降低另一方面。</code></p><p>三角函数：函数值列表，空间换时间。<br>Java: 编译后的字节码比机器码紧凑，但是时间效率很低；JIT（Just-In-Time）编译器可以将字节码编译为机器码。</p><h1 id="研究"><a href="#研究" class="headerlink" title="研究"></a>研究</h1><p>55.<code>许多软件研究者不是做调查，而是鼓吹。因此，（a）有些概念比鼓吹的糟糕、更少；（b）缺少有助于确定这些概念真实价值的评估性研究。</code></p><h1 id="谬误"><a href="#谬误" class="headerlink" title="谬误"></a>谬误</h1><p>1.<code>你不能管理自己无法度量的东西。</code></p><p>优秀的知识管理者趋向于定性度量，而非定量度量。</p><p>实际情况是度量对于软件管理非常重要，谬误存在于具体进行度量的手段和过程中。</p><p>2.<code>可以管理软件产品的质量。</code></p><p>所有的质量属性都有很深刻的技术内容，只有技术人员才能处理这些技术内容。</p><p>3.<code>可以，也应该“忘我”地编程。</code></p><p>我们不可能为了满足别人的需求来抑制自己的需求，我们也同样不太可能为了团队的利益而抑制自我。一个有效运行的系统必须承认人的个性，也必须在这些个性的范围内运作。</p><p>4.<code>工具和技术是通用（one site fits all）的。</code></p><p>5.<code>软件需要更多的方法论。</code></p><p>6.<code>要估算成本和时间表，应首先估算代码行数。</code></p><p>7.<code>随机测试输入是优化测试的好方法。</code></p><p>8.<code>如果有了足够多的关注，所有的bug都显而易见。</code></p><ul><li>错误的深浅与查找错误的人数没有关系。</li><li>有关审查的研究表明：增加审查人数，发现错误数量的增加幅度会迅速减少。</li><li>没有数据表明这句话的正确性。</li></ul><p>9.<code>估计将来的维护成本和做出产品更新的决策需要参考过去的成本数据。</code></p><p>10.<code>教别人编程的方法是教别人写程序。</code></p><p>就像写作一样，要先读后写。</p><ul><li>要教授读代码，我们必须选择所读的范例。</li><li>要教授读代码，需要指导性的教科书，但是却没有。都是关于如何写代码的。</li><li>标准课程教授先写后读，形成了制度。</li><li>我们在软件中需要读代码的唯一时机是维护。维护很不受欢迎，理由之一是读代码是一项非常难的活动。发挥你的创造力写新代码比读别人的老代码有意思得多。</li></ul><blockquote><p>成为程序员最好的方法是写程序，研究别人所写的优秀的程序。。。我到计算机科学中心的垃圾桶里找到了他们操作系统的列表。 —Bill Gates</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2017/05/12/reading-notes-3-Facts-and-fallacies-of-software-engineering/cover.jpg&quot;&gt;

&lt;p&gt;软件工程的55个事实和5+5个谬误。&lt;br&gt;划重点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;软件过程和软件产品的&lt;code&gt;复杂性&lt;/code&gt;决定了我们在该领域的许多认识和行为。复杂性不可避免，我们不应该与之对立，而应该学会适应它。&lt;/li&gt;
&lt;li&gt;在软件领域，糟糕的&lt;code&gt;估算&lt;/code&gt;和由此带来的&lt;code&gt;时间表压力&lt;/code&gt;一直在迫害我们。&lt;/li&gt;
&lt;li&gt;在软件管理者和技术人员之间有&lt;code&gt;隔阂&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;鼓吹&lt;/code&gt;和&lt;code&gt;通用&lt;/code&gt;的观念影响了我们形成专注于有力的、明智的项目方案的能力。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="reading-notes" scheme="https://www.wuchenxu.com/categories/reading-notes/"/>
    
    
      <category term="technical" scheme="https://www.wuchenxu.com/tags/technical/"/>
    
      <category term="reading-notes" scheme="https://www.wuchenxu.com/tags/reading-notes/"/>
    
  </entry>
  
  <entry>
    <title>一线架构师实践指南 by 温昱</title>
    <link href="https://www.wuchenxu.com/2017/05/05/reading-notes-2-practice-guide-for-frontline-architects/"/>
    <id>https://www.wuchenxu.com/2017/05/05/reading-notes-2-practice-guide-for-frontline-architects/</id>
    <published>2017-05-05T15:54:00.000Z</published>
    <updated>2017-07-16T13:18:06.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/2017/05/05/reading-notes-2-practice-guide-for-frontline-architects/cover.png"><p>本书从架构师实际困惑出发，提出一套具有可操作性的方法体系来解决这些问题，作者很擅长用图例、表格来阐述观点，让人很受用。</p><a id="more"></a><p>思维导图：</p><img src="/2017/05/05/reading-notes-2-practice-guide-for-frontline-architects/一线架构师实践指南.png">]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2017/05/05/reading-notes-2-practice-guide-for-frontline-architects/cover.png&quot;&gt;
&lt;p&gt;本书从架构师实际困惑出发，提出一套具有可操作性的方法体系来解决这些问题，作者很擅长用图例、表格来阐述观点，让人很受用。&lt;/p&gt;
    
    </summary>
    
      <category term="reading-notes" scheme="https://www.wuchenxu.com/categories/reading-notes/"/>
    
    
      <category term="technical" scheme="https://www.wuchenxu.com/tags/technical/"/>
    
      <category term="reading-notes" scheme="https://www.wuchenxu.com/tags/reading-notes/"/>
    
  </entry>
  
  <entry>
    <title>Rust语言(4):格式化输出</title>
    <link href="https://www.wuchenxu.com/2017/03/19/Rust-lang-4-std-fmt/"/>
    <id>https://www.wuchenxu.com/2017/03/19/Rust-lang-4-std-fmt/</id>
    <published>2017-03-19T12:35:24.000Z</published>
    <updated>2017-07-16T13:17:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文对比Rust与Python语言的格式化输出。</p><a id="more"></a><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本文所用Rust版本为<code>1.14.0</code>，Python为<code>2.7.12</code>。<br>可以使用在线编译调试工具来测试本文所举示例代码。<br><a href="https://play.rust-lang.org/" target="_blank" rel="noopener">Rust playground</a><br><a href="http://ideone.com/" target="_blank" rel="noopener">Python playground</a></p><h1 id="basic-usage"><a href="#basic-usage" class="headerlink" title="basic usage"></a>basic usage</h1><p>Rust与Python都可以用<code>{}</code>来表示将要被替换变量的占位符。</p><h2 id="Rust"><a href="#Rust" class="headerlink" title="Rust"></a>Rust</h2><ul><li><code>print!</code>将格式化文本输出到控制台，不带换行符。</li><li><code>println!</code>将格式化文本输出到控制到，末尾加一个换行符。</li><li><code>format!</code>将格式化文本输出到字符串。</li></ul><figure class="highlight rust"><figcaption><span>Rust</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print!</span>(<span class="string">"&#123;&#125;.print is output to console w/o newline."</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">"Continue..."</span>);</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125;.println is string to console w/ newline."</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="built_in">str</span> = <span class="built_in">format!</span>(<span class="string">"&#123;&#125;.format is output to a string."</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(<span class="built_in">str</span>, <span class="string">"3.format is output to a string."</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, <span class="built_in">str</span>);</span><br></pre></td></tr></table></figure><h2 id="Python2-7"><a href="#Python2-7" class="headerlink" title="Python2.7"></a>Python2.7</h2><ul><li><code>print</code>来打印文本到控制台，末尾加一个换行符。</li><li><code>str.format()</code>将格式化文本输出到字符串。</li></ul><figure class="highlight python"><figcaption><span>Python2.7</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"&#123;&#125; world"</span>.format(<span class="string">"Hello"</span>))</span><br></pre></td></tr></table></figure><h1 id="with-arguments"><a href="#with-arguments" class="headerlink" title="with arguments"></a>with arguments</h1><ul><li>more arguments</li><li>positional arguments</li><li>named arguments</li></ul><figure class="highlight rust"><figcaption><span>Rust</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125;, &#123;&#125;"</span>, <span class="string">"Hello"</span>, <span class="string">"world"</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;0&#125;, this is &#123;1&#125;. &#123;1&#125;, this is &#123;0&#125;."</span>, <span class="string">"Hellen"</span>, <span class="string">"Tom"</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;subject&#125; &#123;verb&#125; &#123;object&#125;"</span>, object=<span class="string">"the lazy dog"</span>, subject=<span class="string">"the quick brwon fox"</span>, verb=<span class="string">"jumps over"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>Python2.7</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"&#123;&#125;,&#123;&#125;"</span>.format(<span class="string">"hello"</span>, <span class="string">"world"</span>))</span><br><span class="line">print(<span class="string">"&#123;0&#125;, this is &#123;1&#125;. &#123;1&#125;, this is &#123;0&#125;."</span>.format(<span class="string">"Hellen"</span>, <span class="string">"Tom"</span>))</span><br><span class="line">print(<span class="string">"&#123;subject&#125; &#123;verb&#125; &#123;object&#125;"</span>.format(object=<span class="string">"the lazy dog"</span>, subject=<span class="string">"the quick brown fox"</span>, verb=<span class="string">"jumps over"</span>))</span><br></pre></td></tr></table></figure><h1 id="special-format"><a href="#special-format" class="headerlink" title="special format"></a>special format</h1><table><thead><tr><th align="center">*      数字    *</th><th align="center">* Rust格式     *</th><th align="center">* Python格式      *</th><th align="center">*          输出      *</th><th align="center">*            描述          *</th></tr></thead><tbody><tr><td align="center">3.1415926</td><td align="center">{:.2}</td><td align="center">{:.2f}</td><td align="center">3.14</td><td align="center">保留小数点后两位</td></tr><tr><td align="center">3.1415926</td><td align="center">{:+.2}</td><td align="center">{:+.2f}</td><td align="center">+3.14</td><td align="center">带符号保留小数点后两位</td></tr><tr><td align="center">-1</td><td align="center">{:+.2}</td><td align="center">{:+.2f}</td><td align="center">-1(R)/-1.00(P)</td><td align="center">带符号保留小数点后两位</td></tr><tr><td align="center">-1.0</td><td align="center">{:+.2}</td><td align="center">{:+.2f}</td><td align="center">-1.00</td><td align="center">带符号保留小数点后两位</td></tr><tr><td align="center">2.71828</td><td align="center">{:.0}}</td><td align="center">{:.0f}</td><td align="center">3</td><td align="center">不带小数</td></tr><tr><td align="center">5</td><td align="center">{:0&gt;2}/{:02}</td><td align="center">{:0&gt;2d}/{:02d}</td><td align="center">05</td><td align="center">数字补0 (填充左边, 宽度为2)</td></tr><tr><td align="center">5</td><td align="center">{:x^10}</td><td align="center">{:x^10d}</td><td align="center">xxxx5xxxxx</td><td align="center">居中对齐</td></tr><tr><td align="center">5</td><td align="center">{:x&lt;4}</td><td align="center">{:x&lt;4d}</td><td align="center">5xxx</td><td align="center">数字补x (填充右边, 宽度为4)</td></tr><tr><td align="center">1000000</td><td align="center">NA.</td><td align="center">{:,}</td><td align="center">1,000,000</td><td align="center">以逗号分隔的数字格式</td></tr><tr><td align="center">0.25</td><td align="center">NA.</td><td align="center">{:.2%}</td><td align="center">25.00%</td><td align="center">百分比格式</td></tr><tr><td align="center">1000000000</td><td align="center">NA.</td><td align="center">{:.2e}</td><td align="center">1.00e+09</td><td align="center">指数记法</td></tr><tr><td align="center">1000000000.0</td><td align="center">{:2e}</td><td align="center">{:.2e}</td><td align="center">1e9(R)/1.00e+09(P)</td><td align="center">指数记法</td></tr><tr><td align="center">1000000000.0</td><td align="center">{:2E}</td><td align="center">{:.2E}</td><td align="center">1E9(R)/1.00E+09(P)</td><td align="center">指数记法</td></tr><tr><td align="center">42</td><td align="center">{:b}</td><td align="center">{:b}</td><td align="center">101010</td><td align="center">二进制</td></tr><tr><td align="center">42</td><td align="center">{:o}</td><td align="center">{:o}</td><td align="center">52</td><td align="center">八进制</td></tr><tr><td align="center">42</td><td align="center">{:x}</td><td align="center">{:x}</td><td align="center">2a</td><td align="center">十六进制</td></tr><tr><td align="center">42</td><td align="center">{:X}</td><td align="center">{:X}</td><td align="center">2A</td><td align="center">十六进制</td></tr><tr><td align="center">42</td><td align="center">{:#b}</td><td align="center">{:#b}</td><td align="center">0b101010</td><td align="center">带前缀的二进制</td></tr><tr><td align="center">42</td><td align="center">{:#o}</td><td align="center">{:#o}</td><td align="center">0o52</td><td align="center">带前缀的八进制</td></tr><tr><td align="center">42</td><td align="center">{:#x}</td><td align="center">{:#x}</td><td align="center">0x2a</td><td align="center">带前缀的十六进制</td></tr><tr><td align="center">42</td><td align="center">{:#X}</td><td align="center">{:#X}</td><td align="center">0x2A(R)/0X2A(P)</td><td align="center">带前缀的十六进制</td></tr></tbody></table><figure class="highlight rust"><figcaption><span>Rust precision specified in arg</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个参数是小数点后的位数</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"Pi is &#123;:+.*&#125;"</span>, <span class="number">2</span>, <span class="number">3.1415926</span>);</span><br></pre></td></tr></table></figure><h1 id="escape"><a href="#escape" class="headerlink" title="escape {}"></a>escape <code>{}</code></h1><figure class="highlight rust"><figcaption><span>Rust escape&#123;&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#123; &#123;t&#125; &#125;&#125;"</span>, t=<span class="string">"escape"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>Python escape&#123;&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">" The &#123;&#125; set is often represented as &#123; &#123;0&#125; &#125; "</span>.format(<span class="string">"empty"</span>))</span><br></pre></td></tr></table></figure><p>References：</p><ol><li><a href="https://rustwiki.org/rust-by-example/hello/print.html" target="_blank" rel="noopener">Rust print</a></li><li><a href="https://doc.rust-lang.org/std/fmt/index.html" target="_blank" rel="noopener">Module std::fmt</a></li><li><a href="http://blog.xiayf.cn/2013/01/26/python-string-format/" target="_blank" rel="noopener">Python格式字符串（译）</a></li><li><a href="http://stackoverflow.com/questions/493386/how-to-print-without-newline-or-space" target="_blank" rel="noopener">how-to-print-without-newline-or-space</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文对比Rust与Python语言的格式化输出。&lt;/p&gt;
    
    </summary>
    
      <category term="Rust" scheme="https://www.wuchenxu.com/categories/Rust/"/>
    
      <category term="Python" scheme="https://www.wuchenxu.com/categories/Rust/Python/"/>
    
    
      <category term="Rust" scheme="https://www.wuchenxu.com/tags/Rust/"/>
    
      <category term="Python" scheme="https://www.wuchenxu.com/tags/Python/"/>
    
      <category term="fmt" scheme="https://www.wuchenxu.com/tags/fmt/"/>
    
  </entry>
  
  <entry>
    <title>software development(2):variant handling</title>
    <link href="https://www.wuchenxu.com/2017/02/27/software-design-2-variant-handling/"/>
    <id>https://www.wuchenxu.com/2017/02/27/software-design-2-variant-handling/</id>
    <published>2017-02-27T13:11:23.000Z</published>
    <updated>2017-07-16T13:17:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>we should always avoid to use variant handling in software development, because one solution for all variants is the best solution.But sometimes we should compromise due to some limits.</p><a id="more"></a><p>Here are some scenarios I can see now:</p><ol><li>one platform solution for different microconroller/hardware. <a href="#pre-compile">pre-compile</a>. <a href="#link-different-libs">link different libs</a></li><li>confilict functions. <a href="#during-compile">during-compile</a></li><li>cross platform(algorithm development on PC, target is other MCU). <a href="#during-compile">during-compile</a>. <a href="#link-different-libs">link different libs</a></li><li>one ECU for different vehicle models. <a href="#one-time-configuraton">one-time configuraton</a>.  <a href="#bootloader">bootloader</a></li><li>differnt Transmission type for one vehicle model. <a href="#constant-configuration">constant configuration</a></li></ol><h1 id="pre-compile"><a href="#pre-compile" class="headerlink" title="pre-compile"></a>pre-compile</h1><p>copy choosed target files to target directory</p><figure class="highlight plain"><figcaption><span>two targets(A and B),before compile copy targetA or targetB to copied_target, only files in copied_target are included in makefile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_____componentA</span><br><span class="line">         |______targetA</span><br><span class="line">         |______targetB</span><br><span class="line">         |______copied_target</span><br></pre></td></tr></table></figure><h1 id="during-compile"><a href="#during-compile" class="headerlink" title="during-compile"></a>during-compile</h1><p>compile switch(macro)</p><figure class="highlight c"><figcaption><span>compile switch</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (GS_MAJOR_VER == GS_TARGET_A)</span></span><br><span class="line"><span class="comment">// implementation for GS_TARGET_A</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> (GS_MAJOR_VER == GS_TARGET_B)</span></span><br><span class="line"><span class="comment">// implementation for GS_TARGET_B</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span> <span class="meta-string">"no such target"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h1 id="on-the-fly"><a href="#on-the-fly" class="headerlink" title="on the fly"></a>on the fly</h1><h2 id="one-time-configuraton"><a href="#one-time-configuraton" class="headerlink" title="one-time configuraton"></a>one-time configuraton</h2><p>parameter is seleted by vehicle configuration shored in NVM/flash.</p><figure class="highlight c"><figcaption><span>parametes in flash, variant in NVM</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">varaint1_enm,</span><br><span class="line">variant2_enm</span><br><span class="line">&#125;Variants;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> VariantPar_st parameters[]=&#123;variant1_par, variant2_par&#125;;<span class="comment">//all parametes for variants stored in flash</span></span><br><span class="line"></span><br><span class="line">g_variant_u8 = getVariant();<span class="comment">//getVariant() read variant from NVM.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(varaint1_enm == g_variant_u8)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//load variant1 parameter or doing something special for variant1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//loac variant2 paramter or doing something special for variant2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="constant-configuration"><a href="#constant-configuration" class="headerlink" title="constant configuration"></a>constant configuration</h2><h3 id="Signal-Multiplexing"><a href="#Signal-Multiplexing" class="headerlink" title="Signal Multiplexing"></a>Signal Multiplexing</h3><p>One signal in the frame is used as a multiplexor and the remaining payload is interpreted depending on the value of the multiplexor signal.</p><img src="/2017/02/27/software-design-2-variant-handling/signal_multiplexing.png"><h3 id="adaptive-algorithm"><a href="#adaptive-algorithm" class="headerlink" title="adaptive algorithm"></a>adaptive algorithm</h3><p>differnt parameter according different condition(eg.temperature/huminity/speed…)</p><h1 id="post-compile"><a href="#post-compile" class="headerlink" title="post-compile"></a>post-compile</h1><h2 id="link-different-libs"><a href="#link-different-libs" class="headerlink" title="link different libs"></a>link different libs</h2><figure class="highlight plain"><figcaption><span>check your linker user manual and link different lib according to different target</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-L&#123;path to file containing library&#125; -l$&#123;library name&#125;</span><br></pre></td></tr></table></figure><h2 id="merge-different-parameters"><a href="#merge-different-parameters" class="headerlink" title="merge different parameters"></a>merge different parameters</h2><p>pre-condition: parameter size for different variants is the same</p><figure class="highlight plain"><figcaption><span>executable file structure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">------</span><br><span class="line">Application area</span><br><span class="line">------</span><br><span class="line">Calibration area</span><br><span class="line">------</span><br></pre></td></tr></table></figure><figure class="highlight plain"><figcaption><span>variant1.hex/exe</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">------</span><br><span class="line">Application area</span><br><span class="line">------</span><br><span class="line">Calibration area for variant1</span><br><span class="line">------</span><br></pre></td></tr></table></figure><h1 id="version-control"><a href="#version-control" class="headerlink" title="version control"></a>version control</h1><p>manage by version tools using branch, development path.</p><h1 id="deployment"><a href="#deployment" class="headerlink" title="deployment"></a>deployment</h1><h2 id="bootloader"><a href="#bootloader" class="headerlink" title="bootloader"></a>bootloader</h2><p>use bootloader to flash seperate calibartion data during End of Line according to different vehilce models.</p><figure class="highlight plain"><figcaption><span>executable file structure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">------</span><br><span class="line">Bootloader area</span><br><span class="line">------</span><br><span class="line">Application area</span><br><span class="line">------</span><br><span class="line">Calibration area</span><br><span class="line">------</span><br></pre></td></tr></table></figure><h2 id="sample-label"><a href="#sample-label" class="headerlink" title="sample label"></a>sample label</h2><p>different executable files for differnt ECUs.</p><p>References:</p><ol><li><a href="https://vector.com/portal/medien/cmc/application_notes/AN-ION-1-0521_Extended_Multiplexing_in_DBC_Databases.pdf" target="_blank" rel="noopener">Extended Signal Multiplexing in DBC Databases</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;we should always avoid to use variant handling in software development, because one solution for all variants is the best solution.But sometimes we should compromise due to some limits.&lt;/p&gt;
    
    </summary>
    
      <category term="software" scheme="https://www.wuchenxu.com/categories/software/"/>
    
    
      <category term="software" scheme="https://www.wuchenxu.com/tags/software/"/>
    
  </entry>
  
  <entry>
    <title>个人博客搭建hexo+github(9):本地搜索</title>
    <link href="https://www.wuchenxu.com/2017/02/15/Static-Blog-hexo-github-9-local-search/"/>
    <id>https://www.wuchenxu.com/2017/02/15/Static-Blog-hexo-github-9-local-search/</id>
    <published>2017-02-15T15:14:57.000Z</published>
    <updated>2017-07-16T13:17:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>本地搜索，不需要依赖外部的搜索服务，简单易用。</p><a id="more"></a><h1 id="安装hexo-generator-searchdb"><a href="#安装hexo-generator-searchdb" class="headerlink" title="安装hexo-generator-searchdb"></a>安装hexo-generator-searchdb</h1><p><code>npm install hexo-generator-searchdb --save</code></p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>在<code>hexo</code>(<del>不是主题的</del>)的 <code>_config.yml</code> 中增加配置</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: raw</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure><ul><li>path - file path. Default is search.xml .</li><li>field - the search scope you want to search, you can chose:<ul><li>post (Default) - will only covers all the posts of your blog.</li><li>page - will only covers all the pages of your blog.</li><li>all - will covers all the posts and pages of your blog.</li></ul></li><li>format - the form of the page contents, options are:<ul><li>html (Default) - original html string being minified.</li><li>raw - markdown text of each posts or pages.</li><li>excerpt - only collect excerpt.</li><li>more - act as you think.</li></ul></li><li>limit - define the maximum number of posts being indexed, always prefer the newest.</li></ul><h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><img src="/2017/02/15/Static-Blog-hexo-github-9-local-search/local_search_example.png"><p>Reference:</p><ol><li><a href="https://www.npmjs.com/package/hexo-generator-searchdb" target="_blank" rel="noopener">hexo-generator-searchdb</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本地搜索，不需要依赖外部的搜索服务，简单易用。&lt;/p&gt;
    
    </summary>
    
      <category term="hexo" scheme="https://www.wuchenxu.com/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://www.wuchenxu.com/tags/hexo/"/>
    
      <category term="github" scheme="https://www.wuchenxu.com/tags/github/"/>
    
      <category term="blog" scheme="https://www.wuchenxu.com/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>TeX(2):Mac下安装TeX</title>
    <link href="https://www.wuchenxu.com/2017/02/15/TeX-2-MacTex/"/>
    <id>https://www.wuchenxu.com/2017/02/15/TeX-2-MacTex/</id>
    <published>2017-02-15T13:37:13.000Z</published>
    <updated>2019-01-01T14:43:21.833Z</updated>
    
    <content type="html"><![CDATA[<p>Mac下TeX环境搭建</p><a id="more"></a><p>简要步骤：</p><ol><li>下载<a href="http://tug.org/mactex/" target="_blank" rel="noopener">MacTeX</a>，MacTeX是基于TeX Live之上的封装，即下即装，即装即用。</li><li>安装字库。由于我的latex文件原来是在windows下调试好字体的，所以一些字体在mac上是没有的，需要从windows把字库拷贝出来，在mac上安装好。</li><li>执行<code>xelatex ／your／file.tex</code>。</li></ol><p>没有错误就打完收工。</p><p>Reference:</p><ol><li><a href="https://www.zhihu.com/question/20928639" target="_blank" rel="noopener">如何在 OS X 上使用 LaTeX ？</a></li><li><a href="https://wuchenxu.com/2016/09/28/TeX-1-introduction/" target="_blank" rel="noopener">TeX(1):简介</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Mac下TeX环境搭建&lt;/p&gt;
    
    </summary>
    
      <category term="TeX" scheme="https://www.wuchenxu.com/categories/TeX/"/>
    
    
      <category term="TeX" scheme="https://www.wuchenxu.com/tags/TeX/"/>
    
  </entry>
  
  <entry>
    <title>人类简史：从动物到上帝 by 尤瓦尔·赫拉利</title>
    <link href="https://www.wuchenxu.com/2017/01/30/reading-notes-1-history-of-humankind/"/>
    <id>https://www.wuchenxu.com/2017/01/30/reading-notes-1-history-of-humankind/</id>
    <published>2017-01-30T05:09:04.000Z</published>
    <updated>2017-07-16T13:17:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>在历史的路上，有三大重要革命：大约7万年前，“认知革命”（Cognitive Revolution）让历史正式启动。大约12000年前，“农业革命”（Agricultural Revolution）让历史加速发展。而到了大约不过是500年前，“科学革命”（Scientific Revolution）可以说是让历史画下句点而另创新局。这本书的内容，讲述的就是这三大革命如何改变了人类和其他生物。</p><a id="more"></a><img src="/2017/01/30/reading-notes-1-history-of-humankind/cover_of_a_brief_history_of_humankind.jpg"><h1 id="点评"><a href="#点评" class="headerlink" title="点评"></a>点评</h1><p>作者论述了物理学诞生，到化学， 生物学的产生；意识革命之后开始有历史，产生了语言，人类能够互相沟通，创造出“虚构”的故事；农业革命后，文字出现，有了“想象的共同体”，能够大规模协作智人占据食物链顶端；金钱、帝国、宗教使得人类融合统一，构建全球秩序；科学革命，承认人类的无知，科技的飞速进步使得财富的总量大规模增加，人类也面临着生态环境恶化，人是否比以前幸福快乐的问题；但是未来的路怎么走 是人类内耗灭亡还是第二次生物学革命产生新物种，还是未知之数，毕竟历史只是历史，可以拓宽我们能的思维，但是未来的路还是要人类自己走。<br>作者以宏观的视角，纵观整个人类史，不但精通西方世界的历史，而且对东亚，南美的历史也是信手拈来，这是真正的从时间的维度全球的角度来看待的人类史。</p><h1 id="历史年表"><a href="#历史年表" class="headerlink" title="历史年表"></a>历史年表</h1><p>距今年代</p><ul><li>135亿年 物质和能量出现。物理学的开始。　　　　</li><li>原子和分子出现。化学的开始。</li><li>45亿年 地球形成。</li><li>38亿年 有机生物形成。生物学的开始。</li><li>600万年 人类和黑猩猩最后的共同祖先。</li><li>250万年 非洲的人属开始演化。出现最早的石器。</li><li>200万年 人类由非洲传播到欧亚大陆。　　　　</li><li>演化为不同人种。</li><li>50万年 尼安德特人在欧洲和中东演化。</li><li>30万年 开始日常用火。</li><li>20万年 智人在东非演化。</li><li>7万年 认知革命。出现能够描述虚拟故事的语言。　　　　</li><li>历史学的开始。智人传播至非洲之外。</li><li>4.5万年 智人抵达澳大利亚。澳大利亚巨型动物绝种。</li><li>3万年 尼安德特人绝种。</li><li>1.6万年 智人抵达美洲。美洲巨型动物绝种。</li><li>1.3万年 弗洛里斯人绝种。智人成为唯一存活的人类物种。</li><li>1.2万年 农业革命。驯化动植物。　　　　</li><li>出现永久聚落。</li><li>5000年 出现最早的王国、文字和金钱。多神教信仰。</li><li>4250年 出现最早的帝国：萨尔贡大帝的阿卡德帝国。</li><li>2500年 出现最早的硬币：通用的金钱。　　　　</li><li>波斯帝国：普世的政治秩序（“为全人类的福祉而努力”）。　　　　</li><li>印度佛教：普世的真理（“让所有人类解脱痛苦”）。</li><li>2000年 中国汉帝国。地中海罗马帝国。基督教。</li><li>1400年 伊斯兰教。500年 科学革命。人类承认自己的无知，开始取得前所未有的能力。　　　</li><li>欧洲人开始征服美洲和各大洋。整个地球形成单一历史场域。资本主义兴起。</li><li>200年 工业革命。家庭和社群被国家和市场取代。动植物大规模绝种。</li><li>现在 人类脱离了地球的疆域。　　　</li><li>核武器威胁人类的生存。　　　</li><li>生物开始越来越由智慧设计形塑，而非自然选择。</li><li>未来 智慧设计成为生命的基本原则？　　　</li><li>智人被超人类取代？</li></ul><h1 id="第一部分-认知革命"><a href="#第一部分-认知革命" class="headerlink" title="第一部分 认知革命"></a>第一部分 认知革命</h1><h2 id="第一章-人类：一种也没什么特别的动物"><a href="#第一章-人类：一种也没什么特别的动物" class="headerlink" title="第一章 人类：一种也没什么特别的动物"></a>第一章 人类：一种也没什么特别的动物</h2><p>从地球角度看，人类的历史其实很短。</p><blockquote><p>不过就在6万年前，有一头母猿产下两个女儿，一头成了所有黑猩猩的祖先，另一头则成了所有人类的祖奶奶。</p></blockquote><blockquote><p>从大约200万年前到大约1万年前为止，整个世界其实同时存在多种不同人种。这其实也十分合理。就像今天，地球上还是有许多种的狐狸、熊或是猪，而在几十万年前的地球上，至少就有6种不同的人。从整个历史来看，过去多种人种共存其实是常态，现在地球上只有“一种人”，这才是异常。</p></blockquote><blockquote><p>庞大的大脑也是个庞大的负担。大脑结构脆弱，原本就不利于活动，更别说还得用个巨大的头骨把它装着。而且大脑消耗的能量惊人。对智人来说，大脑只占身体总重约2%～3%，但在身体休息而不活动时，大脑的能量消耗却占了25%。</p></blockquote><p>这也是为啥人类历史上屡屡出现野蛮民族暴虐所谓文明国家。</p><blockquote><p>因为大脑较大，远古人类付出的代价有两种：首先是得花更多时间寻找食物，其次是肌肉退化萎缩。这就像是政府把国防预算转拨给了教育，人类也把手臂二头肌所需的能量拨给了大脑里的神经元。对于在非洲草原上这究竟是不是个好策略，事先只能说无人能知。虽然黑猩猩要讲道理绝对讲不赢智人，但它却能直接把智人像个布娃娃一样扯个稀烂。</p></blockquote><blockquote><p>我们用两条腿直立行走。能够站起来，就更容易扫视整片草原，看看哪里有猎物或敌人，而且既然手不需负责移动身体，就能发挥其他用途，像是丢石块或是做信号。手能做的事情越多，可以说人就变得越厉害；于是人的演化也就越来越着重神经发展，也不断地对手掌和手指的肌肉做修正。于是，人类的手开始能够处理非常精细的任务，特别是能够生产、使用复杂的工具。</p></blockquote><blockquote><p>火带来的最大好处在于开始能够烹饪。有些食物，处于自然形态的时候无法为人类所消化吸收，像小麦、水稻、马铃薯，但正因有了烹饪技术，就成为我们的主食。黑猩猩要咀嚼生肉，每天得花上五个小时，但人类吃的是熟食，每天花上一小时就够。</p></blockquote><h2 id="第二章-知善恶树"><a href="#第二章-知善恶树" class="headerlink" title="第二章 知善恶树"></a>第二章 知善恶树</h2><blockquote><p>大约就是在距今7万到3万年前，出现了新的思维和沟通方式，这也正是所谓的认知革命。会发生认知革命的原因为何？我们无从得知。得到普遍认可的理论认为，某次偶然的基因突变，改变了智人的大脑内部连接方式，让他们以前所未有的方式来思考，用完全新式的语言来沟通。这次突变，几乎就像是吃了《圣经》里那棵知善恶树的果实一样。为什么这只发生在智人的DNA里，而没有发生在尼安德特人的DNA里？我们现在只能说这就是纯粹的偶然。</p></blockquote><blockquote><p>最常见的理论，认为人类语言最为灵活。虽然我们只能发出有限的声音，但组合起来却能产生无限多的句子，各有不同的含义。于是，我们就能吸收、储存和沟通惊人的信息量，并了解我们周遭的世界。</p></blockquote><blockquote><p>第二种理论，也同意人类语言是沟通关于世界的信息的方式。然而，最重要的信息不是关于狮子和野牛，而是关于人类自己。我们的语言发展成了一种八卦的工具。根据这一理论，智人主要是一种社会性的动物，社会合作是我们得以生存和繁衍的关键。对于个人来说，光是知道狮子和野牛的下落还不够。更重要的，是要知道自己的部落里谁讨厌谁，谁跟谁在交往，谁很诚实，谁又是骗子。</p></blockquote><blockquote><p>人类语言真正最独特的功能，并不在于能够传达关于人或狮子的信息，而是能够传达关于一些根本不存在的事物的信息。据我们所知，只有智人能够表达关于从来没有看过、碰过、耳闻过的事物，而且讲得煞有其事。</p></blockquote><blockquote><p>在认知革命之后，智人就能够说出：“狮子是我们部落的守护神。”</p></blockquote><blockquote><p>“讨论虚构的事物”正是智人语言最独特的功能。“虚构”这件事的重点不只在于让人类能够拥有想象，更重要的是可以“一起”想象，编织出种种共同的虚构故事，不管是《圣经》的《创世记》、澳大利亚原住民的“梦世记”（Dreamtime），甚至连现代所谓的国家其实也是种想象。这样的虚构故事赋予智人前所未有的能力，让我们得以集结大批人力、灵活合作。</p></blockquote><blockquote><p>即使到了今天，人类的团体还是继续受到这个神奇的数字影响。只要在150人以下，不论是社群、公司、社会网络还是军事单位，只要靠着大家都认识、彼此互通消息，就能够运作顺畅，而不需要规定出正式的阶层、职称、规范。</p></blockquote><blockquote><p>无论是现代国家、中世纪的教堂、古老的城市，或者古老的部落，任何大规模人类合作的根基，都在于某种只存在于集体想象中的虚构故事。</p></blockquote><p>法人</p><blockquote><p>标致公司只是我们的一个集体想象，这种想象在法律上称为“法律拟制”（legal fiction）。像是公司，我们没办法明确指着它，它不是一个实体对象，而是以一种法律实体的方式存在。这种法律实体就像你我，会受到所在国家法律的管辖，可以开立银行账户，拥有自己的财产，要纳税，也可能独立于所有拥有者或员工之外而遭到起诉。</p></blockquote><blockquote><p>事实就是所有动物只有智人能够进行贸易，而所有我们有详细证据证明存在的贸易网络都明显以虚构故事为基础。例如，如果没有信任，就不可能有贸易，而要相信陌生人又是件很困难的事。今天之所以能有全球贸易网络，正是因为我们相信着一些虚拟实体，像是美元、联邦储备银行，还有企业的商标。而在部落社会里，如果两个陌生人想要交易，往往也得先借助共同的神明、传说中的祖先或图腾动物建立信任。</p></blockquote><img src="/2017/01/30/reading-notes-1-history-of-humankind/chapter2.jpg"><blockquote><p>和认知革命正是历史从生物学中脱离而独立存在的起点。在这之前，所有人类的行为都只称得上是生物学的范畴，也有人喜欢称为“史前史”（但我倾向避免用这个词汇，因为这种说法暗示着即使在认知革命之前，人类也是自成一格，与其他动物不同）。认知革命之后，我们要解释智人的发展，依赖的主要工具就不再是生物学理论，而改用历史叙事。就像是如果要理解为何儒家或共产主义能在中国传播，光知道基因、荷尔蒙和有机体这些还不够，另外也得考虑到各种想法、图像幻想的互动才行。</p></blockquote><blockquote><p>讲到认知革命之后生物学和历史的关系，我们可以简单整理成三点：</p></blockquote><ol><li>基本上，生物学为智人的行为和能力设下了基本限制，像是定出了一个活动范围，而所有的历史都在这个范围之内发生。</li><li>然而，这个范围非常大，能让智人有各种惊人的发挥空间。因为他们有创造虚构故事的能力，就能创造出更多、更复杂的游戏，代代相传也就不断发展精进。</li><li>因此，想了解智人的行为，就必须描述人类行为的历史演化。</li></ol><h2 id="第三章-亚当和夏娃的一天"><a href="#第三章-亚当和夏娃的一天" class="headerlink" title="第三章 亚当和夏娃的一天"></a>第三章 亚当和夏娃的一天</h2><blockquote><p>演化心理学近来发展蓬勃，认为现在人类的各种社会和心理特征早从农业时代之前就已经开始形塑。这个领域的学者认为，即使到了现在，我们的大脑和心灵都还是以狩猎和采集的生活方式在思维</p></blockquote><blockquote><p>就算我们今天可能住在高楼大厦，家家户户的冰箱早就塞满食物，我们的DNA还记得那些在草原上的日子。正因如此，我们才会不知不觉就吃完一整桶的哈根达斯，可能还配着一大杯可口可乐。</p></blockquote><blockquote><p><code>语言和文化</code>正是认知革命的主要成就。而正因为虚构故事已经出现，即使是在类似的生态、同样的基因组成下出现的人类，也能够创造出非常不同的想象现实，表现出来就成了不同的规范和价值观。</p></blockquote><h2 id="第四章-毁天灭地的人类洪水"><a href="#第四章-毁天灭地的人类洪水" class="headerlink" title="第四章 毁天灭地的人类洪水"></a>第四章 毁天灭地的人类洪水</h2><blockquote><p>对这些动物来说，需要靠演化才能学会惧怕人类，但时间根本不够，它们转眼便已灭绝。</p></blockquote><blockquote><p>智人的第一波殖民正是整个动物界最大也最快速的一场生态浩劫。</p></blockquote><blockquote><p>第一波的灭绝浪潮是由于采集者的扩张，接着第二波灭绝浪潮则是因为农民的扩张；这些教训，让我们得以从一个重要观点来看今日的第三波灭绝浪潮：由工业活动所造成的物种灭绝</p></blockquote><h1 id="第二部分-农业革命"><a href="#第二部分-农业革命" class="headerlink" title="第二部分 农业革命"></a>第二部分 农业革命</h1><h2 id="第五章-史上最大骗局"><a href="#第五章-史上最大骗局" class="headerlink" title="第五章 史上最大骗局"></a>第五章 史上最大骗局</h2><blockquote><p>这一切在大约1万年前全然改观，人类开始投入几乎全部的心力，操纵着几种动植物的生命。从日升到日落，人类忙着播种、浇水、除草、牧羊，一心以为这样就能得到更多的水果、谷物和肉类。这是一场关于人类生活方式的革命：农业革命。</p></blockquote><blockquote><p>即使到了今天，虽然人类有着种种先进科技，但食物热量超过90%的来源仍然是来自人类祖先在公元前9500年到公元前3500年间驯化的植物：小麦、稻米、玉米、马铃薯、小米和大麦。在过去2000年间，人类并没有驯化什么特别值得一提的动植物。可以说，人到现代还有着远古狩猎采集者的心，以及远古农民的胃。</p></blockquote><blockquote><p>普遍来说，农民的工作要比采集者更辛苦，而且到头来的饮食还要更糟。农业革命可说是史上最大的一桩骗局。</p></blockquote><blockquote><p>真正的主要嫌疑人，就是那极少数的植物物种，其中包括小麦、稻米和马铃薯。人类以为自己驯化了植物，但其实是植物驯化了智人。</p></blockquote><blockquote><p>智人的身体演化目的并不是为了从事这些活动，我们适应的活动是爬爬果树、追追瞪羚，而不是弯腰清石块、努力挑水桶。于是，人类的脊椎、膝盖、脖子和脚底就得付出代价。研究古代骨骼发现，人类进到农业时代后出现了大量疾病，例如椎间盘突出、关节炎和疝气</p></blockquote><blockquote><p>如果要衡量某种物种演化成功与否，评断标准就在于世界上其DNA螺旋的拷贝数的多寡。</p></blockquote><p>活下去就是胜利</p><blockquote><p>这正是农业革命真正的本质：让更多的人却以更糟的状况活下去。</p></blockquote><blockquote><p>每个世代的人做出了当时最好的抉择，最后的结果不一定是最好的，至少某些方面不是。<br>每一代人都只是继续着上一代生活的方式，在这里修一点，那里改一些。但矛盾的是，一连串为了让生活更轻松的“进步”，最后却像是在这些农民的身上加了一道又一道沉重的枷锁。</p></blockquote><p>积重难返</p><blockquote><p>为什么他们不赶快放弃农耕，回到采集生活？部分原因在于，所有改变都必须点点滴滴累积，经过许多代的时间，才能够改变社会；等到那个时候，已经没有人记得过去曾经有不同的生活方式可选了。另一部分，是因为人口增长就像是破釜沉舟。一旦采用农耕之后，村落的人口从100人成长到110人，难道会有10个人自愿挨饿，好让其他人可以回到过去的美好时光？这已经再无回头路。人类发现时，已经深陷陷阱、无法自拔。</p></blockquote><blockquote><p>多少年轻的大学毕业生投身大企业、从事各种劳心劳力的工作，发誓要努力赚钱，好在35岁就退休，去从事他们真正有兴趣的事业？但等他们到了35岁，却发现自己背着巨额贷款，要付子女的学费，要养在高级住宅区的豪宅，每家得有两部车，而且觉得生活里不能没有高级红酒和国外的假期。他们该怎么做？他们会放下一切，回去野外采果子挖树根吗？当然不可能，而是加倍努力，继续把自己累得半死。</p></blockquote><blockquote><p>这个关于奢侈生活陷阱的故事，告诉我们一个重要的教训。人类一心追求更轻松的生活，于是释放出一股巨大的力量，改变了世界的面貌，但结果并没有任何人料想得到，甚至也不是任何人所乐见的。并没有人在背后操纵农业革命发生，或是意图让人依赖谷类维生。一开始只是各种小事，主要就是希望吃饱一点、生活安全一点，但最后累积引起的效应，就是让远古的采集者开始花上整天的时间，在烈日之下挑水务农。</p></blockquote><blockquote><p>贝克力石阵显示，很有可能其实是先建立起信仰中心，之后才围绕着它形成村子。<br>不幸的是，演化观点并不是唯一判断物种成功与否的标准。它一切只考虑到生存和繁殖，而不顾个体的痛苦或幸福。虽然就演化而言，驯化的鸡和牛很可能是最成功的代表，但它们过的其实是生物有史以来最惨的生活。动物的驯化是建立在一系列的野蛮作为上，而且随着时间的前行，残忍程度只增不减。</p></blockquote><blockquote><p>在许多新几内亚的部落社会里，想判断一个人富不富有，就要看他/她有几头猪。而为了确保猪跑不掉，新几内亚北部的农民会把猪的鼻子切掉一大块。这样一来，每次猪想闻东西，都会感到强烈的疼痛，不但无法觅食，甚至连找路都做不到，于是不得不完全依赖人类主人。在新几内亚的另一个地区，人们甚至还习惯直接把猪的眼睛挖掉，杜绝它们逃跑的可能。</p></blockquote><h2 id="第六章-盖起金字塔"><a href="#第六章-盖起金字塔" class="headerlink" title="第六章 盖起金字塔"></a>第六章 盖起金字塔</h2><p>这就跟人的经验是一样的。经验越多看似好事，但是也限制了其他可能性。思维定式，路径依赖</p><blockquote><p>人类发现自己已经很难离开这些人工岛屿了，所有的房子、田地、谷仓，放弃哪个都可能带来重大的损失。此外，随着时间过去，他们拥有的东西越来越多，不易搬运，也把他们绑得死死的。</p></blockquote><p>知道从哪儿来，才能知道要到哪儿去。</p><blockquote><p>农业革命之后，“未来”的重要性被提到史上新高。农民不仅时时刻刻都得想着未来，还几乎可以说是为了未来在服务。<br>正是这些征收来的多余食粮，养活了政治、战争、艺术和哲学，建起了宫殿、堡垒、纪念碑和庙宇。</p></blockquote><blockquote><p>所有这些合作网络，不管是古代美索不达米亚的城市，还是秦朝和古罗马的帝国，都只是“由想象所建构的秩序”。支持它们的社会规范既不是人类自然的天性本能，也不是人际的交流关系，而是他们都相信着共同的虚构神话故事。</p></blockquote><blockquote><p>不管是汉谟拉比还是美国的开国元勋，心中都有个想象的现实，想象着这个世界有着放诸四海皆准、永恒不变的正义原则（例如平等或阶级），但这种不变的原则其实只存在于智人丰富的想象力里，只存在于他们创造并告诉彼此的虚构故事中。这些原则，从来就没有客观的正确性。</p></blockquote><blockquote><p>伏尔泰就曾说：“世界上本来就没有神，但可别告诉我的仆人，免得他半夜偷偷把我宰了。</p></blockquote><blockquote><ol><li>想象建构的秩序深深与真实的世界结合。</li><li>想象建构的秩序塑造了我们的欲望。</li><li>想象建构的秩序存在于人和人之间思想的连接。</li></ol></blockquote><blockquote><p>“主体间”事物的存在，靠的是许多个人主观意识之间的连接网络。就算有某个人改变了想法，甚至过世，对这项事物的影响并不大。但如果是这个网络里面的大多数都死亡或是改变了想法，这种“主体间”的事物就会发生改变或是消失。之所以会有事物存在于主体之间，其目的并不是想存心骗人，也不是只想打哈哈敷衍。虽然它们不像放射线会直接造成实质影响，但对世界的影响仍然不容小觑。历史上有许多最重要的驱动因素，都是这种存在于主体之间的概念想法：法律、金钱、神、国家。<br>为了改变现有由想象建构出的秩序，就得先用想象建构出另一套秩序才行。</p></blockquote><blockquote><p>每一次我们以为自己打破了监狱的高墙、迈向自由的前方，其实只是到了另一间更大的监狱，把活动范围稍稍加以扩大。</p></blockquote><h2 id="第七章-记忆过载"><a href="#第七章-记忆过载" class="headerlink" title="第七章 记忆过载"></a>第七章 记忆过载</h2><blockquote><p>因为智人的社会秩序是通过想象建构，维持秩序所需的关键信息无法单纯靠DNA复制就传给后代，需要通过各种努力，才能维持种种法律、习俗、程序、礼仪，否则社会秩序很快就会崩溃。</p></blockquote><blockquote><p>正因为结绳语有效又准确，就算在西班牙人占领南美之后，还是用结绳语来管理他们建立的新帝国。</p></blockquote><blockquote><p>文字对人类历史所造成最重要的影响：它逐渐改变了人类思维和看待这个世界的方式。过去的自由连接、整体思考，已经转变为分割思考、官僚制度。</p></blockquote><h2 id="第八章-历史从无正义"><a href="#第八章-历史从无正义" class="headerlink" title="第八章 历史从无正义"></a>第八章 历史从无正义</h2><blockquote><p>是人类创造出了由想象建构的秩序、发明了文字，以这两者补足我们基因中的不足。</p></blockquote><blockquote><p>讽刺的是，非洲人在基因上的优势（免疫力）竟造成了他们在社会上的劣势：正因为他们比欧洲人更能适应热带气候，反让他们成了遭到欧洲主人蹂躏的奴隶！由于这些环境因素，美洲的新兴社会也出现了另一个种姓阶级：欧洲白人的统治阶级，以及非洲黑人的奴隶阶级</p></blockquote><blockquote><p>黑人被困在这个恶性循环里，他们申请不到白领的工作，是因为别人以为他们笨，但证明他们笨的，又是因为白领中很少有黑人。</p></blockquote><blockquote><p>大多数社会政治阶级制度其实都没有逻辑或生物学的基础，不过就是由历史的偶然事件引起，再用虚构的故事延续壮大。这正是历史值得研究的一个很好的理由。</p></blockquote><blockquote><p>我们究竟要如何才能判断，什么是真正在生物学上有所不同，而什么又只是人类说得煞有介事、自找借口？一项黄金法则就是“天生带来允许，文化造成封闭”。天生自然的生物学，可能性几乎无穷无尽。然而，文化却要求必须实现某些可能性，而又封闭了其他可能性。例如女性天生能生小孩，但在某些文化里，女性却是非生不可。生物学上，男人就是能从彼此身上得到性愉悦，但某些文化却极力阻止他们实现这种可能。</p></blockquote><h1 id="第三部分-人类的融合统一"><a href="#第三部分-人类的融合统一" class="headerlink" title="第三部分 人类的融合统一"></a>第三部分 人类的融合统一</h1><h2 id="第九章-历史的方向"><a href="#第九章-历史的方向" class="headerlink" title="第九章 历史的方向"></a>第九章 历史的方向</h2><blockquote><p>人类几乎从出生到死亡都被种种虚构的故事和概念围绕，让他们以特定的方式思考，以特定的标准行事，想要特定的东西，也遵守特定的规范。就是这样，让数百万计的陌生人能遵照着这种人造而非天生的直觉，合作无间。这种人造的直觉就是“文化”。</p></blockquote><blockquote><p>自从法国大革命之后，全球人民逐渐同意“自由”和“平等”都是基本的价值观。然而这两者根本就互相抵触！想要确保“平等”，就得限制住那些较突出的人；而要人人都能“自由”，也就必然影响所有人的平等。</p></blockquote><blockquote><p>一般认为认知失调是人类心理上的一种问题，但这其实是一项重要的特性，如果人真的无法同时拥有互相抵触的信念和价值观，很可能所有的文化都将无从建立，也无以为继。</p></blockquote><blockquote><p>三种全球秩序，首先第一种是经济上的货币秩序，第二种是政治上的帝国秩序，而第三种则是宗教上的全球性宗教，像是佛教、基督教和伊斯兰教。</p></blockquote><h2 id="第十章-金钱的味道"><a href="#第十章-金钱的味道" class="headerlink" title="第十章 金钱的味道"></a>第十章 金钱的味道</h2><blockquote><p>在以物易物的经济里，不管是鞋匠还是种苹果的，每天都得搞清楚几十种商品的相对价格。如果市场上有100种不同的商品，把汇率列出来就足足有洋洋洒洒的4950条。如果市场上有1000种不同的商品，汇率更足足有499500条！这怎么可能记得起来？</p></blockquote><blockquote><p>人们之所以愿意如此，正是因为他们接受了这个集体的想象。“信任”正是所有金钱形式最基本的原料。如果有个富裕的农民卖掉房舍田产换来一袋贝壳，还带着这袋贝壳前往远地的省份，那是因为他相信抵达之后，其他人会愿意用稻米、房屋和田地和他交换这些贝壳。所以，可以说金钱就是一种相互信任的系统，而且还不是随随便便的某种系统：金钱正是有史以来最普遍也最有效的互信系统。</p></blockquote><h2 id="第十一章-帝国的愿景"><a href="#第十一章-帝国的愿景" class="headerlink" title="第十一章 帝国的愿景"></a>第十一章 帝国的愿景</h2><blockquote><p>要建立和维系帝国，确实通常就有惨烈的屠杀，而幸存者也会受到残酷的压迫。帝国的标准配备，常常就包括战争、奴役、驱逐和种族屠杀。</p></blockquote><blockquote><p>虽然居鲁士还是会强调统治者和被统治者之间的种族和文化差异，但认为整个世界基本上为一体，同样一套原则可以适用于所有时间地点，而且所有人类应互相负责。于是，人类就像是一个大家庭：父母享有特权，但同时也要负责孩子的幸福。这种新的帝国思想从居鲁士和波斯人传给了亚历山大大帝，再传给希腊国王、古罗马皇帝、穆斯林哈里发、印度君主，最后甚至还传给苏联总理和美国总统。</p></blockquote><blockquote><p>有一则著名的逸事，讲的是有个印度人雄心勃勃，把英语学得无懈可击，上了西式舞蹈的课程，甚至还养成了用刀叉进食的习惯。他把这一切学好之后前往英格兰，在伦敦大学学院读法律，还成为一名合格的律师。然而，后来这个读法律的年轻人到了英属南非，穿着西装、打着领带，却因为坚持自己该坐头等车厢，而不是像他一样的“有色人种”该坐的三等车厢，便被赶下火车。这个人就是甘地。</p></blockquote><img src="/2017/01/30/reading-notes-1-history-of-humankind/chapter11.jpg"><h2 id="第十二章-宗教的法则"><a href="#第十二章-宗教的法则" class="headerlink" title="第十二章 宗教的法则"></a>第十二章 宗教的法则</h2><h3 id="当崇拜对象是神"><a href="#当崇拜对象是神" class="headerlink" title="当崇拜对象是神"></a>当崇拜对象是神</h3><blockquote><p>真正让多神论与一神论不同的观点，在于多神论认为主宰世界的最高权力不带有任何私心或偏见，因此对于人类各种世俗的欲望、担心和忧虑毫不在意。因此，要向这个最高权力祈求战争胜利、健康或下雨，可以说是完全没有意义，因为从他全知全观的角度来说，某个王国的战争输赢、某个城市的兴衰胜败，又或是某个人的生老病死，根本不构成任何差别。希腊人不会浪费祭品去祭拜命运女神，而印度教徒也并未兴建寺庙来祭拜阿特曼。要接近这个宇宙至高的权力，就代表要放下所有的欲望、接受福祸共存的事实，坦然面对失败、贫穷、疾病和死亡。</p></blockquote><blockquote><p>事实证明，就算把这些迫害的所有受害者全部加起来，在这3个世纪间，多神教古罗马处决基督徒的人数不超过几千人。但相对的是，在接下来的1500年间，虽然基督教号称主张爱与怜悯，但仅仅对信仰的诠释有些许差异，就引发基督徒自相残杀，死亡人数达到数百万。</p></blockquote><blockquote><p>在过去两千年间，一神论者多次发动以暴力消灭其他竞争对手的战争，目的就是要加强自己的掌控。</p></blockquote><blockquote><p>就像是泛神论会继续在多神论里延续，多神论也继续在一神论里存活。</p></blockquote><blockquote><p>一神论宗教大张旗鼓把其他神祇从大门赶了出去，但又从旁边的小窗把他们迎了回来。以基督教为例，就发展出了自己的圣人系统，但这套系统可说和多神教几乎殊无二致。<br>英格兰的守护圣人是圣乔治，苏格兰是圣安德鲁，匈牙利是圣史蒂芬，而法国是圣马丁。</p></blockquote><blockquote><p>这样看来，基督教的圣人和多神教的那些神祇几乎没有两样。但很多时候甚至还不只是类似而已，而根本就是这些神祇的伪装。举例来说，在信奉基督宗教之前，爱尔兰的主神是女神布里基德。等到爱尔兰被基督教化，就连布里基德也仿佛受了洗一样，成了“圣布里基德”。而且直到今天，还是天主教爱尔兰最受尊崇的圣人。</p></blockquote><blockquote><p>“恶的难题”（Problem of Evil），苦苦无法解决。“为什么世界上会有邪恶？为什么有苦难？为什么会有坏事发生在好人身上？”如果神真的是如此无所不知、无所不能、事事完美，又怎么会允许世界上有这么多的苦难？</p></blockquote><blockquote><p>“法则的难题”（Problem of Order）。如果世上就是有善恶两股力量在拉扯，它们拉扯的基础是什么法则？</p></blockquote><p>“马自达“汽车的来源</p><blockquote><p>善神阿胡拉·马兹达（Ahura Mazda）</p></blockquote><p>从历史的角度看宗教</p><blockquote><p>从历史上来看，一神论就像是个万花筒，承继了一神论、二元论、多神论和泛神论，收纳在同一个神圣论述之下。结果就是，基督徒大致上是信奉一神论的上帝，相信二元论的魔鬼，崇拜多神论的圣人，还相信泛神论的鬼魂。像这样同时有着不同甚至矛盾的思想，而又结合各种不同来源的仪式和做法，宗教学上有一个特别的名称：综摄（syncretism）。很有可能，综摄才是全球最大的单一宗教。</p></blockquote><h3 id="崇拜对象时自然法则"><a href="#崇拜对象时自然法则" class="headerlink" title="崇拜对象时自然法则"></a>崇拜对象时自然法则</h3><blockquote><p>在公元前1000年，亚非大陆开始出现全新的宗教及信仰类型。这些新型宗教信仰包括印度的耆那教（Jainism）和佛教，中国的道教和儒教，以及地中海的犬儒主义（Cynicism）和享乐主义（Epicureanism），共同的特征就是崇拜的并非神祇。</p></blockquote><blockquote><p>这些信仰也认为有某种超人类秩序控制着这个世界，但它们所崇拜的这个秩序是自然法则，而不是什么神圣的意志。这些自然法则的宗教信仰虽然某些也相信有神祇存在，但认为神祇就和人类、动物和植物一样会受到自然法则的限制。虽然神祇可以说在这个生态系统中有其优势（就算是大象或豪猪，也各有优势），但他们也像大象一样，并无法改变自然的法则。</p></blockquote><p>现在人的小心思，喜怒哀乐，其实前人都有过，都经历过，思考过，并且给出了解决方案。只是每一代人都有自己独特的生存环境，都觉得自己是独特的，之前的解决方案不适合自己，也许到最后会得出同前人一样的结论。没办法，不经历过，怎知是非对错</p><blockquote><p>人类追求财富和权力，获得知识和财富，生儿育女，建起宫殿和房屋。但不论取得多少成就，却仍然无法满足。穷人梦想着要变富，有一百万的想要两百万，有两百万的想要一千万。而且就算真的有钱了、有名了，他们还是不满意，还是有无尽的烦恼和忧虑，无法从生老病死中解脱<br>最后他体会到，一切苦难并非来自噩运、社会不公或是神祇的任性，而是出于每个人自己心中的思想模式。</p></blockquote><blockquote><p>在事物带来快乐或痛苦的时候，重点是要看清事物的本质，而不是着重在它带来的感受，于是就能不再为此所困。虽然感受悲伤，但不要希望悲伤结束，于是虽然仍有悲伤，也能不再为此而困。即使仍然悲伤，也是一种丰硕的经验。虽然感受快乐，但不要希望快乐继续，于是虽然仍有快乐，也能不失去心中的平静。</p></blockquote><blockquote><p>释迦牟尼制定一套冥想的技巧，能够训练心灵感受事物的本质而排除种种欲求。通过训练，心灵专注在“我现在是什么感受？”，而不是问：“为什么是我？”</p></blockquote><blockquote><p>佛陀的教诲一言以蔽之：痛苦来自欲望；要从痛苦中解脱，就要放下欲望；而要放下欲望，就必须训练心智，体验事物的本质。</p></blockquote><blockquote><p>佛教徒还是崇拜着各种神祇，像是在印度的佛教徒拜着印度的神，西藏的佛教徒拜着本教（Bon）的神，日本的佛教徒也拜着神道教的神。</p></blockquote><blockquote><p>诸佛菩萨是人也非人，他们已经能够达到涅槃、解脱痛苦，但为了解脱和帮助还在轮回中的芸芸众生，倒驾慈航重入世间</p></blockquote><h3 id="当崇拜的对象变成了人"><a href="#当崇拜的对象变成了人" class="headerlink" title="当崇拜的对象变成了人"></a>当崇拜的对象变成了人</h3><img src="/2017/01/30/reading-notes-1-history-of-humankind/chapter12.jpg"><h2 id="第十三章-成功的秘密"><a href="#第十三章-成功的秘密" class="headerlink" title="第十三章 成功的秘密"></a>第十三章 成功的秘密</h2><blockquote><p>“如何”和“为何”之间有何不同？描述“如何”的时候，是要重建一连串从一点导致另一点的事件顺序。至于要解释“为何”的时候，则是要找出因果关系，看看究竟为什么发生的是这一连串的事件，而不是另一连串的事件。</p></blockquote><blockquote><p>历史的铁则就是：事后看来无可避免的事，在当时看来总是毫不明显。直到今天，情况仍是如此。我们已经走出全球经济危机了吗？还是前面还有更大的打击？中国会不会继续成长、成为全球第一的超级大国？美国会不会丧失霸主地位？</p></blockquote><p>不能觉得什么都是理所当然的，战争，经济危机，说不定随时可能发生</p><blockquote><p>在1913年10月，布尔什维克党还只是一个很小的俄国激进党派。任何理性的人都想不到，不过短短4年后，他们就接掌了俄国。在公元600年，如果说一小群住在沙漠里的阿拉伯部落会征服从大西洋到印度的辽阔土地，更是如痴人说梦。</p></blockquote><blockquote><p>这也不是说一切都有可能发生。地理、生物和经济力量确实会造成限制。但限制下仍然有许多发展空间，目前还没有什么确实加以制约的法则。</p></blockquote><blockquote><p>历史就是这样的一团混沌，历史就是无法解释得斩钉截铁，无法预测得十拿九稳。在同一时间，有多方力量互相影响、互相牵制，只要某方力量有了极小的改变，结果就会有巨大的不同。</p></blockquote><blockquote><p>混沌系统分成两级，一级混沌指的是“不会因为预测而改变”。例如天气就属于一级混沌系统。<br>至于二级混沌系统，指的是“会受到预测的影响而改变”，因此就永远无法准确预测。例如市场就属于二级混沌系统。<br>政治也属于二级混沌系统。很多人批评研究苏联的学者没能预测到1989年的苏联解体，也嘲笑中东专家没想到2011年会爆发阿拉伯之春革命。但这是不公平的。从定义上，革命就是无法预测。如果真能预测有革命，革命就永远不会成真。</p></blockquote><p>举例</p><blockquote><p>假设在2010年，有某些天才政治学者与某个计算机鬼才合作，开发出某种绝对准确的算法还有个漂亮的界面，号称能够预测是否发生革命。于是，他们向埃及总统穆巴拉克兜售这项服务，换取了一大笔可观的酬劳，告诉穆巴拉克，他们预测来年在埃及必然爆发大规模革命。穆巴拉克会如何反应？最有可能的是他会立刻降税，用数十亿美元补助人民，顺便也大幅加强秘密警察部队，以防万一。于是，这一切的准备工作发挥了效果。一年很快就过去，而且没有发生革命，真是太让人意想不到了，不是吗？于是，穆巴拉克要求退款。他向科学家大吼大叫：“你这套算法是骗人的！要不是你这套东西，我才不会把钱都拱手让人，我大可多盖一座宫殿！”科学家会辩白道：“可是，正是因为我们预测到了，革命才没有发生啊。”“你是说，你们预测到了，只是没有发生？”穆巴拉克一边说，一边示意叫警卫把他们全部抓起来。“这种神棍，开罗的市场到处都有。”</p></blockquote><p>以史为镜 可以知兴替</p><blockquote><p>我们之所以研究历史，不是为了要知道未来，而是要拓展视野，要了解现在的种种绝非“自然”，也并非无可避免。未来的可能性远超过我们的想象。</p></blockquote><blockquote><p>虽然我们无法解释历史做出的选择，但有一点可以确定：历史的选择绝不是为了人类的利益。</p></blockquote><blockquote><p>根据这种说法，文化并不是某些人为了剥削他人而设计出的阴谋，而是因为种种机缘巧合所出现的心理寄生虫，从出现之后就开始剥削所有受到感染的人。<br>迷因学假设，就像是生物演化是基于“基因”这种有机信息单位的复制，文化演化则是基于“迷因”（meme）这种文化信息单位的复制。而所谓成功的文化，就是特别善于复制其迷因，而丝毫不论这对于其人类宿主的成本或利益。</p></blockquote><h1 id="第四部分-科学革命"><a href="#第四部分-科学革命" class="headerlink" title="第四部分 科学革命"></a>第四部分 科学革命</h1><h2 id="第十四章-发现自己的无知"><a href="#第十四章-发现自己的无知" class="headerlink" title="第十四章 发现自己的无知"></a>第十四章 发现自己的无知</h2><p>大杀器</p><blockquote><p>如果要在过去500年间挑出一个最重大、具代表性的一刻，一定就是1945年7月16日上午5点29分45秒。就在这一秒，美国科学家在新墨西哥的阿拉莫戈多引爆了第一颗原子弹。从这时开始，人类不仅有了改变历史进程的能力，更有了结束历史进程的能力。</p></blockquote><blockquote><p>现代科学与先前的知识体系有三大不同之处：<br>1.愿意承认自己的无知<br>2.以观察和数学为中心。<br>3.取得新能力。</p></blockquote><blockquote><p>现代科学是一套独特的知识体系，独特之处也就在于公开承认这“整套体系”都对一些“最重要的问题”一无所知</p></blockquote><blockquote><p>现代科学愿意承认自己的无知，就让它比所有先前的知识体系更具活力、更有弹性，也更有求知欲。</p></blockquote><blockquote><p>现代想要维持社会政治秩序稳定，只能靠着两种不科学的方法，其他别无选择。<br>1.虽然采用科学理论，但必须违反一般科学做法：宣称这就是绝对的真理。纳粹就是采用这种方式，声称他们的种族政策是来自生物事实的推论。<br>2.不要采取科学方法，而诉诸“非科学的绝对真理”。这一直是自由人文主义的策略。自由人文主义的基础在于坚持主张人类的特殊价值和权利，但很尴尬的是，对智人的科学研究并不认同这种看法。但我们也不该太过惊讶。毕竟，科学还是得倚靠着种种宗教和意识形态信仰，才能取得经费，并将研究正当化。</p></blockquote><blockquote><p>现代科学没有需要严格遵守的教条，但研究方法有一个共同的核心：收集各种实证观察（可以用感官感受到的），并以数学工具整理。</p></blockquote><blockquote><p>有些学者想仿照牛顿，将生物学、经济学和心理学整理成简单的公式，却发现这些领域实在太复杂，不可能依样画葫芦。然而，这并不代表他们就放弃了数学。在过去两百年间，为了处理现实中更复杂的层面，数学发展出一个新的分支：统计学。</p></blockquote><blockquote><p>纵观历史，社会上有两种贫穷：（1）社会性的贫穷，指的是某些人掌握了机会，却不愿意释出给他人；（2）生物性的贫穷，指的是因为缺乏食物和住所，而使人的生存受到威胁。或许社会性的贫穷永远都会存在、无法根除，但在全球许多国家中，生物性的贫穷都已经成了过去式。</p></blockquote><h2 id="第十五章-科学与帝国的联姻"><a href="#第十五章-科学与帝国的联姻" class="headerlink" title="第十五章 科学与帝国的联姻"></a>第十五章 科学与帝国的联姻</h2><blockquote><p>究竟欧洲在现代早期培养了什么潜力，让它能在现代晚期称霸全球？这个问题有两个答案、相辅相成：现代科学和资本主义。</p></blockquote><blockquote><p>有一天，航天员受训的时候刚好碰到一位上了年纪的美国原住民。老人问他们在那里做什么。航天员说他们属于一个研究探险队，不久之后就要上月球了。听到他们这么说，老人沉吟了一会儿，问他们能不能帮个忙。“要帮什么忙呢？”他们问。“是这样的，我们族人都相信我们的圣灵住在月亮上。不知道你们能不能为我们族人带个重要的口信？”老人问。“要带什么话呢？”航天员问。这位老人用族语说了一串，并要求航天员重复再三，直到确定他们背得滚瓜烂熟为止。“这是什么意思？”航天员问。“啊，这个是族人和月亮上的圣灵之间的秘密。”等到航天员回了基地，好不容易才找到了一位会讲当地族语的人，希望能翻译这段话的意思。他们把这段话叽里咕噜背出来，让这位翻译简直笑翻了。等到翻译好不容易平静下来，航天员问他，这段话究竟说的是什么。翻译说，这些航天员费尽心力背下来的这句话是：“不管这些人跟您说什么，千万别相信他们。他们只是要来偷走您的土地。”</p></blockquote><blockquote><p>因此“美洲”这个名词就这样广为流传。说来也算是老天有眼，到头来，全球有1/4的陆地、七大洲之中的两洲，名字就是来自一个名不见经传的意大利人，而他唯一做的事就只是有勇气说出“我们不知道”。</p></blockquote><blockquote><p>阿兹特克的卫生水平远高于西班牙。西班牙人第一次来到墨西哥的时候，不论到了哪里，当地人都派人带着熏香随行。西班牙人原本以为这是代表无上的荣耀。但我们从当地文献发现，这其实是因为当地人觉得这些新来的人实在是臭不可闻。</p></blockquote><blockquote><p>梵语竟然和希腊文、拉丁文有惊人的相似之处，而且这些语言也都和哥特语、凯尔特语、古波斯语、德语、法语和英语若合符节。例如梵文的“母亲”是“matar”，而古凯尔特语则是“mathir”。据琼斯推测，所有这些语言一开始必定有共同的来源，那是个古老而已经被遗忘的语言祖先。就这样，他是第一个发现后来称为“印欧语系”这套体系的人。</p></blockquote><h2 id="第十六章-资本主义教条"><a href="#第十六章-资本主义教条" class="headerlink" title="第十六章 资本主义教条"></a>第十六章 资本主义教条</h2><blockquote><p>在1500年，全球商品和服务总产值约是2500亿美元；而今天是大约60兆美元。更重要的是，在1500年，每人年平均产值约为550美元，但今天不论男女老幼，每人年平均产值高达8800美元。</p></blockquote><blockquote><p>“信任”就是世上绝大多数金钱的唯一后盾。</p></blockquote><p>原来是这个逻辑。 明天不一定比之前好，所以觉得财富总量有限，所以限制商人，一个人集中了财富就等于其他人损失了财富。</p><blockquote><p>正因如此，许多文化都认为赚大钱是种罪恶</p></blockquote><blockquote><p>1776年，苏格兰经济学家亚当·斯密出版了《国富论》，这可以说是史上最重要的经济学著作。在《国富论》的第一卷第八章，亚当·斯密提出了以下的创新论述：如果地主、织工或鞋匠赚得的利润高于养家糊口基本所需，就会雇用更多助手，好进一步提高自己的利润。利润越高，能雇的助手也越多。由此可见，民间企业的获利正是社会整体财富和繁荣的基础。</p></blockquote><blockquote><p>他其实告诉我们：贪婪是好的，而且我们让自己过得好的时候，不只是自己得利，还能让他人受益。“利己”就是“利他”。</p></blockquote><blockquote><p>现代资本主义经济的一大重点，就在于出现了一种新的道德标准：应该把利润拿出来，继续投资生产。</p></blockquote><blockquote><p>新的资本主义教条里，最神圣的开宗明义第一条就是：“生产的利润，必须再投资于提高产量。”</p></blockquote><p>作者对未来还是担忧的</p><blockquote><p>一切指望，就在于那些实验室里的人。像是生物科技、纳米科技的新发现，就可能创造出全新的产业，带来庞大的利润，于是就能拿来打平那些银行和政府从2008年以来虚拟创造出的几万亿数字。而如果实验室的脚步不敌泡沫破灭的速度，可以想见经济前景就会令人十分担忧。</p></blockquote><p>华尔街的来历</p><blockquote><p>荷兰的西印度公司（WIC）也在大西洋大展身手。为了掌控哈德孙河这个重要商业通道，西印度公司在河口的一座小岛上开拓了一个殖民地，名为“新阿姆斯特丹”（New Amsterdam）。这个殖民地不断遭受美国原住民威胁，英国人也多次入侵，最后在1664年落入英国手中。英国人将这个城市改名“纽约”（New York，即“新约克”，约克为英国郡名）。当时西印度公司曾在殖民地筑起一道墙，用来抵御英国人和美国原住民，这道墙的位置现在成了世界上最著名的街道：华尔街（Wall Street，直译为“墙街”）。<br>密西西比公司利用其政治影响力操纵股价、推动购买热潮，结果让法国人民对法国金融系统和国王的金融智慧都失去信心。路易十五越来越难推动各种信贷计划，而这也成为法国海外领土逐渐落入英国手中的主因之一。</p></blockquote><blockquote><p>在中世纪，糖在欧洲是难得的奢侈品，必须由中东进口，而且价钱令人咋舌，使用的时候百般珍惜，视为某种秘密成分，加进各种美食或是蛇油为底的药物中。等到美洲开始有了一片又一片的大型甘蔗园，就开始有越来越多的糖运抵欧洲。糖价开始下跌，而欧洲对甜食也越来越贪得无厌。</p></blockquote><blockquote><p>这是自由市场资本主义美中不足之处。它无法保证利润会以公平的方式取得或是以公平的方式分配。而且相反的是，因为人类有追求利润和经济成长的渴望，就会决定盲目扫除一切可能的阻挠。等到“成长”成了无上的目标、不受其他道德伦理考虑的制衡，就很容易衍生成一场灾难。</p></blockquote><blockquote><p>有一些宗教（例如基督教和纳粹）杀害了数百万人，原因是出于仇恨。然而，资本主义也杀害了数百万人，原因则是出于冷漠和贪婪</p></blockquote><h2 id="第十七章-工业的巨轮"><a href="#第十七章-工业的巨轮" class="headerlink" title="第十七章 工业的巨轮"></a>第十七章 工业的巨轮</h2><p>能量转化靠人</p><blockquote><p>在当时想要转换能量，只能靠一种东西：人类或动物自己的身体。在自然的代谢过程里，人类和其他动物燃烧有机燃料（也就是食物），把能量转换为肌肉运动。于是，男男女女或动物摄取谷物和肉类，燃烧碳水化合物和脂肪，再用这些能量来拉车或犁田。</p></blockquote><blockquote><p>由此看来，历史上人类成就的几乎所有事情，第一步靠的都是将植物取得的太阳能转换为肌肉的力量。</p></blockquote><blockquote><p>每次有哪个家庭主妇或仆人想要烧水泡茶，或是把装满了马铃薯的锅放在炉子上煮，这项发明就这样明显地在他们眼前。在水煮沸的那一刻，水壶或锅的盖子会开始跳上跳下。这时热能转换为动能，但是我们过去都只觉得这样乱跳有点烦人，至于一时忘记而让水煮干就更麻烦了。没人注意到这件事的真正潜力。</p></blockquote><blockquote><p>直到后来（起因可能是某些炸弹专家在研钵里磨火药，磨杵却被大力炸飞？），才终于发明了枪</p></blockquote><blockquote><p>1830年9月15日，第一条商业化铁路开通，连接了利物浦与曼彻斯特，用的同样是与抽水或纺织相同的蒸汽动力。</p></blockquote><blockquote><p>工业革命的核心，其实就是能源转换的革命。</p></blockquote><blockquote><p>如果与太阳任何一天放射出的能量相比，全球所有化石燃料所储存的能源简直是微不足道。太阳的能量只有一小部分会到达地球，但即使是这一小部分，就已经高达每年3766800艾焦（焦耳是能量单位，在地心引力下将一颗小苹果抬升一米，所需的能量就是一焦耳；至于艾焦则是1018焦耳，这可是很多很多颗苹果。）全球所有植物进行光合作用，也只能保留大约3000艾焦的能量。现在人类所有活动和产业每年约消耗500艾焦，而地球只要大约短短90分钟，就能从太阳接收到这么多能量。</p></blockquote><blockquote><p>19世纪60年代，法国皇帝拿破仑三世还会用铝质餐具来宴请最尊贵的客人，至于那些二等的客人，就只能用黄金的刀叉来凑合凑合。</p></blockquote><blockquote><p>工业革命最重要的一点，其实在于它就是第二次的农业革命。</p></blockquote><blockquote><p>猪的智商和好奇心在哺乳动物里数一数二，可能只低于巨猿。</p></blockquote><blockquote><p>大西洋奴隶贸易并非出于对非洲人的仇恨，而现代畜牧业也同样不是出于对动物的仇恨。这两者背后共同的推手，就是冷漠。</p></blockquote><blockquote><p>随着农业工业化，只需要越来越少的农民数量，就足以养活越来越多的办公或工厂人口。</p></blockquote><blockquote><p>正是因为农业释放出了数十亿的人力，由工厂和办公室吸纳，才开始像雪崩一样有各种新产品倾泻而出</p></blockquote><blockquote><p>资本主义和消费主义的伦理可以说是一枚硬币的正反两面，将这两种秩序合而为一。有钱人的最高指导原则是——“投资！”而我们这些其他人的最高指导原则则是——“购买！”</p></blockquote><h2 id="第十八章-一场永远的革命"><a href="#第十八章-一场永远的革命" class="headerlink" title="第十八章 一场永远的革命"></a>第十八章 一场永远的革命</h2><blockquote><p>工业革命找出新方法来进行能量转换和商品生产，于是人类对于周遭生态系统的依赖大减</p></blockquote><blockquote><p>工业革命不仅为人类带来了时刻表和生产线的概念，更将这些概念推广到几乎所有的人类活动当中</p></blockquote><blockquote><p>因为火车的速度比传统马车快上太多，所以各地时间的微小差异就造成了巨大的困扰。1847年，英国各家火车业者齐聚一堂，研拟同意统一协调所有火车时刻表，一概以格林尼治天文台的时间为准，而不再遵循利物浦、曼彻斯特、格拉斯哥或任何其他城市的当地时间</p></blockquote><blockquote><p>最后在1880年，英国政府迈出了前所未有的一步，立法规定全英国的时刻表都必须以格林尼治时间为准。这是史上第一次有国家采取了全国统一的时刻表，要求人民依据人工的时钟来过生活，而不是依据当地的日升日落周期有所调整。</p></blockquote><blockquote><p>这一切都比不上有史以来人类最大的社会革命：家庭和地方社群崩溃，改由国家和市场取代。</p></blockquote><blockquote><p>很多时候，王国和帝国就像是收着保护费的黑道集团。国王就是黑道大哥，收了保护费就得罩着自己的人民，不受附近其他黑道集团或当地小混混骚扰。除此之外，其实也没什么功用。</p></blockquote><blockquote><p>随着时间过去，国家和市场的权力不断扩大，也不断削弱家庭和社群过去对成员的紧密连接。国家开始派出警察，制止家族里的私刑，改用法院判决取代。市场也派出小贩和商人，让各地悠久的传统逐渐消失，只剩下不断汰换的流行商业文化。</p></blockquote><blockquote><p>国家与市场找上家庭和社群的各个成员，开出了他们无法拒绝的条件。他们说：“做自己吧！想娶想嫁都随你的意，别管父母准不准。想挑什么工作都可以，别担心什么大家长说的话。想住哪就住哪，就算没办法每周和家人吃上一次饭又有什么关系呢？你不用再依赖家庭或社群了。我们，也就是国家和市场，让我们来照顾你吧。我们会给你食物、住房、教育、保健、福利和就业机会。我们也会给你退休金、保险和保障。”</p></blockquote><blockquote><p>市场和国家要增强这些情感面，靠的就是塑造“想象的社群”（imagined communities，另译“想象的共同体”<br>现代所兴起的两大想象社群，就是“民族”和“消费大众”。所谓民族，是国家的想象社群。而所谓消费大众，则是市场的想象社群。</p></blockquote><blockquote><p>我们现在之所以有叙利亚人、黎巴嫩人、约旦人、伊拉克人的区别，只是因为当初英法两国的外交官在完全不顾当地历史、地理和经济的情况下，在一片沙漠之中确定出了所谓的边界。</p></blockquote><p>宏观角度</p><blockquote><p>我们比较容易体会个人的辛酸，而不是人类整体的苦难。但为了从宏观角度来看历史进程，我们需要看整体统计数据，而不只是看个人的故事而已。在公元2000年，全球战争造成31万人丧生，而暴力犯罪造成52万人死亡。当然，对每一个受害者来说这都是世界的毁灭，家破人亡，朋友和亲戚悲痛欲绝。但从宏观的角度来看，在2000年总共83万的死亡者只占了全球5600万总死亡人数的1.5%。在同样一年，车祸死亡的人数达到126万（占总死亡人数2.25%），自杀人数达81.5万（占总死亡人数1.45%）</p></blockquote><p>恐怖平衡</p><blockquote><p>如果说有个最高诺贝尔和平奖，应该把奖颁给罗伯特·奥本海默以及和他一起研发出原子弹的同事。有了核武器之后，超级大国之间如果再开战，无异等于集体自杀。因此，想要武力征服全球也成了不可能的任务。其次，正因为战争的成本飙升，也就代表其利润下降。</p></blockquote><blockquote><p>虽然现在世界上仍然偶尔会发生大规模国际战争（例如伊拉克入侵科威特），但原因在于这些地方的财富多半属于传统的实质财富。</p></blockquote><blockquote><p>同时，虽然战争已经不再那么有利可图，但和平却成了一笔越来越划算的生意。在过去的农业经济中，长途贸易和外国投资并非重点，因此和平顶多只是省下战争费用，其他并无太大好处。</p></blockquote><blockquote><p>最后一项重点，在于全球政治文化也有了结构性的大变动。</p></blockquote><blockquote><p>现在有四大因素形成了一个良性循环。核子末日的威胁促进了和平主义；和平主义大行其道，于是战争退散、贸易兴旺；贸易成长，也就让和平的利润更高，而战争的成本也更高。</p></blockquote><h2 id="第十九章-从此过着幸福快乐的日子"><a href="#第十九章-从此过着幸福快乐的日子" class="headerlink" title="第十九章 从此过着幸福快乐的日子"></a>第十九章 从此过着幸福快乐的日子</h2><h3 id="快感"><a href="#快感" class="headerlink" title="快感"></a>快感</h3><blockquote><p>目前有一项耐人寻味的结论：金钱确实会带来快乐，但是有一定限度，超过限度之后的效果就不那么明显。所以，对于在经济阶层底层的人来说，确实是钱越多就越快乐。</p></blockquote><p>知足常乐</p><blockquote><p>快乐并不在于任何像是财富、健康甚至社群之类的客观条件，而在于客观条件和主观期望之间是否相符</p></blockquote><blockquote><p>如果说快乐要由期望来决定，那么我们社会的两大支柱（大众媒体和广告业）很有可能正在不知不觉地让全球越来越不开心。</p></blockquote><p>赚钱买门票啊</p><blockquote><p>穷人和受压迫者之所以还能自我安慰，就是因为死亡是唯一完全公平的事。不论再富有、权力再大，人也难逃一死。光是想到自己得死，但有钱人居然能长生不老，就会让穷人怒火中烧、不可遏抑。</p></blockquote><blockquote><p>我们能够快乐的唯一原因，就是身体内发出快感的感官感受。</p></blockquote><blockquote><p>演化就把快感当成奖赏，鼓励男性和女性发生性行为、将自己的基因传下去。如果性交没有高潮，大概很多男性就不会那么热衷。但同时，演化也确保高潮得迅速退去。如果性高潮永续不退，可以想象男性会非常开心，但连觅食的动力都没了，最后死于饥饿</p></blockquote><blockquote><p>我们就不用再浪费时间处理政治和社会改革、叛乱和意识形态，而是开始全力研究唯一能真正让我们快乐的方法：操纵人类的生化机制</p></blockquote><p>以后人类就插着管子 戴着VR活着好了</p><blockquote><p>百忧解（Prozac）之所以让人不再沮丧，靠的就不是对任何体制的改革，而只是提高血清素的浓度。</p></blockquote><h3 id="赋予生命意义"><a href="#赋予生命意义" class="headerlink" title="赋予生命意义"></a>赋予生命意义</h3><blockquote><p>正如尼采所言，只要有了活下去的理由，几乎什么都能够忍受。生活有意义，就算在困境中也能甘之如饴；生活无意义，就算在顺境中也度日如年。</p></blockquote><blockquote><p>从我们所知的纯粹科学角度来看，人类的生命本来就完全没有意义。人类只是在没有特定目标的演化过程中，盲目产生的结果。人类的行动没有什么神圣的整体计划，而且如果整个地球明天早上就爆炸消失，整个宇宙很可能还是一样这么继续运行下去。</p></blockquote><blockquote><p>我们对生活所赋予的任何意义，其实都只是错觉</p></blockquote><blockquote><p>如果快乐是在于感受快感，想要更快乐，就得操纵我们的生化系统。如果快乐是在于觉得生命有意义，想要更快乐，就得要骗自己骗得更彻底</p></blockquote><blockquote><p>DNA就像撒旦，用一些稍纵即逝的快乐作为引诱，令人为之臣服。</p></blockquote><h3 id="放下追求主观感受"><a href="#放下追求主观感受" class="headerlink" title="放下追求主观感受"></a>放下追求主观感受</h3><blockquote><p>佛教认为，快乐既不是主观感受到愉悦，也不是主观觉得生命有意义，反而是在于放下追求主观感受这件事。</p></blockquote><blockquote><p>苦的根源既不在于感到悲伤或疼痛，也不在于感觉一切没有意义。苦真正的根源就在于“追求”主观感受这件事，不管追求的是什么，都会让人陷入持续的紧张、困惑和不满之中。</p></blockquote><blockquote><p>人想要离苦得乐，就必须了解自己所有的主观感受都只是一瞬间的波动，而且别再追求某种感受。如此一来，虽然感受疼痛，但不再感到悲惨；虽然愉悦，但不再干扰心灵的平静。于是，心灵变得一片澄明、自在。这样产生的心灵平静力量强大，那些穷极一生疯狂追求愉悦心情的人完全难以想象。这就像是有人已经在海滩上站了数十年，总是想抓住“好的海浪”，让这些海浪永远留下来，同时又想躲开某些“坏的海浪”，希望这些海浪永远别靠近。就这样一天又一天，这个人站在海滩上徒劳无功，被自己累得几近发疯。最后终于气力用尽，瘫坐在海滩上，让海浪就这样自由来去。忽然发现，这样多么平静啊！</p></blockquote><h2 id="第二十章-智人末日"><a href="#第二十章-智人末日" class="headerlink" title="第二十章 智人末日"></a>第二十章 智人末日</h2><blockquote><p>达尔文理论美妙的地方，就是并不需要有某位智慧过人的设计者来解释为什么长颈鹿会有长脖子。</p></blockquote><blockquote><p>经过40亿年的自然选择之后，阿巴可说是站在新时代曙光乍现的时间点，生命即将改由智能设计来操控</p></blockquote><blockquote><p>有三种方式可能让智慧设计取代自然选择：<br>生物工程（biological engineering）、<br>仿生工程（cyborg engineering）与<br>无机生命（inorganic life）工程。</p></blockquote><h3 id="生物工程"><a href="#生物工程" class="headerlink" title="生物工程"></a>生物工程</h3><blockquote><p>所谓生物工程，指的是人类刻意在生物层次进行的干预行为（例如植入基因），目的在于改变生物体的外形、能力、需求或欲望，以实现某些预设的文化概念（例如爱德华多·卡茨心中的那种艺术）。</p></blockquote><blockquote><p>在英文里，未阉割的公牛称为“bull”，阉割后的称为“ox”，这种将牛阉割的做法已经有大约一万年之久，阉割后的牛比较不具侵略性，也就比较容易训练拉犁。</p></blockquote><p>人类可以让尼安德特人再现，可以改变人类的生理、免疫系统和寿命长短。</p><blockquote><p>许多人都认为，现在人类太快看到太多的机会，手中已经握有基因修改能力，却还无法做出明智、有远见的决定。</p></blockquote><blockquote><p>由俄罗斯、日本和韩国组成的科学家团队最近已经完成长毛象的基因定序。他们正在计划要拿一个现代大象的受精卵细胞，将大象的DNA换成长毛象DNA，再重新植回大象的子宫。只要再经过大约22个月，长毛象就能在绝迹近5000年后再次重现于地球。</p></blockquote><h3 id="仿生工程"><a href="#仿生工程" class="headerlink" title="仿生工程"></a>仿生工程</h3><blockquote><p>仿生工程结合有机和无机组织，创造出“生化人”（cyborg），例如为人类装上生化手就是一例。</p></blockquote><p>这不是三体人吗？</p><blockquote><p>在所有目前进行的研究当中，最革命性的就是要建构一个直接的大脑–计算机双向接口，让计算机能够读取人脑的电子信号，并且同时输回人脑能够了解的电子信号。如果这种设备成功，再直接将大脑连上网络，或是让几个大脑彼此相连，形成“脑际网络”，情况会如何？</p></blockquote><h3 id="无机生命"><a href="#无机生命" class="headerlink" title="无机生命"></a>无机生命</h3><blockquote><p>创造完全无机的生命。最明显的例子，就是能够自行独立演化的计算机程序和计算机病毒。<br>基因程序设计（genetic programming）</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在历史的路上，有三大重要革命：大约7万年前，“认知革命”（Cognitive Revolution）让历史正式启动。大约12000年前，“农业革命”（Agricultural Revolution）让历史加速发展。而到了大约不过是500年前，“科学革命”（Scientific Revolution）可以说是让历史画下句点而另创新局。这本书的内容，讲述的就是这三大革命如何改变了人类和其他生物。&lt;/p&gt;
    
    </summary>
    
      <category term="reading-notes" scheme="https://www.wuchenxu.com/categories/reading-notes/"/>
    
    
      <category term="reading-notes" scheme="https://www.wuchenxu.com/tags/reading-notes/"/>
    
      <category term="history" scheme="https://www.wuchenxu.com/tags/history/"/>
    
  </entry>
  
  <entry>
    <title>Rust语言(3):引用依赖库</title>
    <link href="https://www.wuchenxu.com/2017/01/25/Rust-lang-3-crate/"/>
    <id>https://www.wuchenxu.com/2017/01/25/Rust-lang-3-crate/</id>
    <published>2017-01-25T14:13:03.000Z</published>
    <updated>2017-07-16T13:17:36.000Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=396696&auto=0&height=66"></iframe><p><a href="https://crates.io/" target="_blank" rel="noopener">crate.io</a>是Rust社区的中心package仓库，该仓库有各种不同功能的Rust软件库。</p><p>（过年喽，年前最后一篇了，还有很多坑没填。2017，Year of Rooster，加油，fighting！）</p><a id="more"></a><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p><a href="https://crates.io/" target="_blank" rel="noopener">crate.io</a>是Rust社区的中心package仓库，<code>cargo</code>用来管理package，下载、版本管理、编译、运行依赖的packages。<br><code>crate</code>本身是<code>木箱</code>的意思，而<code>cargo</code>有<code>货运</code>的意思，<code>cargo</code>承载着各种<code>货物</code>，其中有一些是封装好的<code>木箱</code>。这个比喻倒也贴切。</p><h1 id="add-package"><a href="#add-package" class="headerlink" title="add package"></a>add package</h1><h2 id="packages-from-crate-io"><a href="#packages-from-crate-io" class="headerlink" title="packages from crate.io"></a>packages from crate.io</h2><p>使用Rust（当前版本<code>1.14.0</code>）过程中，如果需要使用一些非核心库（Rust的核心库功能有限，使用到其他的库是大概率事件），则需要在<code>Cargo.toml</code>文件添加依赖的package。这些package可以是来自<a href="https://crates.io/" target="_blank" rel="noopener">crate.io</a>，或者<code>git仓库</code>，或者本地路径。</p><p>以下是一个从 crate.io 引用 crate 的例子，两个步骤：</p><ol><li><p>在 Cargo.toml 文件中增加dependencies的package名字以及版本。</p><figure class="highlight toml"><figcaption><span>Cargo.toml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">webbrowser</span> = <span class="string">"0.2.2"</span></span><br></pre></td></tr></table></figure></li><li><p>在rust源文件中引入 crate。</p><figure class="highlight rs"><figcaption><span>Rust import external crate</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> webbrowser;</span><br></pre></td></tr></table></figure></li></ol><h2 id="packages-from-git-repository"><a href="#packages-from-git-repository" class="headerlink" title="packages from git repository"></a>packages from git repository</h2><figure class="highlight toml"><figcaption><span>dependencies from git repository</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">rand</span> = &#123; git = <span class="string">"https://github.com/rust-lang-nursery/rand"</span>, branch = <span class="string">"next"</span> &#125;</span><br></pre></td></tr></table></figure><p>如果不加<code>branch=&quot;next&quot;</code>，则默认获取最新的commit，当然可以用<code>rev</code>、<code>tag</code>、<code>branch</code>来指定不同的版本。</p><h2 id="packages-from-local-path"><a href="#packages-from-local-path" class="headerlink" title="packages from local path"></a>packages from local path</h2><figure class="highlight toml"><figcaption><span>dependencies from local directory</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">my_crate_name</span> = &#123; path = <span class="string">"../my-crate-directory"</span>, version = <span class="string">"0.1.0"</span> &#125;</span><br></pre></td></tr></table></figure><p>如果不加<code>version=&quot;0.1.0&quot;</code>，则不会进行版本检查。</p><h1 id="package-version"><a href="#package-version" class="headerlink" title="package version"></a>package version</h1><h2 id="Semver"><a href="#Semver" class="headerlink" title="Semver"></a>Semver</h2><p>版本号<code>0.2.2</code>有讲究，这是符合<a href="http://semver.org/" target="_blank" rel="noopener">语义化版本控制(Semantic Versioning)</a>格式，这种格式制定了严格的版本号更新要求，严格遵守可以防止<code>dependency hell(依赖地狱)</code>问题。</p><blockquote><p>Given a version number MAJOR.MINOR.PATCH, increment the:<br>MAJOR version when you make incompatible API changes,<br>MINOR version when you add functionality in a backwards-compatible manner, and<br>PATCH version when you make backwards-compatible bug fixes.<br>Additional labels for pre-release and build metadata are available as extensions to the MAJOR.MINOR.PATCH format.</p></blockquote><h2 id="Caret-requirements"><a href="#Caret-requirements" class="headerlink" title="Caret requirements"></a>Caret requirements</h2><p>版本号还可以有另外一种crate格式，这种格式<code>^x.y.z</code>允许升级到与要求版本号兼容的最新版本上。</p><figure class="highlight plain"><figcaption><span>Crate format</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">^1.2.3 := &gt;=1.2.3 &lt;2.0.0</span><br><span class="line">^1.2 := &gt;=1.2.0 &lt;2.0.0</span><br><span class="line">^1 := &gt;=1.0.0 &lt;2.0.0</span><br><span class="line">^0.2.3 := &gt;=0.2.3 &lt;0.3.0</span><br><span class="line">^0.0.3 := &gt;=0.0.3 &lt;0.0.4</span><br><span class="line">^0.0 := &gt;=0.0.0 &lt;0.1.0</span><br><span class="line">^0 := &gt;=0.0.0 &lt;1.0.0</span><br></pre></td></tr></table></figure><h2 id="Tilde-requirements"><a href="#Tilde-requirements" class="headerlink" title="Tilde requirements"></a>Tilde requirements</h2><p>版本号还支持另一种Tilde格式，这种格式<code>~x.y.z</code>指定了最低版本号要求。</p><figure class="highlight plain"><figcaption><span>Tilde format</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~1.2.3 := &gt;=1.2.3 &lt;1.3.0</span><br><span class="line">~1.2   := &gt;=1.2.0 &lt;1.3.0</span><br><span class="line">~1     := &gt;=1.0.0 &lt;2.0.0</span><br></pre></td></tr></table></figure><h2 id="Wildcard-requirements"><a href="#Wildcard-requirements" class="headerlink" title="Wildcard requirements"></a>Wildcard requirements</h2><p>版本号支持通配符。</p><figure class="highlight plain"><figcaption><span>ver wildcard</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* := &gt;=0.0.0</span><br><span class="line">1.* := &gt;=1.0.0 &lt;2.0.0</span><br><span class="line">1.2.* := &gt;=1.2.0 &lt;1.3.0</span><br></pre></td></tr></table></figure><h1 id="build-a-project-with-dependencies"><a href="#build-a-project-with-dependencies" class="headerlink" title="build a project with dependencies"></a>build a project with dependencies</h1><p>我做的一个例子<a href="https://github.com/WuChenxu/Rust/tree/master/04_take_a_break" target="_blank" rel="noopener">take a break</a>，实现了每隔一段时间打开默认浏览器播放音乐功能，其中需要用到<code>webbrowser</code>库。</p><figure class="highlight sh"><figcaption><span>cargo build a project with depedencies</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;cargo build</span><br><span class="line">    Updating registry `https://github.com/rust-lang/crates.io-index`</span><br><span class="line"> Downloading webbrowser v0.2.2</span><br><span class="line">   Compiling webbrowser v0.2.2</span><br><span class="line">   Compiling take_a_break v0.1.0 (file:///Users/alta/github/Rust/04_take_a_break)</span><br><span class="line">    Finished debug [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.66 secs</span><br></pre></td></tr></table></figure><h1 id="update-a-project-with-dependencies"><a href="#update-a-project-with-dependencies" class="headerlink" title="update a project with dependencies"></a>update a project with dependencies</h1><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;cargo <span class="keyword">update</span></span><br><span class="line">    Updating registry `http<span class="variable">s:</span>//github.<span class="keyword">com</span>/rust-lang/crates.io-<span class="built_in">index</span>`</span><br></pre></td></tr></table></figure><p>Reference:</p><ol><li><a href="http://doc.crates.io/guide.html" target="_blank" rel="noopener">Cargo Guide</a></li><li><a href="https://github.com/steveklabnik/semver" target="_blank" rel="noopener">Rust semver</a></li><li><a href="http://semver.org/lang/zh-CN/" target="_blank" rel="noopener">semver</a></li><li><a href="https://github.com/WuChenxu/Rust/tree/master/04_take_a_break" target="_blank" rel="noopener">take a break</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=396696&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;a href=&quot;https://crates.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;crate.io&lt;/a&gt;是Rust社区的中心package仓库，该仓库有各种不同功能的Rust软件库。&lt;/p&gt;
&lt;p&gt;（过年喽，年前最后一篇了，还有很多坑没填。2017，Year of Rooster，加油，fighting！）&lt;/p&gt;
    
    </summary>
    
      <category term="Rust" scheme="https://www.wuchenxu.com/categories/Rust/"/>
    
    
      <category term="Rust" scheme="https://www.wuchenxu.com/tags/Rust/"/>
    
      <category term="crate" scheme="https://www.wuchenxu.com/tags/crate/"/>
    
  </entry>
  
  <entry>
    <title>软件开发(1):state machine</title>
    <link href="https://www.wuchenxu.com/2017/01/16/software-design-1-state-machine/"/>
    <id>https://www.wuchenxu.com/2017/01/16/software-design-1-state-machine/</id>
    <published>2017-01-16T13:23:45.000Z</published>
    <updated>2019-05-05T12:45:19.289Z</updated>
    
    <content type="html"><![CDATA[<p>FSM,HSM,Model-Base…</p><a id="more"></a><h1 id="state-machine"><a href="#state-machine" class="headerlink" title="state machine"></a>state machine</h1><h2 id="状态机是什么"><a href="#状态机是什么" class="headerlink" title="状态机是什么"></a>状态机是什么</h2><h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><h2 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h2><h1 id="FSM-Finite-State-Machine"><a href="#FSM-Finite-State-Machine" class="headerlink" title="FSM(Finite State Machine)"></a>FSM(Finite State Machine)</h1><h2 id="三段式"><a href="#三段式" class="headerlink" title="三段式"></a>三段式</h2><h2 id="状态转移表"><a href="#状态转移表" class="headerlink" title="状态转移表"></a>状态转移表</h2><h1 id="HSM-hierarchical-State-Machine"><a href="#HSM-hierarchical-State-Machine" class="headerlink" title="HSM(hierarchical State Machine)"></a>HSM(hierarchical State Machine)</h1><p>注意状态之间的同步</p><h1 id="Modeling"><a href="#Modeling" class="headerlink" title="Modeling"></a>Modeling</h1><p>design<br>integration<br>simulate<br>validation<br>generate code</p><h2 id="Matlab-Stateflow"><a href="#Matlab-Stateflow" class="headerlink" title="Matlab Stateflow"></a><a href="https://www.mathworks.com/products/stateflow.html" target="_blank" rel="noopener">Matlab Stateflow</a></h2><h2 id="YAKINDU-Statechart-Tools-SCT"><a href="#YAKINDU-Statechart-Tools-SCT" class="headerlink" title="YAKINDU Statechart Tools (SCT)"></a><a href="https://www.itemis.com/en/yakindu/statechart-tools/" target="_blank" rel="noopener">YAKINDU Statechart Tools (SCT)</a></h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;FSM,HSM,Model-Base…&lt;/p&gt;
    
    </summary>
    
      <category term="software" scheme="https://www.wuchenxu.com/categories/software/"/>
    
    
      <category term="software" scheme="https://www.wuchenxu.com/tags/software/"/>
    
      <category term="design" scheme="https://www.wuchenxu.com/tags/design/"/>
    
  </entry>
  
  <entry>
    <title>怎样开发一个产品</title>
    <link href="https://www.wuchenxu.com/2017/01/11/how-to-develop-a-product/"/>
    <id>https://www.wuchenxu.com/2017/01/11/how-to-develop-a-product/</id>
    <published>2017-01-11T14:02:34.000Z</published>
    <updated>2017-07-16T13:17:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>个人的一点看法，欢迎讨论。谢绝转载。</p><a id="more"></a><h1 id="逆向开发"><a href="#逆向开发" class="headerlink" title="逆向开发"></a>逆向开发</h1><p>如果是一个成熟产品，市面上有很多现成的产品，那么一个快速开发的捷径是”抄”。硬件可以模仿甚至抄板，软件可以通过学习市场上其他产品的功能，算法可以参考一些公开的论文，结合对其他产品的反向分析。<br>曾经有过极端的案例是，硬件抄板成一模一样，软件读出来，直接烧录进去就可以出货了。当然了这种极端的做法是侵犯了别人的知识产权，我是不支持的。</p><h1 id="正向开发"><a href="#正向开发" class="headerlink" title="正向开发"></a>正向开发</h1><p>按照顺序：</p><ol><li>定义问题</li><li>寻找解决方案</li><li>系统架构设计</li><li>硬件设计设计</li><li>软件架构设计</li><li>软件开发</li><li>软件测试</li><li>系统测试</li></ol><p>核心竞争力：建立开发（development）和系统性能调优（system preformance tuning）的能力（know-how，toolchain…）。<br>系统设计可以划分子系统，子系统下面可以划分子模块，每个模块可独立演进，每个模块的算法可以优化迭代。<br>软件模块开发可以考虑用基于模型的设计（Model-Based design），如Matlab，既可以做SIL（Software In the Loop）或者HIL（Hardware In the Loop），也可以生成代码在嵌入式设备中运行。<br>有前瞻性的预研团队，可以与高校或者研究所合作，确保技术上不断更新。<br>当然对汽车行业还要考虑更多：A-SPICE、ISO26262（functional safety），AUTOSAR。</p><h1 id="混合模式"><a href="#混合模式" class="headerlink" title="混合模式"></a>混合模式</h1><p>就算是已正向开发为主的大公司，也会进行所谓”竞争对手分析”，对比市场上的产品与一家产品的功能及性能差距，优点可以在向客户的推介材料里展示，缺点可以称为改进的方向，以确保产品在市场上有竞争力。<br>如果一家刚起步的公司两种方法：</p><ol><li>集中精力开发核心模块，其他模块都外包，如Mobieye专攻图像处理器和算法，可以集成到Tier1或者OEM的video里。</li><li>先逆向开发出产品，杀入市场，占领一部分市场，然后慢慢建立自己的正向研发能力，如国内主机厂，华为手机原来是白牌。</li></ol><p>reference：</p><ol><li><a href="https://en.wikipedia.org/wiki/Mobileye" target="_blank" rel="noopener">Mobieye</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;个人的一点看法，欢迎讨论。谢绝转载。&lt;/p&gt;
    
    </summary>
    
      <category term="product" scheme="https://www.wuchenxu.com/categories/product/"/>
    
    
      <category term="idea" scheme="https://www.wuchenxu.com/tags/idea/"/>
    
  </entry>
  
</feed>
